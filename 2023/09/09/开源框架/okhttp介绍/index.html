<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.18.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="# OkHttp源码分析  OkHttp是一个高效的客户端 Http 请求框架，OkHttp 是对 HTTP 协议的实现，在Android客户端开发被广泛使用。  支持Http1、Http2、Quic以及WebSocket 连接池复用底层TCP(Socket)，减少请求延时 无缝的支持GZIP减少数据流量 缓存响应数据减少重复的网络请求 请求失败自动重试主机的其他ip，自动重定向  学习OKht">
<meta property="og:type" content="article">
<meta property="og:title" content="okhttp介绍">
<meta property="og:url" content="http://example.com/2023/09/09/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/okhttp%E4%BB%8B%E7%BB%8D/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="# OkHttp源码分析  OkHttp是一个高效的客户端 Http 请求框架，OkHttp 是对 HTTP 协议的实现，在Android客户端开发被广泛使用。  支持Http1、Http2、Quic以及WebSocket 连接池复用底层TCP(Socket)，减少请求延时 无缝的支持GZIP减少数据流量 缓存响应数据减少重复的网络请求 请求失败自动重试主机的其他ip，自动重定向  学习OKht">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4538003-00d6440ffa1710e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="article:published_time" content="2023-09-09T15:38:16.000Z">
<meta property="article:modified_time" content="2023-09-11T11:02:55.898Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/4538003-00d6440ffa1710e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">


<link rel="canonical" href="http://example.com/2023/09/09/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/okhttp%E4%BB%8B%E7%BB%8D/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2023/09/09/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/okhttp%E4%BB%8B%E7%BB%8D/","path":"2023/09/09/开源框架/okhttp介绍/","title":"okhttp介绍"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>okhttp介绍 | Hexo</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#OkHttp-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.</span> <span class="nav-text">OkHttp 的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#OkHttpClient-%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.1.</span> <span class="nav-text">OkHttpClient 组件介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ConnectionPool-%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="nav-number">1.1.1.</span> <span class="nav-text">ConnectionPool(连接池)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EventListenerFactory-%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8%E5%B7%A5%E5%8E%82"><span class="nav-number">1.1.2.</span> <span class="nav-text">EventListenerFactory(事件监听器工厂)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#retryOnConnectionFailure"><span class="nav-number">1.1.3.</span> <span class="nav-text">retryOnConnectionFailure</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Authenticator-%E8%AE%A4%E8%AF%81%E5%99%A8"><span class="nav-number">1.1.4.</span> <span class="nav-text">Authenticator(认证器)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#followRedirects-%E5%92%8C-followSslRedirects"><span class="nav-number">1.1.5.</span> <span class="nav-text">followRedirects 和 followSslRedirects</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CookieJar-Cookie%E7%AE%A1%E7%90%86%E5%99%A8"><span class="nav-number">1.1.6.</span> <span class="nav-text">CookieJar(Cookie管理器)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cache-%E7%BC%93%E5%AD%98%E7%AE%A1%E7%90%86%E9%85%8D%E7%BD%AE"><span class="nav-number">1.1.7.</span> <span class="nav-text">Cache(缓存管理配置)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dns"><span class="nav-number">1.1.8.</span> <span class="nav-text">Dns</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Proxy-%E4%BB%A3%E7%90%86"><span class="nav-number">1.1.9.</span> <span class="nav-text">Proxy(代理)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PoxySelector-%E4%BB%A3%E7%90%86%E9%80%89%E6%8B%A9%E5%99%A8"><span class="nav-number">1.1.10.</span> <span class="nav-text">PoxySelector(代理选择器)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ProxyAuthenticator-%E4%BB%A3%E7%90%86%E8%AE%A4%E8%AF%81%E5%99%A8"><span class="nav-number">1.1.11.</span> <span class="nav-text">ProxyAuthenticator(代理认证器)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SocketFactory-%E5%92%8C-SSLSocketFactory"><span class="nav-number">1.1.12.</span> <span class="nav-text">SocketFactory 和 SSLSocketFactory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#X509TrustManager-%E8%AF%81%E4%B9%A6%E9%AA%8C%E8%AF%81%E5%99%A8"><span class="nav-number">1.1.13.</span> <span class="nav-text">X509TrustManager(证书验证器)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConnectionSpecs-TLS%E8%BF%9E%E6%8E%A5%E9%85%8D%E7%BD%AE"><span class="nav-number">1.1.14.</span> <span class="nav-text">ConnectionSpecs(TLS连接配置)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Protocols-HTTP%E5%8D%8F%E8%AE%AE%E7%AE%A1%E7%90%86"><span class="nav-number">1.1.15.</span> <span class="nav-text">Protocols(HTTP协议管理)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HostnameVerifier-%E4%B8%BB%E6%9C%BA%E5%90%8D%E9%AA%8C%E8%AF%81%E5%99%A8"><span class="nav-number">1.1.16.</span> <span class="nav-text">HostnameVerifier(主机名验证器)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CertificatePinner-%E8%AF%81%E4%B9%A6%E5%9B%BA%E5%AE%9A%E9%AA%8C%E8%AF%81"><span class="nav-number">1.1.17.</span> <span class="nav-text">CertificatePinner(证书固定验证)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CertificateChainCleaner-%E9%AA%8C%E8%AF%81%E6%93%8D%E4%BD%9C%E5%91%98"><span class="nav-number">1.1.18.</span> <span class="nav-text">CertificateChainCleaner(验证操作员)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TimeOut%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4"><span class="nav-number">1.1.19.</span> <span class="nav-text">TimeOut超时时间</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">请求流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E8%AF%B7%E6%B1%82%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D"><span class="nav-number">2.1.</span> <span class="nav-text">一、请求任务分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E6%8B%A6%E6%88%AA%E5%99%A8%E8%B4%A3%E4%BB%BB%E9%93%BE"><span class="nav-number">2.2.</span> <span class="nav-text">二、拦截器责任链</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82"><span class="nav-number">2.2.1.</span> <span class="nav-text">一次完整网络请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89Interceptor"><span class="nav-number">2.2.2.</span> <span class="nav-text">1、自定义Interceptor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E9%87%8D%E8%AF%95%E5%8F%8A%E9%87%8D%E5%AE%9A%E5%90%91%E6%8B%A6%E6%88%AA%E5%99%A8RetryAndFollowUpInterceptor"><span class="nav-number">2.2.3.</span> <span class="nav-text">2、重试及重定向拦截器RetryAndFollowUpInterceptor</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#enterNetworkInterceptorExchange-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">enterNetworkInterceptorExchange()初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#recover%E8%AF%B7%E6%B1%82%E9%87%8D%E8%AF%95"><span class="nav-number">2.2.3.1.1.</span> <span class="nav-text">recover请求重试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-number">2.2.3.1.2.</span> <span class="nav-text">重定向</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E6%A1%A5%E6%8E%A5%E6%8B%A6%E6%88%AA%E5%99%A8BridgeInterceptor"><span class="nav-number">2.2.4.</span> <span class="nav-text">3、桥接拦截器BridgeInterceptor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E7%BC%93%E5%AD%98%E6%8B%A6%E6%88%AA%E5%99%A8CacheInterceptor"><span class="nav-number">2.2.5.</span> <span class="nav-text">4、缓存拦截器CacheInterceptor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E8%BF%9E%E6%8E%A5%E6%8B%A6%E6%88%AA%E5%99%A8ConnectInterceptor"><span class="nav-number">2.2.6.</span> <span class="nav-text">5、连接拦截器ConnectInterceptor</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E8%BF%9E%E6%8E%A5%E6%B1%A0%E8%8E%B7%E5%8F%96%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B"><span class="nav-number">2.2.6.1.</span> <span class="nav-text">从连接池获取连接过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%AE%A1%E7%90%86"><span class="nav-number">2.2.6.2.</span> <span class="nav-text">连接池管理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5"><span class="nav-number">2.2.6.2.1.</span> <span class="nav-text">建立连接</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96HTTP%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="nav-number">2.2.6.3.</span> <span class="nav-text">获取HTTP编解码器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81NetworkInterceptor-%E7%BD%91%E7%BB%9C%E8%B0%83%E8%AF%95%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="nav-number">2.2.7.</span> <span class="nav-text">6、NetworkInterceptor 网络调试拦截器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%E3%80%81CallServerInterceptor"><span class="nav-number">2.2.8.</span> <span class="nav-text">7、CallServerInterceptor</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/09/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/okhttp%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="okhttp介绍 | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          okhttp介绍
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-09-09 15:38:16" itemprop="dateCreated datePublished" datetime="2023-09-09T15:38:16+00:00">2023-09-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-09-11 11:02:55" itemprop="dateModified" datetime="2023-09-11T11:02:55+00:00">2023-09-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><meta name="referrer" content="no-referrer" />
# OkHttp源码分析

<p>OkHttp是一个高效的客户端 Http 请求框架，OkHttp 是对 HTTP 协议的实现，在Android客户端开发被广泛使用。</p>
<blockquote>
<p>支持Http1、Http2、Quic以及WebSocket</p>
<p>连接池复用底层TCP(Socket)，减少请求延时</p>
<p>无缝的支持GZIP减少数据流量</p>
<p>缓存响应数据减少重复的网络请求</p>
<p>请求失败自动重试主机的其他ip，自动重定向</p>
</blockquote>
<p>学习OKhttp源码就要先看全局，然后根据使用需要再研究细节，体会其精妙之处。<br>了解它的原理，并加以实践，可以实现一个简单的HTTP请求客户端。</p>
<h1 id="OkHttp-的使用"><a href="#OkHttp-的使用" class="headerlink" title="OkHttp 的使用"></a>OkHttp 的使用</h1><p>OkHttpClient是 HTTP 协议中的<strong>请求方</strong>，使用 HTTP 协议获取网络上的各种资源，简单称为客户端，角色和浏览器一样。</p>
<p>OkHttpClient 中包含了各种组件，通过组合使用，实现HTTP请求。</p>
<p>Request 是OkHttp 的请求实体，可以封装各种请求参数。</p>
<p>通过<code>OkHttpClient.newCall()</code>创建出一个网络请求执行器<code>call</code>，有两种请求方式：</p>
<ul>
<li>调用<code>enqueue(callback)</code>实现异步请求，通过子线程请求，当请求完成，将响应结果通过回调函数传递。</li>
<li>调用<code>execute()</code> 实现同步请求，堵塞当前线程，直到请求完成，返回响应结果。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> client = OkHttpClient.Builder().build()</span><br><span class="line"><span class="comment">// 构建请求    </span></span><br><span class="line"><span class="keyword">val</span> request = Request.Builder()</span><br><span class="line">    .url(<span class="string">&quot;https://baidu.com&quot;</span>)</span><br><span class="line">    .build()</span><br><span class="line"><span class="comment">// 网络请求执行器    </span></span><br><span class="line"><span class="keyword">val</span> realCall = client.newCall(request)</span><br><span class="line"><span class="comment">// 执行异步请求    </span></span><br><span class="line"><span class="keyword">val</span> asyncResponse = realCall.enqueue(<span class="keyword">object</span> : Callback &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>, e: <span class="type">IOException</span>)</span></span> &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;okhttp&quot;</span>, <span class="string">&quot;请求失败&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>, response: <span class="type">Response</span>)</span></span> &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;okhttp&quot;</span>, <span class="string">&quot;请求成功&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 执行同步请求</span></span><br><span class="line"><span class="keyword">val</span> syncResponse = realCall.excute()   </span><br></pre></td></tr></table></figure>


<h2 id="OkHttpClient-组件介绍"><a href="#OkHttpClient-组件介绍" class="headerlink" title="OkHttpClient 组件介绍"></a>OkHttpClient 组件介绍</h2><p>要想了解OkHttp 如何实现 HTTP 协议完成网络请求之前，就先要了解 OkHttpClient 中的组件。</p>
<p>两大核心组件是： <strong>Dispatcher(分发器）和 Interceptor(拦截器)</strong> ，这两个着重介绍，它们和OkHttp请求流程息息相关，下面先看看其他组件。</p>
<h3 id="ConnectionPool-连接池"><a href="#ConnectionPool-连接池" class="headerlink" title="ConnectionPool(连接池)"></a>ConnectionPool(连接池)</h3><p>连接池和线程池类似，批量管理 TCP 连接，通过重用和自动回收，实现性能和资源占用的动态平衡。</p>
<p>TCP连接使用完成后不会被直接销毁，而是重新放回到连接池中，等待下次 HTTP 请求使用。</p>
<p>同时连接池中会制定规则，自动回收无用的连接，释放资源。如此就实现了连接的复用，防止一有HTTP请求就重新创建新的连接。</p>
<h3 id="EventListenerFactory-事件监听器工厂"><a href="#EventListenerFactory-事件监听器工厂" class="headerlink" title="EventListenerFactory(事件监听器工厂)"></a>EventListenerFactory(事件监听器工厂)</h3><p>对如连接事件，域名解析成功事件等设置监听器。</p>
<h3 id="retryOnConnectionFailure"><a href="#retryOnConnectionFailure" class="headerlink" title="retryOnConnectionFailure"></a>retryOnConnectionFailure</h3><p>这是一个bool值，当连接、请求失败时，OkHttp是否重试，默认为true。注意请求失败，比如返回状态码500等，不符合重试条件。<br>需要是「同一个域名的多个IP重试」，「Socket连接失败」。</p>
<h3 id="Authenticator-认证器"><a href="#Authenticator-认证器" class="headerlink" title="Authenticator(认证器)"></a>Authenticator(认证器)</h3><p>用于自动重新认证，配置之后当请求收到 401 未授权的状态码后，会直接调用 <code>authenticator</code> ，手动加入请求头字段<code>Authenticator</code>，重新发起请求。</p>
<p>比如当token 过期时，可以配置 <code>authenticator</code> 重新获取新的token，添加到请求头中，再次发起请求。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> client = OkHttpClient.Builder()</span><br><span class="line">    .authenticator(Authenticator &#123; route, response -&gt;</span><br><span class="line">        <span class="keyword">val</span> request = response.request</span><br><span class="line">        <span class="comment">// TODO 重新请求服务器新的token</span></span><br><span class="line">        <span class="keyword">val</span> newToken = requestToken()</span><br><span class="line">        request.newBuilder()</span><br><span class="line">            .addHeader(<span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;Bearer <span class="subst">$&#123;newToken&#125;</span>&quot;</span>)</span><br><span class="line">            .build()</span><br><span class="line">    &#125;)</span><br><span class="line">    .build()</span><br></pre></td></tr></table></figure>



<h3 id="followRedirects-和-followSslRedirects"><a href="#followRedirects-和-followSslRedirects" class="headerlink" title="followRedirects 和 followSslRedirects"></a>followRedirects 和 followSslRedirects</h3><p>这两个都是bool值。</p>
<p>followRedirects，表示是否重定向，跳转到 301 返回的 location url，默认为true。</p>
<p>followSslRedirects，在上面 followRedirects 为true 的基础上，当协议发生切换时，是否依然需要重定向，默认为true。</p>
<p>比如请求的网址是<code>http://baidu.com</code>，重定向需要跳转的网址为<code>https:baidu.com</code>，由http协议变成了https协议。</p>
<h3 id="CookieJar-Cookie管理器"><a href="#CookieJar-Cookie管理器" class="headerlink" title="CookieJar(Cookie管理器)"></a>CookieJar(Cookie管理器)</h3><p>OkHttp 提供了 Cookie 的存取管理类，但和浏览器不同，<code>CookieJar</code> 中没有实现存取的逻辑（什么时候存Cookie，什么时候取Cookie，需要自己实现）。</p>
<p>在OkHttp 中CookieJar的默认实现为<code>NoCookies</code>，里面什么也没有，返回的也是空List，不像浏览器会自动存储请求响应的Cookie。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> NO_COOKIES: CookieJar = NoCookies()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">NoCookies</span> : <span class="type">CookieJar</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">saveFromResponse</span><span class="params">(url: <span class="type">HttpUrl</span>, cookies: <span class="type">List</span>&lt;<span class="type">Cookie</span>&gt;)</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadForRequest</span><span class="params">(url: <span class="type">HttpUrl</span>)</span></span>: List&lt;Cookie&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> emptyList()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以如果需要管理Cookie，需要在OkHttpClient 中配置，并且实现一个CookieJar，编写条件，可以用<code>Map</code>保存在内存中，用<code>SharedPreferences</code>保存在文件中。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> client = OkHttpClient.Builder()</span><br><span class="line">    .cookieJar(<span class="keyword">object</span> : CookieJar &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadForRequest</span><span class="params">(url: <span class="type">HttpUrl</span>)</span></span>: List&lt;Cookie&gt; &#123;</span><br><span class="line">            <span class="comment">// 返回Cookie的逻辑</span></span><br><span class="line">            <span class="keyword">return</span> map.<span class="keyword">get</span>(url)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">saveFromResponse</span><span class="params">(url: <span class="type">HttpUrl</span>, cookies: <span class="type">List</span>&lt;<span class="type">Cookie</span>&gt;)</span></span> &#123;</span><br><span class="line">            <span class="comment">// TODO 存取Cookie的逻辑</span></span><br><span class="line">            map.put(url, cookies)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).build()</span><br></pre></td></tr></table></figure>


<h3 id="Cache-缓存管理配置"><a href="#Cache-缓存管理配置" class="headerlink" title="Cache(缓存管理配置)"></a>Cache(缓存管理配置)</h3><p>缓存用于保存服务器的响应结果，下次相同请求时可以直接使用。Cache，默认是空实现，需要自己配置Cache存储的文件位置和存储空间上限。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val client = OkHttpClient.Builder()</span><br><span class="line">    .cache(Cache(File(Environment.getDownloadCacheDirectory(), &quot;cache&quot;), 100*1024*1024))</span><br><span class="line">    .build()</span><br></pre></td></tr></table></figure>


<h3 id="Dns"><a href="#Dns" class="headerlink" title="Dns"></a>Dns</h3><p>Dns负责将主机名解析成IP地址，默认使用JDK中的<code>InetAddress.getAllByName(hostname).toList()</code>。</p>
<h3 id="Proxy-代理"><a href="#Proxy-代理" class="headerlink" title="Proxy(代理)"></a>Proxy(代理)</h3><p>表示请求代理设置，有三种类型</p>
<ul>
<li><code>DIRECT</code>,直连模式，直接和目标服务器通信，中间没有代理服务器</li>
<li><code>HTTP</code>, 代理模式，客户端请求代理服务器，代理服务器HTTP协议转发HTTP数据包给目标服务器。</li>
<li><code>SOCKS</code>，代理模式，通过Socks服务器和目标服务器通信，Socks代理只是简单地转发数据包(传输层)，而不必关心是何种应用协议（比如FTP、HTTP和NNTP请求）。</li>
</ul>
<h3 id="PoxySelector-代理选择器"><a href="#PoxySelector-代理选择器" class="headerlink" title="PoxySelector(代理选择器)"></a>PoxySelector(代理选择器)</h3><p>代理选择器，根据你要连接的URL自动选择最合适的代理。如果需要编写定制代理选择器，需要继承并实现<code>select</code>方法。</p>
<p>默认实现为<code>NullProxySelector</code>，默认返回直连模式，即不使用代理。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NullProxySelector</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">select</span><span class="params">(uri: <span class="type">URI</span>?)</span></span>: List&lt;Proxy&gt; &#123;</span><br><span class="line">    requireNotNull(uri) &#123; <span class="string">&quot;uri must not be null&quot;</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> listOf(Proxy.NO_PROXY)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Proxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> static Proxy NO_PROXY = new Proxy();</span><br><span class="line"><span class="comment">// Creates the proxy that represents a &#123;@code DIRECT&#125; connection.</span></span><br><span class="line"><span class="keyword">private</span> Proxy() &#123;</span><br><span class="line">    type = Type.DIRECT</span><br><span class="line">    sa = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="ProxyAuthenticator-代理认证器"><a href="#ProxyAuthenticator-代理认证器" class="headerlink" title="ProxyAuthenticator(代理认证器)"></a>ProxyAuthenticator(代理认证器)</h3><p>和上面的<code>authenticator</code>类似，针对代理服务器做授权处理。</p>
<h3 id="SocketFactory-和-SSLSocketFactory"><a href="#SocketFactory-和-SSLSocketFactory" class="headerlink" title="SocketFactory 和 SSLSocketFactory"></a>SocketFactory 和 SSLSocketFactory</h3><p>Socket连接工程，当需要TCP连接建立时，提供Socket服务。</p>
<p>SSLSocketFactory针对HTTPS 请求，在TCP连接基础上再建立一个TLS连接，提供SSLSocket</p>
<h3 id="X509TrustManager-证书验证器"><a href="#X509TrustManager-证书验证器" class="headerlink" title="X509TrustManager(证书验证器)"></a>X509TrustManager(证书验证器)</h3><p>X509表示证书格式，当建立HTTPS连接时，需要验证服务端证书签名，证书签发机构证书签名，根证书签名，这些工作都是由 X509TrustManager 完成。</p>
<h3 id="ConnectionSpecs-TLS连接配置"><a href="#ConnectionSpecs-TLS连接配置" class="headerlink" title="ConnectionSpecs(TLS连接配置)"></a>ConnectionSpecs(TLS连接配置)</h3><p>Https 建立连接时，客户端需要发送支持的TLS版本协议 和 对称加密、非对称加密、摘要(hash)算法套件。</p>
<p>默认使用<code>MODERN_TLS</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">val MODERN_TLS = Builder(true)</span><br><span class="line">    .cipherSuites(*APPROVED_CIPHER_SUITES)</span><br><span class="line">    .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2)</span><br><span class="line">    .supportsTlsExtensions(true)</span><br><span class="line">    .build()</span><br><span class="line">    </span><br><span class="line">// 明文，不加密    </span><br><span class="line">val CLEARTEXT = Builder(false).build()    </span><br></pre></td></tr></table></figure>



<h3 id="Protocols-HTTP协议管理"><a href="#Protocols-HTTP协议管理" class="headerlink" title="Protocols(HTTP协议管理)"></a>Protocols(HTTP协议管理)</h3><p>http协议版本管理，如HTTP&#x2F;1.0、HTTP&#x2F;1.1、HTTP&#x2F;2等</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP_1_0(&quot;http/1.0&quot;),</span><br><span class="line">HTTP_1_1(&quot;http/1.1&quot;),</span><br><span class="line">HTTP_2(&quot;h2&quot;),</span><br><span class="line">H2_PRIOR_KNOWLEDGE(&quot;h2_prior_knowledge&quot;),</span><br><span class="line">QUIC(&quot;quic&quot;);</span><br></pre></td></tr></table></figure>



<h3 id="HostnameVerifier-主机名验证器"><a href="#HostnameVerifier-主机名验证器" class="headerlink" title="HostnameVerifier(主机名验证器)"></a>HostnameVerifier(主机名验证器)</h3><p>用于验证HTTPS 握手中服务端证书中的主机名 是否和 客户端请求的主机一致。</p>
<h3 id="CertificatePinner-证书固定验证"><a href="#CertificatePinner-证书固定验证" class="headerlink" title="CertificatePinner(证书固定验证)"></a>CertificatePinner(证书固定验证)</h3><p>用于设置HTTPS 握手过程中针对某个在Host 额外的 Certificate Public Key Pinner，即把网站证书链中的每一个证书公钥直接拿来提前配置进 OkHttpClient 里去、作为正常证书验证机制外的一次额外验证，一般不使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">hostname</span> <span class="operator">=</span> <span class="string">&quot;publicobject.com&quot;</span>;</span><br><span class="line"><span class="type">CertificatePinner</span> <span class="variable">certificatePinner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CertificatePinner</span>.Builder()</span><br><span class="line">    .add(hostname, <span class="string">&quot;sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;</span>)</span><br><span class="line">    .build();</span><br><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> OkHttpClient.Builder()</span><br><span class="line">    .certificatePinner(certificatePinner)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>



<h3 id="CertificateChainCleaner-验证操作员"><a href="#CertificateChainCleaner-验证操作员" class="headerlink" title="CertificateChainCleaner(验证操作员)"></a>CertificateChainCleaner(验证操作员)</h3><p>使用X509TrustManager 验证整个服务端证书链。</p>
<h3 id="TimeOut超时时间"><a href="#TimeOut超时时间" class="headerlink" title="TimeOut超时时间"></a>TimeOut超时时间</h3><p>connectTimeout：建立连接(TCL 或 TLS) 的超时时间。</p>
<p>readTimeout：发起请求到读 到响应数据的超时时间。</p>
<p>writeTimeout：发起请求并被目标服务器接受的超时时间。有时候对方服务器可能由于某种原因不读取你的Request。</p>
<h1 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h1><p>整个OkHttp 请求主流程 靠分发器 和 拦截器 ，其他组件配合两者。</p>
<p>分发器Dispatcher：负责调配请求任务，内部包含一个线程池执行请求任务，对总请求数和单主机请求数有限制。</p>
<h2 id="一、请求任务分配"><a href="#一、请求任务分配" class="headerlink" title="一、请求任务分配"></a>一、请求任务分配</h2><p><code>okClient.newCall(request)</code> 返回的是 <code>RealCall</code> 类型。下面调用<code>realCall.enqueue(callback)</code>。</p>
<p><code>client.dispatcher</code> 就是分发器<code>Dispatcher</code>，将异步任务<code>AsyncCall</code>交给分发器。</p>
<p><code>AsyncCall</code>继承自<code>RealCall</code>，RealCall是整个网络请求执行器，相当于大管家，管理请求相关的参数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealCall</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(responseCallback: <span class="type">Callback</span>)</span></span> &#123;</span><br><span class="line">  check(executed.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123; <span class="string">&quot;Already Executed&quot;</span> &#125;</span><br><span class="line">  callStart()</span><br><span class="line">  <span class="comment">// Dispatcher.enqueue   </span></span><br><span class="line">  client.dispatcher.enqueue(AsyncCall(responseCallback))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异步请求执行器会先加入到等待执行队列中。<br><code>findExistingCallWithHost()</code> 判断相同域名下，队列是否存在队列请求调用 <code>AsynCall</code>。<br>如果有相同请求执行<code>call.reuseCallsPerHostFrom(existingCall)</code>，同步 <code>callsPerHost</code> 统一主机并发请求次数。 </p>
<p><code>promoteAndExecute</code> 就是从队列中推举并执行请求。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatcher</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有异步请求最多 64 个</span></span><br><span class="line"><span class="keyword">var</span> maxRequests = <span class="number">64</span></span><br><span class="line"><span class="comment">// 相同域名下，最多5个异步请求</span></span><br><span class="line"><span class="keyword">var</span> maxRequestsPerHost = <span class="number">5</span></span><br><span class="line"><span class="comment">// 异步请求等待执行队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> readyAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()</span><br><span class="line"><span class="comment">// 异步请求正在等待执行队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> runningAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()</span><br><span class="line"><span class="comment">// 同步请求正在执行队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> runningSyncCalls = ArrayDeque&lt;RealCall&gt;()</span><br><span class="line"><span class="comment">// 异步请求使用的线程池    </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> executorServiceOrNull: ExecutorService? = <span class="literal">null</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(call: <span class="type">AsyncCall</span>)</span></span> &#123;</span><br><span class="line">  synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">// 先加入到等待执行队列中  </span></span><br><span class="line">    readyAsyncCalls.add(call)</span><br><span class="line">	<span class="comment">// 如果相同域名下的call，callsPerHost会直接被赋值成队列中已有 Call 的callsPerHost</span></span><br><span class="line">    <span class="keyword">if</span> (!call.call.forWebSocket) &#123;</span><br><span class="line">      <span class="keyword">val</span> existingCall = findExistingCallWithHost(call.host)</span><br><span class="line">      <span class="keyword">if</span> (existingCall != <span class="literal">null</span>) call.reuseCallsPerHostFrom(existingCall)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  promoteAndExecute()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">reuseCallsPerHostFrom</span><span class="params">(other: <span class="type">AsyncCall</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.callsPerHost = other.callsPerHost</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>promoteAndExecute()</code>，遍历等待执行队列中，推举出符合要求的 Call，需要满足两个条件才能执行：</p>
<ul>
<li><strong>正在执行队列已有异步请求数量不能超过 64 个。</strong></li>
<li><strong>正在执行队列中相同域名下，<code>callsPerHost</code> 同一主机并发请求数不能超过 5 个，防止服务器资源扛不住，Http 连接管理中对此进行了说明。</strong></li>
</ul>
<p>相同域名下的Call中<code>callsPerHost</code>在上一步都会同步为相同对象，所以当<code>callsPerHost.incrementAndGet()</code>，相同域名下的其他Call 也会 + 1。<br>即使相同域名下建立了多个 Call 请求对象，对相同域名的并发请求数是同步的。<br>想要绕过相同域名连接数限制，只能使用域名分片。</p>
<p>如果都符合条件，</p>
<ul>
<li>加入到<code>executableCalls</code>临时执行队列，<code>promoteAndExecute()</code>执行后队列销毁。</li>
<li><code>runningAsyncCalls</code>正在执行队列中，只要请求没有结束不会被移除。</li>
</ul>
<p>如果线程池被被关闭则移除且不执行所有队列中所有请求。<br>连接整成，遍历<code>executableCalls</code> 执行队列，调用<code>asyncCall.executeOn(executorService)</code> 使用线程池执行请求。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatcher</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">promoteAndExecute</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.assertThreadDoesntHoldLock()</span><br><span class="line">  <span class="comment">// 可执行异步请求容器    </span></span><br><span class="line">  <span class="keyword">val</span> executableCalls = mutableListOf&lt;AsyncCall&gt;()</span><br><span class="line">  <span class="keyword">val</span> isRunning: <span class="built_in">Boolean</span></span><br><span class="line">  synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> i = readyAsyncCalls.iterator()</span><br><span class="line">    <span class="comment">// 遍历等待队列    </span></span><br><span class="line">    <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">      <span class="keyword">val</span> asyncCall = i.next()</span><br><span class="line">      <span class="comment">// 超过异步请求数 64 直接不执行。 </span></span><br><span class="line">      <span class="keyword">if</span> (runningAsyncCalls.size &gt;= <span class="keyword">this</span>.maxRequests) <span class="keyword">break</span> <span class="comment">// Max capacity.</span></span><br><span class="line">      <span class="comment">// 超过相同域名并发请求数，当前不执行，可以执行其他域名的 call</span></span><br><span class="line">      <span class="keyword">if</span> (asyncCall.callsPerHost.<span class="keyword">get</span>() &gt;= <span class="keyword">this</span>.maxRequestsPerHost) <span class="keyword">continue</span> <span class="comment">// Host max capacity.</span></span><br><span class="line">      i.remove()</span><br><span class="line">      <span class="comment">// 并发请求次数+1    </span></span><br><span class="line">      asyncCall.callsPerHost.incrementAndGet()</span><br><span class="line">      <span class="comment">// 添加到执行队列中</span></span><br><span class="line">      executableCalls.add(asyncCall)</span><br><span class="line">      <span class="comment">// 添加到正在执行队列中</span></span><br><span class="line">      runningAsyncCalls.add(asyncCall)</span><br><span class="line">    &#125;</span><br><span class="line">    isRunning = runningCallsCount() &gt; <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (executorService.isShutdown) &#123;</span><br><span class="line">     <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until executableCalls.size) &#123;</span><br><span class="line">        <span class="keyword">val</span> asyncCall = executableCalls[i]</span><br><span class="line">        asyncCall.callsPerHost.decrementAndGet()</span><br><span class="line"></span><br><span class="line">        synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">           runningAsyncCalls.remove(asyncCall)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">           asyncCall.failRejected()</span><br><span class="line">        &#125;</span><br><span class="line">     idleCallback?.run()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until executableCalls.size) &#123;</span><br><span class="line">          <span class="keyword">val</span> asyncCall = executableCalls[i]</span><br><span class="line">          asyncCall.executeOn(executorService)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isRunning</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>executorService</code> 配置线程池参数如下:</p>
<ul>
<li>核心线程数 0: 当没有任务执行时，线程池中没有任何线程资源，最大程度地减少系统资源的占用。</li>
<li>最大线程数为 MAX_VALUE: 这样线程池可以处理任意数量的任务，保证了高并发。</li>
<li>工作队列 SynchronousQueue: 该队列没有存储空间，所有有任务会执行创建线程，保证高并发。</li>
<li>存活时间为 60s: 线程空间超过 60s 就会被销毁，节约资源。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispather</span></span><br><span class="line"><span class="keyword">val</span> executorService: ExecutorService</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (executorServiceOrNull == <span class="literal">null</span>) &#123;</span><br><span class="line">            executorServiceOrNull = ThreadPoolExecutor(<span class="number">0</span>, <span class="built_in">Int</span>.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">                SynchronousQueue(), threadFactory(<span class="string">&quot;<span class="variable">$okHttpName</span> Dispatcher&quot;</span>, <span class="literal">false</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> executorServiceOrNull!!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程池会执行 RealCall 请求。因为RealCall，默认实现了<code>Runnable</code>接口，会执行它的<code>run</code>方法。<br>另外当执行失败时，会调用<code>Dispatcher.finished</code>方法结尾。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealCall</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">executeOn</span><span class="params">(executorService: <span class="type">ExecutorService</span>)</span></span> &#123;</span><br><span class="line">    client.dispatcher.assertThreadDoesntHoldLock()</span><br><span class="line">        <span class="keyword">var</span> success = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行请求，this表示Runnable</span></span><br><span class="line">            executorService.execute(<span class="keyword">this</span>)</span><br><span class="line">            success = <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: RejectedExecutionException) &#123;</span><br><span class="line">            <span class="keyword">val</span> ioException = InterruptedIOException(<span class="string">&quot;executor rejected&quot;</span>)</span><br><span class="line">            ioException.initCause(e)</span><br><span class="line">            noMoreExchanges(ioException)</span><br><span class="line">            responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, ioException)</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!success) &#123; </span><br><span class="line">                <span class="comment">// 请求执行失败</span></span><br><span class="line">                client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>getResponseWithInterceptorChain()</code>发起请求，获取响应结果，返回给调用层。</p>
<p>当执行成功结束后，也会调用<code>Dispatcher.finished</code>方法结尾。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealCall</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">  threadName(<span class="string">&quot;OkHttp <span class="subst">$&#123;redactedUrl()&#125;</span>&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> signalledCallback = <span class="literal">false</span></span><br><span class="line">    timeout.enter()</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">val</span> response = getResponseWithInterceptorChain()</span><br><span class="line">      signalledCallback = <span class="literal">true</span></span><br><span class="line">      responseCallback.onResponse(<span class="keyword">this</span><span class="symbol">@RealCall</span>, response)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125; <span class="keyword">catch</span> (t: Throwable) &#123;</span><br><span class="line">      cancel()</span><br><span class="line">      ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 请求成功完成  </span></span><br><span class="line">      client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>finished()</code>方法中，当一个请求执行结束后，调用<code>promoteAndExecute()</code> 执行等待队列中的下一个请求任务，并且将域名下的并发请求数 -1.</p>
<p>如果等待队列中无任务可以执行，则能利用线程池执行其他任务。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">finished</span><span class="params">(call: <span class="type">AsyncCall</span>)</span></span> &#123;</span><br><span class="line">  call.callsPerHost.decrementAndGet()</span><br><span class="line">  finished(runningAsyncCalls, call)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">finished</span><span class="params">(calls: <span class="type">Deque</span>&lt;<span class="type">T</span>&gt;, call: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> idleCallback: Runnable?</span><br><span class="line">  synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> AssertionError(<span class="string">&quot;Call wasn&#x27;t in-flight!&quot;</span>)</span><br><span class="line">    idleCallback = <span class="keyword">this</span>.idleCallback</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行队列中的下个Call  </span></span><br><span class="line">  <span class="keyword">val</span> isRunning = promoteAndExecute()</span><br><span class="line">  <span class="comment">// 如果线程池空调可以先执行其他任务    </span></span><br><span class="line">  <span class="keyword">if</span> (!isRunning &amp;&amp; idleCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">    idleCallback.run()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、拦截器责任链"><a href="#二、拦截器责任链" class="headerlink" title="二、拦截器责任链"></a>二、拦截器责任链</h2><p>OkHttp 的核心工作是在 <code>getResponseWithInterceptorChain()</code> 中完成。</p>
<p>前部分将自定义的拦截器和 OkHttp 提供的拦截器依次添加到拦截器容器中。</p>
<p>创建 <code>RealInterceptorChain</code> 责任链对象<code>chain</code>，调用<code>chain.proceed(originalRequest)</code>，传入外部构建的<code>request</code>对象，启动责任链。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealCall</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">  <span class="comment">// 创建拦截器容器.</span></span><br><span class="line">  <span class="keyword">val</span> interceptors = mutableListOf&lt;Interceptor&gt;()</span><br><span class="line">  <span class="comment">// 把拦截器添加到容器中</span></span><br><span class="line">  interceptors += client.interceptors</span><br><span class="line">  interceptors += RetryAndFollowUpInterceptor(client)</span><br><span class="line">  interceptors += BridgeInterceptor(client.cookieJar)</span><br><span class="line">  interceptors += CacheInterceptor(client.cache)</span><br><span class="line">  interceptors += ConnectInterceptor</span><br><span class="line">      </span><br><span class="line">  <span class="comment">// 如果不是websocket，则可以自定义networkInterceptors </span></span><br><span class="line">  <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">    interceptors += client.networkInterceptors</span><br><span class="line">  &#125;</span><br><span class="line">  interceptors += CallServerInterceptor(forWebSocket)</span><br><span class="line">  <span class="comment">// 创建责任链对象	</span></span><br><span class="line">  <span class="keyword">val</span> chain = RealInterceptorChain(</span><br><span class="line">      call = <span class="keyword">this</span>,</span><br><span class="line">      interceptors = interceptors,</span><br><span class="line">      index = <span class="number">0</span>,</span><br><span class="line">      exchange = <span class="literal">null</span>,</span><br><span class="line">      request = originalRequest,</span><br><span class="line">      connectTimeoutMillis = client.connectTimeoutMillis,</span><br><span class="line">      readTimeoutMillis = client.readTimeoutMillis,</span><br><span class="line">      writeTimeoutMillis = client.writeTimeoutMillis</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">var</span> calledNoMoreExchanges = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 启动拦截器责任链，等待结果返回  </span></span><br><span class="line">    <span class="keyword">val</span> response = chain.proceed(originalRequest)</span><br><span class="line">    <span class="keyword">if</span> (isCanceled()) &#123;</span><br><span class="line">      response.closeQuietly()</span><br><span class="line">      <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">    calledNoMoreExchanges = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">throw</span> noMoreExchanges(e) <span class="keyword">as</span> Throwable</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!calledNoMoreExchanges) &#123;</span><br><span class="line">      noMoreExchanges(<span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面调用<code> chain.proceed(originalRequest)</code>，整个拦截器链条是如何运转的？</p>
<p>先拷贝一个<code>RealInterceptorChain</code>，然后index + 1，获取当前index 下的 拦截器，调用<code>intercept()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealInterceptorChain</span></span><br><span class="line"><span class="keyword">private</span> val index: Int    override fun <span class="title function_">proceed</span><span class="params">(request: Request)</span>: Response &#123;   </span><br><span class="line">    ...    </span><br><span class="line">    <span class="type">val</span> <span class="variable">next</span> <span class="operator">=</span> copy(index = index + <span class="number">1</span>, request = request)	</span><br><span class="line">    <span class="type">val</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors[index]    </span><br><span class="line">    <span class="type">val</span> <span class="variable">response</span> <span class="operator">=</span> interceptor.intercept(next) ?: <span class="keyword">throw</span> NullPointerException(<span class="string">&quot;interceptor$interceptor returned null&quot;</span>)      </span><br><span class="line">...    </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>在拦截器的<code>interceptors</code>做了 3 件事情：</p>
<ol>
<li>对请求预处理。</li>
<li>调用<code>chain.proceed()</code>，index已经+1，将请求交给下个拦截器，执行<code>intercept()</code>方法。</li>
<li>最后一个拦截器请求完成后，获取响应结果，返回给上个拦截器处理，直至传递到顶部。</li>
</ol>
<p>整个责任链模式就像工程流水线，各司其职。一个玩具飞机有外壳装配员，引擎装配员，螺旋桨装配员，模型包装员组成。</p>
<p>当玩具流到谁那里，谁就负责安装他负责的这一部分，这部分安装完成后流到下一个环节，直到玩具生产完成。<br><img src="https://upload-images.jianshu.io/upload_images/4538003-00d6440ffa1710e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>下面看看具体每个拦截器的作用，整个拦截器链按照Interceptor添加顺序依次调用<code>intercept()</code>方法。</p>
<h3 id="一次完整网络请求"><a href="#一次完整网络请求" class="headerlink" title="一次完整网络请求"></a>一次完整网络请求</h3><p>在开始之前，我们要知道从客户端将网址输入到浏览器，一次完整的网络请求会发生什么。</p>
<h3 id="1、自定义Interceptor"><a href="#1、自定义Interceptor" class="headerlink" title="1、自定义Interceptor"></a>1、自定义Interceptor</h3><p>先执行开发者调用<code>OkHttpClient.Builder().addInterceptor()</code>添加的自定义拦截器，它在系统拦截器之前工作，进行最早的Request预处理工作，已经最后处理响应结果Response，可以根据需要添加header。</p>
<h3 id="2、重试及重定向拦截器RetryAndFollowUpInterceptor"><a href="#2、重试及重定向拦截器RetryAndFollowUpInterceptor" class="headerlink" title="2、重试及重定向拦截器RetryAndFollowUpInterceptor"></a>2、重试及重定向拦截器RetryAndFollowUpInterceptor</h3><p><strong>它会对连接做⼀些初始化⼯作，并且负责在请求失败时的重试，以及重定向的⾃动后续请求</strong>。它的存在，可以让重试和重定向对于开发者是无感知。</p>
<ol>
<li>前置工作，调用<code>call.enterNetworkInterceptorExchange</code>创建<code>ExChangeFinder</code>。</li>
<li>后置工作是调用<code>recover()</code>重试</li>
<li><code>followUpRequest(response, exchange)</code>生成重定向请求，重新请求重定向的链接。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">  <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">  <span class="keyword">var</span> request = chain.request</span><br><span class="line">  <span class="keyword">val</span> call = realChain.call</span><br><span class="line">  <span class="keyword">var</span> followUpCount = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> priorResponse: Response? = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">var</span> newExchangeFinder = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">var</span> recoveredFailures = listOf&lt;IOException&gt;()</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 1、初始化 </span></span><br><span class="line">    call.enterNetworkInterceptorExchange(request, newExchangeFinder)</span><br><span class="line">    <span class="keyword">var</span> response: Response</span><br><span class="line">    <span class="keyword">var</span> closeActiveExchange = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 请求取消  </span></span><br><span class="line">      <span class="keyword">if</span> (call.isCanceled()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2、交给下一个拦截器  </span></span><br><span class="line">        response = realChain.proceed(request)</span><br><span class="line">        newExchangeFinder = <span class="literal">true</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e: RouteException) &#123;</span><br><span class="line">        <span class="comment">// 3、路由异常，连接未成功，请求没有发出去</span></span><br><span class="line">        <span class="keyword">if</span> (!recover(e.lastConnectException, call, request, requestSendStarted = <span class="literal">false</span>)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> e.firstConnectException.withSuppressed(recoveredFailures)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          recoveredFailures += e.firstConnectException</span><br><span class="line">        &#125;</span><br><span class="line">        newExchangeFinder = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">        <span class="comment">// 3、请求发出去了，但是和服务器通信失败，服务器读取请求内容突然关闭</span></span><br><span class="line">        <span class="keyword">if</span> (!recover(e, call, request, requestSendStarted = e !<span class="keyword">is</span> ConnectionShutdownException)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> e.withSuppressed(recoveredFailures)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          recoveredFailures += e</span><br><span class="line">        &#125;</span><br><span class="line">        newExchangeFinder = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 重定向会执行两次请求，第一次响应结果保存到重定向后的response中</span></span><br><span class="line">      <span class="keyword">if</span> (priorResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">        response = response.newBuilder()</span><br><span class="line">            .priorResponse(priorResponse.newBuilder()</span><br><span class="line">                .body(<span class="literal">null</span>)</span><br><span class="line">                .build())</span><br><span class="line">            .build()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">val</span> exchange = call.interceptorScopedExchange</span><br><span class="line">      <span class="comment">// 构建重定向请求    </span></span><br><span class="line">      <span class="keyword">val</span> followUp = followUpRequest(response, exchange)</span><br><span class="line">      <span class="comment">// 为空直接返回response   </span></span><br><span class="line">      <span class="keyword">if</span> (followUp == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exchange != <span class="literal">null</span> &amp;&amp; exchange.isDuplex) &#123;</span><br><span class="line">          call.timeoutEarlyExit()</span><br><span class="line">        &#125;</span><br><span class="line">        closeActiveExchange = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">val</span> followUpBody = followUp.body</span><br><span class="line">      <span class="comment">// isOneShot默认返回false，true表示只请求一次，所以重定向失效。   </span></span><br><span class="line">      <span class="keyword">if</span> (followUpBody != <span class="literal">null</span> &amp;&amp; followUpBody.isOneShot()) &#123;</span><br><span class="line">        closeActiveExchange = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">      &#125;</span><br><span class="line">      response.body?.closeQuietly()</span><br><span class="line">      <span class="comment">// 最多重定向20次    </span></span><br><span class="line">      <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ProtocolException(<span class="string">&quot;Too many follow-up requests: <span class="variable">$followUpCount</span>&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 保存重定向请求参数  </span></span><br><span class="line">      request = followUp</span><br><span class="line">      <span class="comment">// 保存上个重定向结果    </span></span><br><span class="line">      priorResponse = response</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      call.exitNetworkInterceptorExchange(closeActiveExchange)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="enterNetworkInterceptorExchange-初始化"><a href="#enterNetworkInterceptorExchange-初始化" class="headerlink" title="enterNetworkInterceptorExchange()初始化"></a>enterNetworkInterceptorExchange()初始化</h4><p>Exchange 表示请求- 响应一次数据交换，只有建立连接才能数据交换。</p>
<p>ExchangeFinder 的作用就是将寻找可重用的连接，此类的实例不是线程安全的。</p>
<ol>
<li>先检查上次连接是否已经关闭，没有关闭直接抛出一个异常</li>
<li>创建 <code>RealRoutePlanner</code> 选择和建立一个可用连接，调用 <code>createAddress()</code> 将核心信息保存下来。</li>
<li><code>client.fastFallback</code> 默认为 true，所以会创建<code>FastFallbackExchangeFinder</code> 对象。<br>这些初始化信息是为了后面网络连接使用。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealCall</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">enterNetworkInterceptorExchange</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    request: <span class="type">Request</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    newRoutePlanner: <span class="type">Boolean</span> = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    chain: <span class="type">RealInterceptorChain</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    check(interceptorScopedExchange == <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">        check(!responseBodyOpen) &#123;</span><br><span class="line">            <span class="string">&quot;cannot make a new request because the previous response is still open: &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;please call response.close()&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        check(!requestBodyOpen)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newRoutePlanner) &#123;</span><br><span class="line">        <span class="keyword">val</span> routePlanner = RealRoutePlanner(</span><br><span class="line">            client,</span><br><span class="line">            createAddress(request.url),</span><br><span class="line">            <span class="keyword">this</span>,</span><br><span class="line">            chain,</span><br><span class="line">            connectionListener = connectionPool.connectionListener</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">this</span>.exchangeFinder = <span class="keyword">when</span> &#123;</span><br><span class="line">            client.fastFallback -&gt; FastFallbackExchangeFinder(routePlanner, client.taskRunner)</span><br><span class="line">            <span class="keyword">else</span> -&gt; SequentialExchangeFinder(routePlanner)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="recover请求重试"><a href="#recover请求重试" class="headerlink" title="recover请求重试"></a>recover请求重试</h5><p>只有满足以下所有的条件，才能发起重连：</p>
<ol>
<li><code>retryOnConnectionFailure = true</code> okhttpClient 配置时 允许重连。</li>
<li><code>isRecoverable()</code>，如果是协议异常、超时异常、HTTPS 连接异常导致连接失败，则不能重试</li>
<li>还有新的路由可以连接</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RouteException</span></span><br><span class="line">recover(e.lastConnectException, call, request, requestSendStarted = <span class="literal">false</span>)</span><br><span class="line">    <span class="comment">// IOException    </span></span><br><span class="line">    recover(e, call, request, requestSendStarted = e !<span class="keyword">is</span> ConnectionShutdownException)    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">recover</span><span class="params">(e: <span class="type">IOException</span>, call: <span class="type">RealCall</span>,userRequest: <span class="type">Request</span>, requestSendStarted: <span class="type">Boolean</span>)</span></span>: <span class="built_in">Boolean</span> &#123;  </span><br><span class="line">    <span class="comment">// 如果配置不重连，则直接返回false  </span></span><br><span class="line">    <span class="keyword">if</span> (!client.retryOnConnectionFailure) <span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">    <span class="comment">// 一般不满足  </span></span><br><span class="line">    <span class="keyword">if</span> (requestSendStarted &amp;&amp; requestIsOneShot(e, userRequest)) <span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">    <span class="comment">// 是否是重连的异常  </span></span><br><span class="line">    <span class="keyword">if</span> (!isRecoverable(e, requestSendStarted)) <span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">   <span class="comment">// 没有新的路由可以重连  </span></span><br><span class="line">    <span class="keyword">if</span> (!call.retryAfterFailure()) <span class="keyword">return</span> <span class="literal">false</span> </span><br><span class="line">    <span class="comment">// For failure recovery, use the same route selector with a new connection. </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h5><p>重定向是当客户端和服务端建立TCP连接成功，但是HTTP请求失败，会根据状态码是否重试。</p>
<p>407和401 因为未授权导致请求失败，会调用在OkHttpClient 组件介绍部分的认证器重新认证再次发起请求。</p>
<p>3XX，重定向状态码，会调用<code>buildRedirectRequest()</code> ，取出location字段的url，重新建立请求。</p>
<p>408、503、421 因为客户端和服务端自身原因导致失败，会根据条件判断是否发起一个新的请求。</p>
<p><strong>重定向次数最多只有20次</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">followUpRequest</span><span class="params">(userResponse: <span class="type">Response</span>, exchange: <span class="type">Exchange</span>?)</span></span>: Request? &#123;</span><br><span class="line">    <span class="keyword">val</span> route = exchange?.connection?.route()</span><br><span class="line">        <span class="keyword">val</span> responseCode = userResponse.code</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> method = userResponse.request.method</span><br><span class="line">        <span class="keyword">when</span> (responseCode) &#123;</span><br><span class="line">       	<span class="comment">//  407 代理服务器未授权，会调用proxyAuthenticator重新授权再发起请求</span></span><br><span class="line">        HTTP_PROXY_AUTH -&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> selectedProxy = route!!.proxy</span><br><span class="line">                <span class="keyword">if</span> (selectedProxy.type() != Proxy.Type.HTTP) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> ProtocolException(<span class="string">&quot;Received HTTP_PROXY_AUTH (407) code while not using proxy&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">return</span> client.proxyAuthenticator.authenticate(route, userResponse)</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 401 目的服务器未授权，调用authenticator重新授权</span></span><br><span class="line">        HTTP_UNAUTHORIZED -&gt; <span class="keyword">return</span> client.authenticator.authenticate(route, userResponse)</span><br><span class="line">        <span class="comment">//  3xx 重定向状态码，发起重定向请求   </span></span><br><span class="line">        HTTP_PERM_REDIRECT, HTTP_TEMP_REDIRECT, HTTP_MULT_CHOICE, HTTP_MOVED_PERM, HTTP_MOVED_TEMP, HTTP_SEE_OTHER -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> buildRedirectRequest(userResponse, method)</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">        <span class="comment">// 408 客户端连接超时</span></span><br><span class="line">        HTTP_CLIENT_TIMEOUT -&gt; &#123;</span><br><span class="line">           	<span class="comment">// 是否允许能连接重试</span></span><br><span class="line">            <span class="keyword">if</span> (!client.retryOnConnectionFailure) &#123;</span><br><span class="line">                <span class="comment">// The application layer has directed us not to retry the request.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> requestBody = userResponse.request.body</span><br><span class="line">                <span class="keyword">if</span> (requestBody != <span class="literal">null</span> &amp;&amp; requestBody.isOneShot()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">val</span> priorResponse = userResponse.priorResponse</span><br><span class="line">                <span class="keyword">if</span> (priorResponse != <span class="literal">null</span> &amp;&amp; priorResponse.code == HTTP_CLIENT_TIMEOUT) &#123;</span><br><span class="line">                    <span class="comment">// We attempted to retry and got another timeout. Give up.</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (retryAfter(userResponse, <span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> userResponse.request</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 503 服务不可用</span></span><br><span class="line">        HTTP_UNAVAILABLE -&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> priorResponse = userResponse.priorResponse</span><br><span class="line">                <span class="keyword">if</span> (priorResponse != <span class="literal">null</span> &amp;&amp; priorResponse.code == HTTP_UNAVAILABLE) &#123;</span><br><span class="line">                    <span class="comment">// We attempted to retry and got another timeout. Give up.</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (retryAfter(userResponse, Integer.MAX_VALUE) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// specifically received an instruction to retry without delay</span></span><br><span class="line">                <span class="keyword">return</span> userResponse.request</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">	    <span class="comment">// 421 从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围</span></span><br><span class="line">        HTTP_MISDIRECTED_REQUEST -&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> requestBody = userResponse.request.body</span><br><span class="line">                <span class="keyword">if</span> (requestBody != <span class="literal">null</span> &amp;&amp; requestBody.isOneShot()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (exchange == <span class="literal">null</span> || !exchange.isCoalescedConnection) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            exchange.connection.noCoalescedConnections()</span><br><span class="line">                <span class="keyword">return</span> userResponse.request</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3、桥接拦截器BridgeInterceptor"><a href="#3、桥接拦截器BridgeInterceptor" class="headerlink" title="3、桥接拦截器BridgeInterceptor"></a>3、桥接拦截器BridgeInterceptor</h3><p>它负责为请求添加一些开发者不需要手动添加，但服务端需要的请求字段，加载保存的cookie。</p>
<p>请求头，一般实际开发中配合 Retrofit 注解配合构建 RequestBody:</p>
<ol>
<li>请求实体 RequestBody 有 content-type，header 添加 <code>Content-Type</code>。</li>
<li>请求实体有 content-length 大小，header 添加 <code>Content-Length</code>，没有值添加 <code>Transfer-Encoding:chunked</code>，分块传输，它两互斥。</li>
<li>header 添加 <code>host</code>, 把 url 中的域名部分作为 host。</li>
<li>header 添加 <code>Connection:Keep-Alive</code>，保证单次请求后连接不断开。</li>
<li>如果不是范围请求，header 默认添加 <code>Accept-Encoding:gzip</code> 支持服务器资源 gzip 压缩。</li>
<li>有 cookie header 添加 <code>Cookie</code> 信息。</li>
<li>header 添加 <code>User-Agent:okhttp/$&#123;CONST_VERSION&#125;</code>。</li>
</ol>
<p>获取响应后，解析响应头:</p>
<ol>
<li>响应头有<code>Set-Cookie</code>，会用 CookieJar 保存服务器返回的cookie。</li>
<li>响应头有<code>Content-Encoding:gzip</code> 且根据<code>networkResponse.promisesBody()</code>服务端有返回压缩实体，则使用<code>GzipSource</code>用于解压。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">  <span class="keyword">val</span> userRequest = chain.request()</span><br><span class="line">  <span class="keyword">val</span> requestBuilder = userRequest.newBuilder()</span><br><span class="line">  <span class="comment">// 1、处理请求头    </span></span><br><span class="line">  <span class="keyword">val</span> body = userRequest.body</span><br><span class="line">  <span class="comment">// 添加实体首部   </span></span><br><span class="line">  <span class="keyword">if</span> (body != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> contentType = body.contentType()</span><br><span class="line">    <span class="keyword">if</span> (contentType != <span class="literal">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">&quot;Content-Type&quot;</span>, contentType.toString())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> contentLength = body.contentLength()</span><br><span class="line">    <span class="keyword">if</span> (contentLength != -<span class="number">1L</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">&quot;Content-Length&quot;</span>, contentLength.toString())</span><br><span class="line">      requestBuilder.removeHeader(<span class="string">&quot;Transfer-Encoding&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">&quot;Transfer-Encoding&quot;</span>, <span class="string">&quot;chunked&quot;</span>)</span><br><span class="line">      requestBuilder.removeHeader(<span class="string">&quot;Content-Length&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加host  </span></span><br><span class="line">  <span class="keyword">if</span> (userRequest.header(<span class="string">&quot;Host&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">    requestBuilder.header(<span class="string">&quot;Host&quot;</span>, userRequest.url.toHostHeader())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 默认为长连接  </span></span><br><span class="line">  <span class="keyword">if</span> (userRequest.header(<span class="string">&quot;Connection&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">    requestBuilder.header(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;Keep-Alive&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 默认期望服务器返回压缩字段</span></span><br><span class="line">  <span class="keyword">var</span> transparentGzip = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">if</span> (userRequest.header(<span class="string">&quot;Accept-Encoding&quot;</span>) == <span class="literal">null</span> &amp;&amp; userRequest.header(<span class="string">&quot;Range&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">    transparentGzip = <span class="literal">true</span></span><br><span class="line">    requestBuilder.header(<span class="string">&quot;Accept-Encoding&quot;</span>, <span class="string">&quot;gzip&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 加载cookie  </span></span><br><span class="line">  <span class="keyword">val</span> cookies = cookieJar.loadForRequest(userRequest.url)</span><br><span class="line">  <span class="keyword">if</span> (cookies.isNotEmpty()) &#123;</span><br><span class="line">    requestBuilder.header(<span class="string">&quot;Cookie&quot;</span>, cookieHeader(cookies))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加UA  </span></span><br><span class="line">  <span class="keyword">if</span> (userRequest.header(<span class="string">&quot;User-Agent&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">    requestBuilder.header(<span class="string">&quot;User-Agent&quot;</span>, userAgent)</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 2、发给下一个拦截器  </span></span><br><span class="line">  <span class="keyword">val</span> networkResponse = chain.proceed(requestBuilder.build())</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3、处理响应头   </span></span><br><span class="line">  <span class="comment">// 保存cookie    </span></span><br><span class="line">  cookieJar.receiveHeaders(userRequest.url, networkResponse.headers)</span><br><span class="line">  <span class="keyword">val</span> responseBuilder = networkResponse.newBuilder()</span><br><span class="line">      .request(userRequest)</span><br><span class="line">  <span class="comment">// 如果服务器返回压缩格式数据，进行解压    </span></span><br><span class="line">  <span class="keyword">if</span> (transparentGzip &amp;&amp;</span><br><span class="line">      <span class="string">&quot;gzip&quot;</span>.equals(networkResponse.header(<span class="string">&quot;Content-Encoding&quot;</span>), ignoreCase = <span class="literal">true</span>) &amp;&amp;</span><br><span class="line">      networkResponse.promisesBody()) &#123;</span><br><span class="line">    <span class="keyword">val</span> responseBody = networkResponse.body</span><br><span class="line">    <span class="keyword">if</span> (responseBody != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">val</span> gzipSource = GzipSource(responseBody.source())</span><br><span class="line">      <span class="keyword">val</span> strippedHeaders = networkResponse.headers.newBuilder()</span><br><span class="line">          .removeAll(<span class="string">&quot;Content-Encoding&quot;</span>)</span><br><span class="line">          .removeAll(<span class="string">&quot;Content-Length&quot;</span>)</span><br><span class="line">          .build()</span><br><span class="line">      responseBuilder.headers(strippedHeaders)</span><br><span class="line">      <span class="keyword">val</span> contentType = networkResponse.header(<span class="string">&quot;Content-Type&quot;</span>)</span><br><span class="line">      responseBuilder.body(RealResponseBody(contentType, -<span class="number">1L</span>, gzipSource.buffer()))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> responseBuilder.build()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4、缓存拦截器CacheInterceptor"><a href="#4、缓存拦截器CacheInterceptor" class="headerlink" title="4、缓存拦截器CacheInterceptor"></a>4、缓存拦截器CacheInterceptor</h3><p>负责HTTP的缓存处理，在建立连接发出请求前，先判断是否存在本地响应结果缓存，如果存在可以直接返回不请求服务器。，</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">  <span class="keyword">val</span> call = chain.call()</span><br><span class="line">  <span class="keyword">val</span> cacheCandidate = cache?.<span class="keyword">get</span>(chain.request())</span><br><span class="line">  <span class="keyword">val</span> now = System.currentTimeMillis()</span><br><span class="line">  <span class="keyword">val</span> strategy = CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()</span><br><span class="line">  <span class="keyword">val</span> networkRequest = strategy.networkRequest</span><br><span class="line">  <span class="keyword">val</span> cacheResponse = strategy.cacheResponse</span><br><span class="line">  cache?.trackResponse(strategy)</span><br><span class="line">  <span class="keyword">val</span> listener = (call <span class="keyword">as</span>? RealCall)?.eventListener ?: EventListener.NONE</span><br><span class="line">  <span class="keyword">if</span> (cacheCandidate != <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// The cache candidate wasn&#x27;t applicable. Close it.</span></span><br><span class="line">    cacheCandidate.body?.closeQuietly()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// If we&#x27;re forbidden from using the network and the cache is insufficient, fail.</span></span><br><span class="line">  <span class="keyword">if</span> (networkRequest == <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Response.Builder()</span><br><span class="line">        .request(chain.request())</span><br><span class="line">        .protocol(Protocol.HTTP_1_1)</span><br><span class="line">        .code(HTTP_GATEWAY_TIMEOUT)</span><br><span class="line">        .message(<span class="string">&quot;Unsatisfiable Request (only-if-cached)&quot;</span>)</span><br><span class="line">        .body(EMPTY_RESPONSE)</span><br><span class="line">        .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build().also &#123;</span><br><span class="line">          listener.satisfactionFailure(call, it)</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// If we don&#x27;t need the network, we&#x27;re done.</span></span><br><span class="line">  <span class="keyword">if</span> (networkRequest == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> cacheResponse!!.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .build().also &#123;</span><br><span class="line">          listener.cacheHit(call, it)</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">    listener.cacheConditionalHit(call, cacheResponse)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">    listener.cacheMiss(call)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> networkResponse: Response? = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 2、转向下一个拦截器  </span></span><br><span class="line">    networkResponse = chain.proceed(networkRequest)</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// If we&#x27;re crashing on I/O or otherwise, don&#x27;t leak the cache body.</span></span><br><span class="line">    <span class="keyword">if</span> (networkResponse == <span class="literal">null</span> &amp;&amp; cacheCandidate != <span class="literal">null</span>) &#123;</span><br><span class="line">      cacheCandidate.body?.closeQuietly()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// If we have a cache response too, then we&#x27;re doing a conditional get.</span></span><br><span class="line">  <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (networkResponse?.code == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">      <span class="keyword">val</span> response = cacheResponse.newBuilder()</span><br><span class="line">          .headers(combine(cacheResponse.headers, networkResponse.headers))</span><br><span class="line">          .sentRequestAtMillis(networkResponse.sentRequestAtMillis)</span><br><span class="line">          .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis)</span><br><span class="line">          .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">          .networkResponse(stripBody(networkResponse))</span><br><span class="line">          .build()</span><br><span class="line">      networkResponse.body!!.close()</span><br><span class="line">      <span class="comment">// Update the cache after combining headers but before stripping the</span></span><br><span class="line">      <span class="comment">// Content-Encoding header (as performed by initContentStream()).</span></span><br><span class="line">      cache!!.trackConditionalCacheHit()</span><br><span class="line">      cache.update(cacheResponse, response)</span><br><span class="line">      <span class="keyword">return</span> response.also &#123;</span><br><span class="line">        listener.cacheHit(call, it)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cacheResponse.body?.closeQuietly()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">val</span> response = networkResponse!!.newBuilder()</span><br><span class="line">      .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">      .networkResponse(stripBody(networkResponse))</span><br><span class="line">      .build()</span><br><span class="line">  <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (response.promisesBody() &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">      <span class="comment">// Offer this request to the cache.</span></span><br><span class="line">      <span class="keyword">val</span> cacheRequest = cache.put(response)</span><br><span class="line">      <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response).also &#123;</span><br><span class="line">        <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// This will log a conditional cache miss only.</span></span><br><span class="line">          listener.cacheMiss(call)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cache.remove(networkRequest)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (_: IOException) &#123;</span><br><span class="line">        <span class="comment">// The cache cannot be written.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> response</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5、连接拦截器ConnectInterceptor"><a href="#5、连接拦截器ConnectInterceptor" class="headerlink" title="5、连接拦截器ConnectInterceptor"></a>5、连接拦截器ConnectInterceptor</h3><p>它负责建立连接，会使用Socket建立TCP连接，如果是HTTPS 协议，则在TCP之上建立TLS连接，返回对应的 HttpCodec 对象（⽤于编码解码 HTTP 请求）。</p>
<p>代码虽然不多，但是大多数功能逻辑都封装到其他类中，核心代码<code>realChain.call.initExchange(chain)</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">  <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">  <span class="keyword">val</span> exchange = realChain.call.initExchange(chain)</span><br><span class="line">  <span class="keyword">val</span> connectedChain = realChain.copy(exchange = exchange)</span><br><span class="line">  <span class="keyword">return</span> connectedChain.proceed(realChain.request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>调用<code>exchangeFinder.find()</code>返回HTTPCodec，负责请求编解码，然后组成一个<code>Exchange</code>，负责传输单个 HTTP 请求和响应对，完成一次数据交换，保存到<code>RealCall</code>的 <code>exchange</code>字段中。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealCall</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">initExchange</span><span class="params">(chain: <span class="type">RealInterceptorChain</span>)</span></span>: Exchange &#123;</span><br><span class="line">  synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">    check(expectMoreExchanges) &#123; <span class="string">&quot;released&quot;</span> &#125;</span><br><span class="line">    check(!responseBodyOpen)</span><br><span class="line">    check(!requestBodyOpen)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">val</span> exchangeFinder = <span class="keyword">this</span>.exchangeFinder!!</span><br><span class="line">  <span class="comment">// 找连接，返回codc    </span></span><br><span class="line">  <span class="keyword">val</span> codec = exchangeFinder.find(client, chain) </span><br><span class="line">  <span class="keyword">val</span> result = Exchange(<span class="keyword">this</span>, eventListener, exchangeFinder, codec)</span><br><span class="line">  <span class="keyword">this</span>.interceptorScopedExchange = result</span><br><span class="line">  <span class="keyword">this</span>.exchange = result</span><br><span class="line">  synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.requestBodyOpen = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">this</span>.responseBodyOpen = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (canceled) <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li>调用<code>findHealthyConnection</code>查找可用连接。</li>
<li>调用<code>resultConnection.newCodec</code>创建HTTP编解码器。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExchangeFinder</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">find</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  client: <span class="type">OkHttpClient</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  chain: <span class="type">RealInterceptorChain</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: ExchangeCodec &#123;</span><br><span class="line">    <span class="comment">// 找到一个可用的连接</span></span><br><span class="line"> 	<span class="keyword">val</span> resultConnection = findHealthyConnection(</span><br><span class="line">        connectTimeout = chain.connectTimeoutMillis,</span><br><span class="line">        readTimeout = chain.readTimeoutMillis,</span><br><span class="line">        writeTimeout = chain.writeTimeoutMillis,</span><br><span class="line">        pingIntervalMillis = client.pingIntervalMillis,</span><br><span class="line">        connectionRetryEnabled = client.retryOnConnectionFailure,</span><br><span class="line">        doExtensiveHealthChecks = chain.request.method != <span class="string">&quot;GET&quot;</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 根据连接创建Codec    </span></span><br><span class="line">    <span class="keyword">return</span> resultConnection.newCodec(client, chain)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li><code>findConnection()</code> 查找连接</li>
<li><code>isHealthy()</code>判断连接是否可用</li>
</ol>
<p>如果获取的Connection不可用，则再次循环调用<code>findConnection()</code>再从连接池中获取连接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExchangeFinder</span></span><br><span class="line"><span class="keyword">private</span> fun <span class="title function_">findHealthyConnection</span><span class="params">(</span></span><br><span class="line"><span class="params">  connectTimeout: Int,</span></span><br><span class="line"><span class="params">  readTimeout: Int,</span></span><br><span class="line"><span class="params">  writeTimeout: Int,</span></span><br><span class="line"><span class="params">  pingIntervalMillis: Int,</span></span><br><span class="line"><span class="params">  connectionRetryEnabled: Boolean,</span></span><br><span class="line"><span class="params">  doExtensiveHealthChecks: Boolean</span></span><br><span class="line"><span class="params">)</span>: RealConnection &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">//查找连接  </span></span><br><span class="line">    <span class="type">val</span> <span class="variable">candidate</span> <span class="operator">=</span> findConnection(</span><br><span class="line">        connectTimeout = connectTimeout,</span><br><span class="line">        readTimeout = readTimeout,</span><br><span class="line">        writeTimeout = writeTimeout,</span><br><span class="line">        pingIntervalMillis = pingIntervalMillis,</span><br><span class="line">        connectionRetryEnabled = connectionRetryEnabled</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 确认Connection可用</span></span><br><span class="line">    <span class="keyword">if</span> (candidate.isHealthy(doExtensiveHealthChecks)) &#123;</span><br><span class="line">      <span class="keyword">return</span> candidate</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>从连接池获取连接的逻辑非常复杂，我们需要拆分来看，整体逻辑如下，从连接池获取连接的核心代码<code>connectionPool.callAcquirePooledConnection()</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExchangeFinder</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">findConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  connectTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  readTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  writeTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  pingIntervalMillis: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  connectionRetryEnabled: <span class="type">Boolean</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: RealConnection &#123;</span><br><span class="line">  <span class="comment">// 请求被取消直接抛出异常  </span></span><br><span class="line">  <span class="keyword">if</span> (call.isCanceled()) <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line">  <span class="comment">// Attempt to reuse the connection from the call.</span></span><br><span class="line">  <span class="keyword">val</span> callConnection = call.connection </span><br><span class="line">  <span class="comment">// 1、第一次请求时connection = null，跳过，第二次请求连接可能已经建立</span></span><br><span class="line">  <span class="keyword">if</span> (callConnection != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> toClose: Socket? = <span class="literal">null</span></span><br><span class="line">    synchronized(callConnection) &#123;</span><br><span class="line">      <span class="keyword">if</span> (callConnection.noNewExchanges || !sameHostAndPort(callConnection.route().address.url)) &#123;</span><br><span class="line">        toClose = call.releaseConnectionNoEvents()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If the call&#x27;s connection wasn&#x27;t released, reuse it. We don&#x27;t call connectionAcquired() here</span></span><br><span class="line">    <span class="comment">// because we already acquired it.</span></span><br><span class="line">    <span class="keyword">if</span> (call.connection != <span class="literal">null</span>) &#123;</span><br><span class="line">      check(toClose == <span class="literal">null</span>)</span><br><span class="line">      <span class="keyword">return</span> callConnection</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The call&#x27;s connection was released.</span></span><br><span class="line">    toClose?.closeQuietly()</span><br><span class="line">    eventListener.connectionReleased(call, callConnection)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  refusedStreamCount = <span class="number">0</span></span><br><span class="line">  connectionShutdownCount = <span class="number">0</span></span><br><span class="line">  otherFailureCount = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 2、从连接池中获取连接</span></span><br><span class="line">  <span class="keyword">if</span> (connectionPool.callAcquirePooledConnection(address, call, <span class="literal">null</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">    <span class="keyword">val</span> result = call.connection!!</span><br><span class="line">    eventListener.connectionAcquired(call, result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Nothing in the pool. Figure out what route we&#x27;ll try next.</span></span><br><span class="line">  <span class="keyword">val</span> routes: List&lt;Route&gt;?</span><br><span class="line">  <span class="keyword">val</span> route: Route</span><br><span class="line">  <span class="keyword">if</span> (nextRouteToTry != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Use a route from a preceding coalesced connection.</span></span><br><span class="line">    routes = <span class="literal">null</span></span><br><span class="line">    route = nextRouteToTry!!</span><br><span class="line">    nextRouteToTry = <span class="literal">null</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (routeSelection != <span class="literal">null</span> &amp;&amp; routeSelection!!.hasNext()) &#123;</span><br><span class="line">    <span class="comment">// Use a route from an existing route selection.</span></span><br><span class="line">    routes = <span class="literal">null</span></span><br><span class="line">    route = routeSelection!!.next()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Compute a new route selection. This is a blocking operation!</span></span><br><span class="line">    <span class="keyword">var</span> localRouteSelector = routeSelector</span><br><span class="line">    <span class="keyword">if</span> (localRouteSelector == <span class="literal">null</span>) &#123;</span><br><span class="line">      localRouteSelector = RouteSelector(address, call.client.routeDatabase, call, eventListener)</span><br><span class="line">      <span class="keyword">this</span>.routeSelector = localRouteSelector</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> localRouteSelection = localRouteSelector.next()</span><br><span class="line">    routeSelection = localRouteSelection</span><br><span class="line">    routes = localRouteSelection.routes</span><br><span class="line">    <span class="keyword">if</span> (call.isCanceled()) <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line">    <span class="comment">// 3、从连接池中获取连接</span></span><br><span class="line">    <span class="keyword">if</span> (connectionPool.callAcquirePooledConnection(address, call, routes, <span class="literal">false</span>)) &#123;</span><br><span class="line">      <span class="keyword">val</span> result = call.connection!!</span><br><span class="line">      eventListener.connectionAcquired(call, result)</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    route = localRouteSelection.next()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 4、创建一个新的连接</span></span><br><span class="line">  <span class="keyword">val</span> newConnection = RealConnection(connectionPool, route)</span><br><span class="line">  call.connectionToCancel = newConnection</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    newConnection.connect(</span><br><span class="line">        connectTimeout,</span><br><span class="line">        readTimeout,</span><br><span class="line">        writeTimeout,</span><br><span class="line">        pingIntervalMillis,</span><br><span class="line">        connectionRetryEnabled,</span><br><span class="line">        call,</span><br><span class="line">        eventListener</span><br><span class="line">    )</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    call.connectionToCancel = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  call.client.routeDatabase.connected(newConnection.route())</span><br><span class="line">  <span class="comment">// 5、从连接池获取连接</span></span><br><span class="line">  <span class="keyword">if</span> (connectionPool.callAcquirePooledConnection(address, call, routes, <span class="literal">true</span>)) &#123;</span><br><span class="line">    <span class="keyword">val</span> result = call.connection!!</span><br><span class="line">    nextRouteToTry = route</span><br><span class="line">    newConnection.socket().closeQuietly()</span><br><span class="line">    eventListener.connectionAcquired(call, result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  synchronized(newConnection) &#123;</span><br><span class="line">    connectionPool.put(newConnection)</span><br><span class="line">    call.acquireConnectionNoEvents(newConnection)</span><br><span class="line">  &#125;</span><br><span class="line">  eventListener.connectionAcquired(call, newConnection)</span><br><span class="line">  <span class="keyword">return</span> newConnection</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>第一个条件，<code>requireMultiplexed</code>表示 是否只获取多路复用的连接，即HTTP2连接。</p>
<p>因为HTTP 1.0 和 1.1 请求需要排队发送，当队头请求堵塞时，后面的请求都会被影响。因此HTTP2 做了优化，采用多路复用技术，多个请求合并使用同一个连接。</p>
<p>如果<code>requireMultiplexed = true</code>要求只拿HTTP2连接，但连接池中连接不支持，则continue，遍历下个连接，反之连接支持HTTP2则执行第二个条件。</p>
<p>如果<code>requireMultiplexed = false</code>不强求连接支持多路复用，直接执行第二个条件。</p>
<p>第二个条件<code>isEligible()</code>需要根据代码来判断是否有符合条件的连接，传入<code>address</code> 和 <code>routes</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealConnectionPool</span></span><br><span class="line">fun <span class="title function_">callAcquirePooledConnection</span><span class="params">(</span></span><br><span class="line"><span class="params">  address: Address,</span></span><br><span class="line"><span class="params">  call: RealCall,</span></span><br><span class="line"><span class="params">  routes: List&lt;Route&gt;?,</span></span><br><span class="line"><span class="params">  requireMultiplexed: Boolean</span></span><br><span class="line"><span class="params">)</span>: Boolean &#123;</span><br><span class="line">  <span class="keyword">for</span> (connection in connections) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(connection) &#123;</span><br><span class="line">      <span class="comment">// http2多路复用  </span></span><br><span class="line">      <span class="keyword">if</span> (requireMultiplexed &amp;&amp; !connection.isMultiplexed) <span class="keyword">return</span><span class="meta">@synchronized</span></span><br><span class="line">      <span class="keyword">if</span> (!connection.isEligible(address, routes)) <span class="keyword">return</span><span class="meta">@synchronized</span></span><br><span class="line">      call.acquireConnectionNoEvents(connection)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果HTTP 1.0 或 1.1 连接，满足以下两个条件则可复用连接</p>
<ol>
<li>先判断连接中已有的请求数，一个连接每次只能执行 1 个HTTP请求，并且当前连接没有正在执行的请求。</li>
<li>端口、主机名、代理、TLS版本、密码套件等连接相关的配置都要一致，则证明连接的是同一个服务器，比如请求<code>https://baidu.com/index/1</code> 和 <code>https://baidu.com/index/2</code>，两者可共用同一个连接。</li>
</ol>
<p>如果HTTP1.0或1.1条件不满足，再验证HTTP2，HTTP2一个连接支持执行多个请求，需要满足以下4个条件：</p>
<ol>
<li>支持HTTP2连接</li>
<li><code>routes</code> 不为空，且使用直连模式，ip相同</li>
<li>主机名可以不同，但证书为多域名证书，当前主机名可以验证通过。</li>
</ol>
<p>如果<code>https://github.com</code> 和 <code>https://githlab.com</code>是同一个服务器的虚拟主机，支持HTTP2，则请求这两个主机名都可以复用同一个连接。</p>
<ul>
<li>如果<code>routes = null</code>，则只能获取HTTP 1.0 &#x2F; 1.1 的连接</li>
<li>如果<code>routes != null</code>，则可以获取HTTP 1.0 &#x2F; 1.1 的连接HTTP2 的连接</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealConnection</span></span><br><span class="line">internal fun <span class="title function_">isEligible</span><span class="params">(address: Address, routes: List&lt;Route&gt;?)</span>: Boolean &#123;</span><br><span class="line">  assertThreadHoldsLock()</span><br><span class="line">  <span class="comment">// http1.0或1.1</span></span><br><span class="line">  <span class="keyword">if</span> (calls.size &gt;= allocationLimit || noNewExchanges) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  </span><br><span class="line">  <span class="title function_">if</span> <span class="params">(!<span class="built_in">this</span>.route.address.equalsNonHost(address)</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  </span><br><span class="line">  <span class="title function_">if</span> <span class="params">(address.url.host == <span class="built_in">this</span>.route()</span>.address.url.host) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// HTTP/2</span></span><br><span class="line">  <span class="keyword">if</span> (http2Connection == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"> </span><br><span class="line">  <span class="title function_">if</span> <span class="params">(routes == <span class="literal">null</span> || !routeMatchesAny(routes)</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"> </span><br><span class="line">  <span class="title function_">if</span> <span class="params">(address.hostnameVerifier !== OkHostnameVerifier)</span> <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="title function_">if</span> <span class="params">(!supportsUrl(address.url)</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    address.certificatePinner!!.check(address.url.host, handshake()!!.peerCertificates)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (_: SSLPeerUnverifiedException) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="从连接池获取连接过程"><a href="#从连接池获取连接过程" class="headerlink" title="从连接池获取连接过程"></a>从连接池获取连接过程</h4><p>下面会拆分<code>ExchangeFinder.findConnection()</code></p>
<p>第一次请求，connection 默认为null，当请求重试，比如重新刷新token，重定向。第一次请求完成后，当前connection已经建立可以直接复用。</p>
<p>比如请求<code>https://baidu.com/index1</code> 重定向返回的<code>https://baidu.com/index2</code>，则重定向可以复用连接。</p>
<p>如果第二次请求连接不能被复用，则会调用<code>closeQuietly()</code>方法安全释放当前连接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、第一次请求时connection = null，跳过，第二次请求连接可能已经建立</span></span><br><span class="line"> <span class="keyword">if</span> (callConnection != <span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> toClose: Socket? = <span class="literal">null</span></span><br><span class="line">   <span class="title function_">synchronized</span><span class="params">(callConnection)</span> &#123;</span><br><span class="line">     <span class="comment">// 当前连接不接受新请求或post、host不同，则会释放当前连接  </span></span><br><span class="line">     <span class="keyword">if</span> (callConnection.noNewExchanges || !sameHostAndPort(callConnection.route().address.url)) &#123;</span><br><span class="line">       toClose = call.releaseConnectionNoEvents()</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 如果当前连接可以直接复用</span></span><br><span class="line">   <span class="keyword">if</span> (call.connection != <span class="literal">null</span>) &#123;</span><br><span class="line">     check(toClose == <span class="literal">null</span>)</span><br><span class="line">     <span class="keyword">return</span> callConnection</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// The call&#x27;s connection was released.</span></span><br><span class="line">   toClose?.closeQuietly()</span><br><span class="line">   eventListener.connectionReleased(call, callConnection)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><code>routes = null</code>，<code>requireMultiplexed = false</code>，这两个条件一综合，先向连接池中获取HTTP1.0&#x2F;1.1的连接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">refusedStreamCount = <span class="number">0</span></span><br><span class="line">connectionShutdownCount = <span class="number">0</span></span><br><span class="line">otherFailureCount = <span class="number">0</span></span><br><span class="line"><span class="comment">// 2、从连接池中获取连接</span></span><br><span class="line"><span class="keyword">if</span> (connectionPool.callAcquirePooledConnection(address, call, <span class="literal">null</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">  <span class="type">val</span> <span class="variable">result</span> <span class="operator">=</span> call.connection!!</span><br><span class="line">  eventListener.connectionAcquired(call, result)</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Route</code>：包含<code>address</code>、<code>proxy</code>、<code>socketAddress</code>，<code>address</code>包括<code>host</code>和<code>port</code>。</p>
<p>一个域名下有多个IP，<code>proxy</code>包含直连和代理两种模式，路由就是IP、Port、主机名、代理模式的不同组合，网络数据包客户端-&gt;代理服务器-&gt;源服务器之间的传输路径。</p>
<p>Selection 按照Proxy 进行分类，直连模式下route分为一类，代理模式下route 分为一类。</p>
<p>如果有新的路由信息，再尝试从连接池获取连接，由于<code>routes != null</code>、<code>requireMultiplexed  = false</code>,既可以获取到HTTP1.0&#x2F;1.1的连接，也可以获取到HTTP2的连接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Nothing in the pool. Figure out what route we&#x27;ll try next.</span></span><br><span class="line">  val routes: List&lt;Route&gt;?</span><br><span class="line">  val route: Route</span><br><span class="line">    </span><br><span class="line">  <span class="title function_">if</span> <span class="params">(nextRouteToTry != <span class="literal">null</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// Use a route from a preceding coalesced connection.</span></span><br><span class="line">    routes = <span class="type">null</span></span><br><span class="line">    <span class="variable">route</span> <span class="operator">=</span> nextRouteToTry!!</span><br><span class="line">    nextRouteToTry = <span class="literal">null</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (routeSelection != <span class="literal">null</span> &amp;&amp; routeSelection!!.hasNext()) &#123;</span><br><span class="line">    <span class="comment">// Use a route from an existing route selection.</span></span><br><span class="line">    routes = <span class="type">null</span></span><br><span class="line">    <span class="variable">route</span> <span class="operator">=</span> routeSelection!!.next()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果有新的路由选择器</span></span><br><span class="line">    <span class="type">var</span> <span class="variable">localRouteSelector</span> <span class="operator">=</span> routeSelector</span><br><span class="line">    <span class="title function_">if</span> <span class="params">(localRouteSelector == <span class="literal">null</span>)</span> &#123;</span><br><span class="line">      localRouteSelector = RouteSelector(address, call.client.routeDatabase, call, eventListener)</span><br><span class="line">      <span class="built_in">this</span>.routeSelector = localRouteSelector</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">val</span> <span class="variable">localRouteSelection</span> <span class="operator">=</span> localRouteSelector.next()</span><br><span class="line">    routeSelection = <span class="type">localRouteSelection</span></span><br><span class="line">    <span class="variable">routes</span> <span class="operator">=</span> localRouteSelection.routes</span><br><span class="line">    <span class="title function_">if</span> <span class="params">(call.isCanceled()</span>) <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line">    <span class="comment">// 3、从连接池中获取连接</span></span><br><span class="line">    <span class="keyword">if</span> (connectionPool.callAcquirePooledConnection(address, call, routes, <span class="literal">false</span>)) &#123;</span><br><span class="line">      <span class="type">val</span> <span class="variable">result</span> <span class="operator">=</span> call.connection!!</span><br><span class="line">      eventListener.connectionAcquired(call, result)</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    route = localRouteSelection.next()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>如果前三次都没有从连接池中获取连接，则会创建一个新的连接，然后放入到缓存池当中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4、创建一个新的连接</span></span><br><span class="line"><span class="type">val</span> <span class="variable">newConnection</span> <span class="operator">=</span> RealConnection(connectionPool, route)</span><br><span class="line">call.connectionToCancel = newConnection</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  newConnection.connect(</span><br><span class="line">      connectTimeout,</span><br><span class="line">      readTimeout,</span><br><span class="line">      writeTimeout,</span><br><span class="line">      pingIntervalMillis,</span><br><span class="line">      connectionRetryEnabled,</span><br><span class="line">      call,</span><br><span class="line">      eventListener</span><br><span class="line">  )</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  call.connectionToCancel = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line">call.client.routeDatabase.connected(newConnection.route())</span><br></pre></td></tr></table></figure>



<p>创建完连接为什么还要再从连接池中获取。</p>
<p>这是考虑到极端情况，在上面线程池中并发执行两个相同域名的请求，同时创建了两个连接。</p>
<p>如果连接支持HTTP2，则可以将尝试两个请求合并到一个连接中。</p>
<p>所以<code>routes != null</code>，<code>requireMultiplexed = true</code>只获取HTTP2的连接。</p>
<p>如果获取到则之前创建的2个连接会弃用其中一个，节约资源。</p>
<p>如果没获取到则将新创建的连接放入到连接池中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5、从连接池获取连接</span></span><br><span class="line"> <span class="keyword">if</span> (connectionPool.callAcquirePooledConnection(address, call, routes, <span class="literal">true</span>)) &#123;</span><br><span class="line">   <span class="type">val</span> <span class="variable">result</span> <span class="operator">=</span> call.connection!!</span><br><span class="line">   nextRouteToTry = route</span><br><span class="line">   <span class="comment">// 关闭弃用当前新创建的连接    </span></span><br><span class="line">   newConnection.socket().closeQuietly()</span><br><span class="line">   eventListener.connectionAcquired(call, result)</span><br><span class="line">   <span class="keyword">return</span> result</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 新连接放入到连接池中</span></span><br><span class="line"> <span class="keyword">synchronized</span>(newConnection) &#123;</span><br><span class="line">   connectionPool.put(newConnection)</span><br><span class="line">   call.acquireConnectionNoEvents(newConnection)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="连接池管理"><a href="#连接池管理" class="headerlink" title="连接池管理"></a>连接池管理</h4><p>ConnectionPool 初始画有两个构造函数，需要传入一个代理对象<code>RealConnectionPool</code>，主要功能都由<code>RealConnectionPool</code>完成。</p>
<p><code>maxIdleConnections = 5</code> 表示连接池中最大空闲连接为5个。</p>
<p><code>keepAliveDuration = 5</code>表示连接池中连接的最长空闲时间为5分钟。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConnectionPool</span> internal <span class="title function_">constructor</span><span class="params">(</span></span><br><span class="line"><span class="params">  internal val delegate: RealConnectionPool</span></span><br><span class="line"><span class="params">)</span> &#123;	</span><br><span class="line">  constructor(</span><br><span class="line">    maxIdleConnections: Int,</span><br><span class="line">    keepAliveDuration: Long,</span><br><span class="line">    timeUnit: TimeUnit</span><br><span class="line">  ) : <span class="built_in">this</span>(RealConnectionPool(</span><br><span class="line">      taskRunner = TaskRunner.INSTANCE,</span><br><span class="line">      maxIdleConnections = maxIdleConnections,</span><br><span class="line">      keepAliveDuration = keepAliveDuration,</span><br><span class="line">      timeUnit = timeUnit</span><br><span class="line">  ))</span><br><span class="line">  constructor() : <span class="built_in">this</span>(<span class="number">5</span>, <span class="number">5</span>, TimeUnit.MINUTES)</span><br><span class="line">  <span class="comment">/** Returns the number of idle connections in the pool. */</span></span><br><span class="line">  fun <span class="title function_">idleConnectionCount</span><span class="params">()</span>: Int = delegate.idleConnectionCount()</span><br><span class="line">  <span class="comment">/** Returns total number of connections in the pool. */</span></span><br><span class="line">  fun <span class="title function_">connectionCount</span><span class="params">()</span>: Int = delegate.connectionCount()</span><br><span class="line">  <span class="comment">/** Close and remove all idle connections in the pool. */</span></span><br><span class="line">  fun <span class="title function_">evictAll</span><span class="params">()</span> &#123;</span><br><span class="line">    delegate.evictAll()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>会先将<code>connection</code>添加到线程安全的队列<code>connections</code>中，然后添加到任务队列中，执行连接清理任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealConnectionPool</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">val</span> <span class="variable">connections</span> <span class="operator">=</span> ConcurrentLinkedQueue&lt;RealConnection&gt;()</span><br><span class="line"><span class="keyword">private</span> val cleanupQueue: TaskQueue = taskRunner.newQueue()</span><br><span class="line"><span class="keyword">private</span> <span class="type">val</span> <span class="variable">cleanupTask</span> <span class="operator">=</span> object : Task(<span class="string">&quot;$okHttpName ConnectionPool&quot;</span>) &#123;</span><br><span class="line">  override fun <span class="title function_">runOnce</span><span class="params">()</span> = cleanup(System.nanoTime())</span><br><span class="line">&#125;</span><br><span class="line">fun <span class="title function_">put</span><span class="params">(connection: RealConnection)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.assertThreadHoldsLock()</span><br><span class="line">  connections.add(connection)</span><br><span class="line">  cleanupQueue.schedule(cleanupTask)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>task.runOnce()</code> 即 <code>RealConnectionPool.cleanup()</code>方法执行清理任务。</p>
<p>先遍历任务队列中的任务，正在使用的连接跳过，如果有空闲连接，则获取一个空闲时间最长的连接。</p>
<ul>
<li>队列中空闲连接已经超过 5 个，则移除空闲时间最长的连接。</li>
<li>连接空闲时间超过 5 分钟 则直接移除</li>
<li>连接空闲时间没有超过 5 分钟，比如只有 3 分钟，则记录剩余时间，2 分钟之后再调用<code>afterRun()</code>再执行。</li>
<li>没有空闲连接，但有正在使用的连接，则等5分钟之后再检查。</li>
<li>没有连接，则退出清理任务。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TaskRunner</span></span><br><span class="line"><span class="keyword">private</span> fun <span class="title function_">runTask</span><span class="params">(task: Task)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.assertThreadDoesntHoldLock()</span><br><span class="line">  <span class="type">val</span> <span class="variable">currentThread</span> <span class="operator">=</span> Thread.currentThread()</span><br><span class="line">  <span class="type">val</span> <span class="variable">oldName</span> <span class="operator">=</span> currentThread.name</span><br><span class="line">  currentThread.name = task.name</span><br><span class="line">  <span class="type">var</span> <span class="variable">delayNanos</span> <span class="operator">=</span> -<span class="number">1L</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    delayNanos = task.runOnce()</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">      afterRun(task, delayNanos)</span><br><span class="line">    &#125;</span><br><span class="line">    currentThread.name = oldName</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RealConnectionPool</span></span><br><span class="line">fun <span class="title function_">cleanup</span><span class="params">(now: Long)</span>: Long &#123;</span><br><span class="line">  <span class="type">var</span> <span class="variable">inUseConnectionCount</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">  <span class="type">var</span> <span class="variable">idleConnectionCount</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> longestIdleConnection: RealConnection? = <span class="literal">null</span></span><br><span class="line">  <span class="type">var</span> <span class="variable">longestIdleDurationNs</span> <span class="operator">=</span> Long.MIN_VALUE</span><br><span class="line">  <span class="comment">// Find either a connection to evict, or the time that the next eviction is due.</span></span><br><span class="line">  <span class="keyword">for</span> (connection in connections) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(connection) &#123;</span><br><span class="line">      <span class="comment">// 检查连接是否正在使用</span></span><br><span class="line">      <span class="keyword">if</span> (pruneAndGetAllocationCount(connection, now) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        inUseConnectionCount++</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是空闲连接  </span></span><br><span class="line">        idleConnectionCount++</span><br><span class="line">        <span class="comment">// 计算空闲时间</span></span><br><span class="line">        <span class="type">val</span> <span class="variable">idleDurationNs</span> <span class="operator">=</span> now - connection.idleAtNs</span><br><span class="line">         <span class="comment">// 获取最长空闲时间的连接</span></span><br><span class="line">        <span class="keyword">if</span> (idleDurationNs &gt; longestIdleDurationNs) &#123;</span><br><span class="line">          longestIdleDurationNs = <span class="type">idleDurationNs</span></span><br><span class="line">          <span class="variable">longestIdleConnection</span> <span class="operator">=</span> connection</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          Unit</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  when &#123;</span><br><span class="line">    <span class="comment">// 如果推举的连接最长闲置时间 &gt; 5分钟 或者 空闲连接数超过 5 个，则移除它</span></span><br><span class="line">    longestIdleDurationNs &gt;= <span class="built_in">this</span>.keepAliveDurationNs</span><br><span class="line">        || idleConnectionCount &gt; <span class="built_in">this</span>.maxIdleConnections -&gt; &#123;</span><br><span class="line">      <span class="comment">// We&#x27;ve chosen a connection to evict. Confirm it&#x27;s still okay to be evict, then close i</span></span><br><span class="line">      <span class="type">val</span> <span class="variable">connection</span> <span class="operator">=</span> longestIdleConnection!!</span><br><span class="line">      <span class="keyword">synchronized</span>(connection) &#123;</span><br><span class="line">        <span class="keyword">if</span> (connection.calls.isNotEmpty()) <span class="keyword">return</span> <span class="number">0L</span> <span class="comment">// No longer idle.</span></span><br><span class="line">        <span class="keyword">if</span> (connection.idleAtNs + longestIdleDurationNs != now) <span class="keyword">return</span> <span class="number">0L</span> <span class="comment">// No longer oldest.</span></span><br><span class="line">        connection.noNewExchanges = <span class="literal">true</span></span><br><span class="line">        connections.remove(longestIdleConnection)</span><br><span class="line">      &#125;</span><br><span class="line">      connection.socket().closeQuietly()</span><br><span class="line">      <span class="keyword">if</span> (connections.isEmpty()) cleanupQueue.cancelAll()</span><br><span class="line">      <span class="comment">// Clean up again immediately.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0L</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果空闲连接没有超过5分钟，则计算还有多久。</span></span><br><span class="line">    idleConnectionCount &gt; <span class="number">0</span> -&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> keepAliveDurationNs - longestIdleDurationNs</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有正在使用的连接则等5分钟后再检查  </span></span><br><span class="line">    inUseConnectionCount &gt; <span class="number">0</span> -&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> keepAliveDurationNs</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">      <span class="comment">// 如果没有连接，则等有连接了再说，退出任务</span></span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h5 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h5><p><code>newConnection.connect()</code>中先判断是否支持http tunnel，如果支持调用<code>connectTunnel()</code>。</p>
<p>如果是常用的HTTP连接，调用<code>connectSocket()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealConnection</span></span><br><span class="line">fun <span class="title function_">connect</span><span class="params">(</span></span><br><span class="line"><span class="params">  connectTimeout: Int,</span></span><br><span class="line"><span class="params">  readTimeout: Int,</span></span><br><span class="line"><span class="params">  writeTimeout: Int,</span></span><br><span class="line"><span class="params">  pingIntervalMillis: Int,</span></span><br><span class="line"><span class="params">  connectionRetryEnabled: Boolean,</span></span><br><span class="line"><span class="params">  call: Call,</span></span><br><span class="line"><span class="params">  eventListener: EventListener</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">  check(protocol == <span class="literal">null</span>) &#123; <span class="string">&quot;already connected&quot;</span> &#125;</span><br><span class="line">  <span class="keyword">var</span> routeException: RouteException? = <span class="literal">null</span></span><br><span class="line">  <span class="type">val</span> <span class="variable">connectionSpecs</span> <span class="operator">=</span> route.address.connectionSpecs</span><br><span class="line">  <span class="type">val</span> <span class="variable">connectionSpecSelector</span> <span class="operator">=</span> ConnectionSpecSelector(connectionSpecs)</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (route.requiresTunnel()) &#123;</span><br><span class="line">        <span class="comment">// 建立httpTunnel</span></span><br><span class="line">        connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener)</span><br><span class="line">        <span class="keyword">if</span> (rawSocket == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// We were unable to connect the tunnel but properly closed down our resources.</span></span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 连接socket  </span></span><br><span class="line">        connectSocket(connectTimeout, readTimeout, call, eventListener)</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="comment">// 建立tls、http连接   </span></span><br><span class="line">      establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener)</span><br><span class="line">      eventListener.connectEnd(call, route.socketAddress, route.proxy, protocol)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">      socket?.closeQuietly()</span><br><span class="line">      rawSocket?.closeQuietly()</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果是直连，调用<code>socketFactory.createSocket()</code>，<code>rawSocket</code>用于保存Socket 对象，调用<code>connectSocket()</code>建立TCP连接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealConnection</span></span><br><span class="line"><span class="keyword">private</span> fun <span class="title function_">connectSocket</span><span class="params">(</span></span><br><span class="line"><span class="params">  connectTimeout: Int,</span></span><br><span class="line"><span class="params">  readTimeout: Int,</span></span><br><span class="line"><span class="params">  call: Call,</span></span><br><span class="line"><span class="params">  eventListener: EventListener</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">  <span class="type">val</span> <span class="variable">proxy</span> <span class="operator">=</span> route.proxy</span><br><span class="line">  <span class="type">val</span> <span class="variable">address</span> <span class="operator">=</span> route.address</span><br><span class="line">  <span class="type">val</span> <span class="variable">rawSocket</span> <span class="operator">=</span> when (proxy.type()) &#123;</span><br><span class="line">    Proxy.Type.DIRECT, Proxy.Type.HTTP -&gt; address.socketFactory.createSocket()!!</span><br><span class="line">    <span class="keyword">else</span> -&gt; Socket(proxy)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.rawSocket = rawSocket</span><br><span class="line">  eventListener.connectStart(call, route.socketAddress, proxy)</span><br><span class="line">  rawSocket.soTimeout = readTimeout</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Platform.get().connectSocket(rawSocket, route.socketAddress, connectTimeout)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e: ConnectException) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ConnectException(<span class="string">&quot;Failed to connect to $&#123;route.socketAddress&#125;&quot;</span>).apply &#123;</span><br><span class="line">      initCause(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>如果Socket创建TCP连接成功，调用<code>establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener)</code></p>
<p>分为两种情况，HTTP连接 和 HTTPS连接。</p>
<ul>
<li>HTTP连接，HTTP1.0或1.1的协议则不需要做什么，直接返回<code>rawSocket</code>，如果支持HTTP2协议则调用<code>startHttp2()</code>,则会写入<code>&gt;&gt; CONNECTION PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n</code> 开启HTTP2 连接。</li>
<li>HTTPS连接，先会调用<code>connectTls()</code> 建立TLS连接，然后再判断支持需要开启HTTP2连接。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealConnection</span></span><br><span class="line"><span class="keyword">private</span> fun <span class="title function_">establishProtocol</span><span class="params">(</span></span><br><span class="line"><span class="params">  connectionSpecSelector: ConnectionSpecSelector,</span></span><br><span class="line"><span class="params">  pingIntervalMillis: Int,</span></span><br><span class="line"><span class="params">  call: Call,</span></span><br><span class="line"><span class="params">  eventListener: EventListener</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (route.address.sslSocketFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Protocol .H2_PRIOR_KNOWLEDGE in route.address.protocols) &#123;</span><br><span class="line">      socket = <span class="type">rawSocket</span></span><br><span class="line">      <span class="variable">protocol</span> <span class="operator">=</span> Protocol.H2_PRIOR_KNOWLEDGE</span><br><span class="line">      <span class="title function_">startHttp2</span><span class="params">(pingIntervalMillis)</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    socket = <span class="type">rawSocket</span></span><br><span class="line">    <span class="variable">protocol</span> <span class="operator">=</span> Protocol.HTTP_1_1</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  eventListener.secureConnectStart(call)</span><br><span class="line">  connectTls(connectionSpecSelector)</span><br><span class="line">  eventListener.secureConnectEnd(call, handshake)</span><br><span class="line">  <span class="keyword">if</span> (protocol === Protocol.HTTP_2) &#123;</span><br><span class="line">    startHttp2(pingIntervalMillis)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="获取HTTP编解码器"><a href="#获取HTTP编解码器" class="headerlink" title="获取HTTP编解码器"></a>获取HTTP编解码器</h4><p>当成功获取可用连接后，会调用<code>resultConnection.newCodec()</code>创建HTTP编解码器。</p>
<p>由于HTTP1.0 或 1.1 和 HTTP2 的报文格式不同，因此根据HTTP协议有<code>Http1ExchangeCodec</code> 和  <code>Http2ExchangeCodec</code> 两种编解码器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">internal fun <span class="title function_">newCodec</span><span class="params">(client: OkHttpClient, chain: RealInterceptorChain)</span>: ExchangeCodec &#123;</span><br><span class="line">  <span class="type">val</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="built_in">this</span>.socket!!</span><br><span class="line">  <span class="type">val</span> <span class="variable">source</span> <span class="operator">=</span> <span class="built_in">this</span>.source!!</span><br><span class="line">  <span class="type">val</span> <span class="variable">sink</span> <span class="operator">=</span> <span class="built_in">this</span>.sink!!</span><br><span class="line">  <span class="type">val</span> <span class="variable">http2Connection</span> <span class="operator">=</span> <span class="built_in">this</span>.http2Connection</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">if</span> (http2Connection != <span class="literal">null</span>) &#123;</span><br><span class="line">    Http2ExchangeCodec(client, <span class="built_in">this</span>, chain, http2Connection)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    socket.soTimeout = chain.readTimeoutMillis()</span><br><span class="line">    source.timeout().timeout(chain.readTimeoutMillis.toLong(), MILLISECONDS)</span><br><span class="line">    sink.timeout().timeout(chain.writeTimeoutMillis.toLong(), MILLISECONDS)</span><br><span class="line">    Http1ExchangeCodec(client, <span class="built_in">this</span>, source, sink)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Http1ExchangeCodec 会将headers 中的字段编码为 HTTP的请求报文格式，比如<code>Host: www.baidu.com\r\n</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Http1ExchangeCodec</span></span><br><span class="line">fun <span class="title function_">writeRequest</span><span class="params">(headers: Headers, requestLine: String)</span> &#123;</span><br><span class="line">  check(state == STATE_IDLE) &#123; <span class="string">&quot;state: $state&quot;</span> &#125;</span><br><span class="line">  sink.writeUtf8(requestLine).writeUtf8(<span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">  <span class="keyword">for</span> (i in <span class="number">0</span> until headers.size) &#123;</span><br><span class="line">    sink.writeUtf8(headers.name(i))</span><br><span class="line">        .writeUtf8(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">        .writeUtf8(headers.value(i))</span><br><span class="line">        .writeUtf8(<span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  sink.writeUtf8(<span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">  state = STATE_OPEN_REQUEST_BODY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>HTTP2 使用二进制分帧<code>Steam</code>，由</p>
<ul>
<li><strong>帧长度</strong></li>
<li><strong>帧类型</strong>(HEADERS 帧和 DATA 帧属于数据帧，存放的是 HTTP 报文，而 SETTINGS、PING、PRIORITY 等则是用来管理流的控制帧。)**</li>
<li>帧标志（ND_HEADERS<strong>表示头数据结束，相当于 HTTP&#x2F;1 里头后的空行（“\r\n”），</strong>END_STREAM**表示单方向数据发送结束（即 EOS，End of Stream），相当于 HTTP&#x2F;1 里 Chunked 分块结束标志（“0\r\n\r\n”））</li>
<li><strong>流标识符</strong>，也就是帧所属的“流”，接收方使用它就可以从乱序的帧里识别出具有相同流 ID 的帧序列，按顺序组装起来就实现了虚拟的“流”</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Http2ExchangeCodec </span></span><br><span class="line">override fun <span class="title function_">writeRequestHeaders</span><span class="params">(request: Request)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (stream != <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="type">val</span> <span class="variable">hasRequestBody</span> <span class="operator">=</span> request.body != <span class="literal">null</span></span><br><span class="line">  <span class="type">val</span> <span class="variable">requestHeaders</span> <span class="operator">=</span> http2HeadersList(request)</span><br><span class="line">  stream = http2Connection.newStream(requestHeaders, hasRequestBody)</span><br><span class="line">  <span class="comment">// We may have been asked to cancel while creating the new stream and sending the request</span></span><br><span class="line">  <span class="comment">// headers, but there was still no stream to close.</span></span><br><span class="line">  <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">    stream!!.closeLater(ErrorCode.CANCEL)</span><br><span class="line">    <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  stream!!.readTimeout().timeout(chain.readTimeoutMillis.toLong(), TimeUnit.MILLISECONDS)</span><br><span class="line">  stream!!.writeTimeout().timeout(chain.writeTimeoutMillis.toLong(), TimeUnit.MILLISECONDS)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>至此ConnectInterceptor工作完成，将HTTP编解码器，建立成功的连接，都放到<code>Exchange(this, eventListener, exchangeFinder, codec)</code>对象中。</p>
<p>Exchanage 具备了发送请求接收响应，对请求参数编码和对响应参数接码的功能，可以完成一次数据交换了。</p>
<h3 id="6、NetworkInterceptor-网络调试拦截器"><a href="#6、NetworkInterceptor-网络调试拦截器" class="headerlink" title="6、NetworkInterceptor 网络调试拦截器"></a>6、NetworkInterceptor 网络调试拦截器</h3><p><code>addNetworkInterceptor(Interceptor)</code> 和 前面介绍的 <code>addInterceptor(Interceptor)</code> 创建的拦截器行为逻辑使用都一样，唯一区别是位置不同。</p>
<p>它在发送请求拦截器前，重试重定向拦截器后，它可以获取每个请求和响应的完整原始数据（包括重定向以及重试的⼀些中间请求和响应)，主要用于做网络调试。</p>
<h3 id="7、CallServerInterceptor"><a href="#7、CallServerInterceptor" class="headerlink" title="7、CallServerInterceptor"></a>7、CallServerInterceptor</h3><p>它负责实质的请求与响应的 I&#x2F;O 操作，即往 Socket ⾥写⼊请求数据，和从 Socket ⾥读取响应数据。</p>
<p>主要通过<code>Exchange</code>实现，通过调用<code>writeRequestHeaders</code>写入数据、<code>flushRequest()</code>发送请求，<code>readResponseHeaders()</code>读取数据。</p>
<p>最后处理响应结果返回给上个拦截器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CallServerInterceptor</span>(<span class="keyword">private</span> val forWebSocket: Boolean) : Interceptor &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Throws(IOException::class)</span></span><br><span class="line">  override fun <span class="title function_">intercept</span><span class="params">(chain: Interceptor.Chain)</span>: Response &#123;</span><br><span class="line">    <span class="type">val</span> <span class="variable">realChain</span> <span class="operator">=</span> chain as RealInterceptorChain</span><br><span class="line">    <span class="type">val</span> <span class="variable">exchange</span> <span class="operator">=</span> realChain.exchange!!</span><br><span class="line">    <span class="type">val</span> <span class="variable">request</span> <span class="operator">=</span> realChain.request</span><br><span class="line">    <span class="type">val</span> <span class="variable">requestBody</span> <span class="operator">=</span> request.body</span><br><span class="line">    <span class="type">val</span> <span class="variable">sentRequestMillis</span> <span class="operator">=</span> System.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入请求报文</span></span><br><span class="line">    exchange.writeRequestHeaders(request)</span><br><span class="line"></span><br><span class="line">    <span class="type">var</span> <span class="variable">invokeStartEvent</span> <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> responseBuilder: Response.Builder? = <span class="literal">null</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 允许使用请求体，除了HEAD 和 GET请求</span></span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method) &amp;&amp; requestBody != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 客户端有POST数据要上传，可以考虑使用100-continue协议。加入头&#123;&quot;Expect&quot;:&quot;100-continue&quot;&#125;，征询服务器情况，看服务器是否处理POST的数据</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;100-continue&quot;</span>.equals(request.header(<span class="string">&quot;Expect&quot;</span>), ignoreCase = <span class="literal">true</span>)) &#123;</span><br><span class="line">        <span class="comment">// 发送请求  </span></span><br><span class="line">        exchange.flushRequest()</span><br><span class="line">        responseBuilder = exchange.readResponseHeaders(expectContinue = <span class="literal">true</span>)</span><br><span class="line">        exchange.responseHeadersStart()</span><br><span class="line">        invokeStartEvent = <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (responseBuilder == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (requestBody.isDuplex()) &#123;</span><br><span class="line">          <span class="comment">// Prepare a duplex body so that the application can send a request body later.</span></span><br><span class="line">          exchange.flushRequest()</span><br><span class="line">          <span class="type">val</span> <span class="variable">bufferedRequestBody</span> <span class="operator">=</span> exchange.createRequestBody(request, <span class="literal">true</span>).buffer()</span><br><span class="line">          requestBody.writeTo(bufferedRequestBody)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// Write the request body if the &quot;Expect: 100-continue&quot; expectation was met.</span></span><br><span class="line">          <span class="type">val</span> <span class="variable">bufferedRequestBody</span> <span class="operator">=</span> exchange.createRequestBody(request, <span class="literal">false</span>).buffer()</span><br><span class="line">          requestBody.writeTo(bufferedRequestBody)</span><br><span class="line">          bufferedRequestBody.close()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        exchange.noRequestBody()</span><br><span class="line">        <span class="keyword">if</span> (!exchange.connection.isMultiplexed) &#123;</span><br><span class="line">          <span class="comment">// If the &quot;Expect: 100-continue&quot; expectation wasn&#x27;t met, prevent the HTTP/1 connection</span></span><br><span class="line">          <span class="comment">// from being reused. Otherwise we&#x27;re still obligated to transmit the request body to</span></span><br><span class="line">          <span class="comment">// leave the connection in a consistent state.</span></span><br><span class="line">          exchange.noNewExchangesOnConnection()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      exchange.noRequestBody()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (requestBody == <span class="literal">null</span> || !requestBody.isDuplex()) &#123;</span><br><span class="line">      <span class="comment">// 发送请求    </span></span><br><span class="line">      exchange.finishRequest()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (responseBuilder == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 读取返回结果  </span></span><br><span class="line">      responseBuilder = exchange.readResponseHeaders(expectContinue = <span class="literal">false</span>)!!</span><br><span class="line">      <span class="keyword">if</span> (invokeStartEvent) &#123;</span><br><span class="line">        exchange.responseHeadersStart()</span><br><span class="line">        invokeStartEvent = <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">var</span> <span class="variable">response</span> <span class="operator">=</span> responseBuilder</span><br><span class="line">        .request(request)</span><br><span class="line">        .handshake(exchange.connection.handshake())</span><br><span class="line">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build()</span><br><span class="line">    <span class="type">var</span> <span class="variable">code</span> <span class="operator">=</span> response.code</span><br><span class="line">    <span class="title function_">if</span> <span class="params">(code == <span class="number">100</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// Server sent a 100-continue even though we did not request one. Try again to read the actual</span></span><br><span class="line">      <span class="comment">// response status.</span></span><br><span class="line">      responseBuilder = exchange.readResponseHeaders(expectContinue = <span class="literal">false</span>)!!</span><br><span class="line">      <span class="keyword">if</span> (invokeStartEvent) &#123;</span><br><span class="line">        exchange.responseHeadersStart()</span><br><span class="line">      &#125;</span><br><span class="line">      response = responseBuilder</span><br><span class="line">          .request(request)</span><br><span class="line">          .handshake(exchange.connection.handshake())</span><br><span class="line">          .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">          .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">          .build()</span><br><span class="line">      code = response.code</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    exchange.responseHeadersEnd(response)</span><br><span class="line"></span><br><span class="line">    response = <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</span><br><span class="line">      <span class="comment">// Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span></span><br><span class="line">      response.newBuilder()</span><br><span class="line">          .body(EMPTY_RESPONSE)</span><br><span class="line">          .build()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      response.newBuilder()</span><br><span class="line">          .body(exchange.openResponseBody(response))</span><br><span class="line">          .build()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;close&quot;</span>.equals(response.request.header(<span class="string">&quot;Connection&quot;</span>), ignoreCase = <span class="literal">true</span>) ||</span><br><span class="line">        <span class="string">&quot;close&quot;</span>.equals(response.header(<span class="string">&quot;Connection&quot;</span>), ignoreCase = <span class="literal">true</span>)) &#123;</span><br><span class="line">      exchange.noNewExchangesOnConnection()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((code == <span class="number">204</span> || code == <span class="number">205</span>) &amp;&amp; response.body?.contentLength() ?: -<span class="number">1L</span> &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ProtocolException(</span><br><span class="line">          <span class="string">&quot;HTTP $code had non-zero Content-Length: $&#123;response.body?.contentLength()&#125;&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>至此OKHttp请求流程分析完毕，通过 7 大拦截器完成HTTP的请求和响应。</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/08/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Https%E4%BB%8B%E7%BB%8D/" rel="prev" title="Https 介绍">
                  <i class="fa fa-angle-left"></i> Https 介绍
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/09/10/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/okhttp%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/" rel="next" title="okhttp缓存策略介绍">
                  okhttp缓存策略介绍 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">John Doe</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
