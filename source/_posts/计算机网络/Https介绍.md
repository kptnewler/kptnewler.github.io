---
title: Https 介绍
date: 2023-08-31 15:11:42
tags:
  - Https
categories:
  - 计算机网络
---

<meta name="referrer" content="no-referrer" />

# HTTPS 介绍

HTTP由于是明文传输的，传输信息会被任何中间商所获取、修改、伪装。如果进行线上交易，黑客很容易伪装成交易方获取你的交易信息，比如交易账号、实名信息等，危险财产安全。
HTTPS是一种新的应用层协议，默认端口为443，在HTTP的基础上增加了安全性，其他特点都和HTTP相同，相当于HTTP的安全进化版。

## HTTPS的安全特性

HTTPS增加了哪些安全特性保证了数据传输的安全呢？主要有以下4个安全特性：机密性、完整性、身份验证、不可否认。

### 机密性

机密性，通过密钥对传输的信息进行加密，只有接收方和发送发知道真实信息，黑客哪怕获取到密文，没有密钥也无法破解，解决HTTP协议中明文数据被黑客获取的问题。

### 完整性

完整性，验证并保证数据传输的完整。因为发送方传输的数据即使被加密，黑客能通过劫持后能修改密文，接收方如果不能验证完整性，解密之后就是错误的信息，整个通信过程就被破坏了。

### 身份验证

身份验证，验证传输信息双方的真实身份，证明信息确实是可信的人传递的，而不是黑客传来的。

### 不可否认

不可否认，不能否认已经发生的行为，发送方给接收方传递了信息，发送方不能说自己没传过。

### 生活实例

下面这个生活小例子，说明了这4种安全特性。

小明和小红上课喜欢纸条，但是离得远只能通过小强传递，小强喜欢看他们纸条内容。于是小红和小明放学约定了一个加密规则，对纸条内容进行加密，即使小强看了纸条也不知道啥意思。

小强没办法知道纸条内容，于是恼羞成怒，每次在纸条里面加几个字，导致小红和小明都解密出错误的信息，小红和小明又约定了一个验证完整性的规则，小强以后改了纸条信息也能被发现。

小强没辙了，就假冒小明给小红写纸条，小红不知道，以为小明突然又用明文传输了，于是就给他回了，于是和小强传了一早上纸条，小明的纸条传的纸条都被小强扔了。小红和小明放学一合计被小强耍了，于是又定了一个规则验证双方身份信息，保证纸条不是小强传的。

小强终于老实了，但是小红和小明遇到了问题，小明在纸条里写了周末带小红去欢乐谷，放学了小明突然想起来周末有事，于是不承认对小红说过，小红老生气了，但是纸条被扔了也没办法，就跟小明说这次先原谅你，现在说好以后纸条我们两个都要收好，免得对方赖账。

## SSL/TLS协议

上面介绍了HTTPS的安全特性，HTTPS依靠SSL协议实现安全特性，保证数据传输的安全。

HTTPS中的"S"指的就是SSL/TLS，HTTP下层是TCP/IP协议栈，而HTTPS在下层加了SSL/TTL协议，先调用专门的安全接口，再把接口处理过的数据传给TCP/IP协议栈。

![HTTPS 结构图](https://upload-images.jianshu.io/upload_images/4538003-7d1a7f0d45c91fdc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

SSL 即安全套接层（Secure Sockets Layer），在 OSI 模型中处于第 5 层（会话层），由网景公司于 1994 年发明，有 v2 和 v3 两个版本，而 v1 因为有严重的缺陷从未公开过。

SSL 发展到 v3 时已经证明了它自身是一个非常好的安全通信协议，于是互联网工程组 IETF 在 1999 年把它改名为 TLS（传输层安全，Transport Layer Security），正式标准化，版本号从 1.0 重新算起，所以 TLS1.0 实际上就是 SSLv3.1。

到今天 TLS 已经发展出了三个版本，分别是 2006 年的 1.1、2008 年的 1.2 和去年（2018）的 1.3，每个新版本都紧跟密码学的发展和互联网的现状，持续强化安全和性能，已经成为了信息安全领域中的权威标准。

目前应用的最广泛的 TLS 是 1.2，而之前的协议（TLS1.1/1.0、SSLv3/v2）都已经被认为是不安全的，各大浏览器即将在 2020 年左右停止支持，所以接下来的讲解都针对的是 TLS1.2。

浏览器和服务器在使用 TLS 建立连接时需要选择一组恰当的加密算法来实现安全通信，这些算法的组合被称为“密码套件”（cipher suite，也叫加密套件）。

### TLS 协议的组成

TLS 包含几个子协议，你也可以理解为它是由几个不同职责的模块组成，比较常用的有记录协议、警报协议、握手协议、变更密码规范协议等。

- **记录协议**（Record Protocol）规定了 TLS 收发数据的基本单位：记录（record）。它有点像是 TCP 里的 segment，所有的其他子协议都需要通过记录协议发出。但多个记录数据可以在一个 TCP 包里一次性发出，也并不需要像 TCP 那样返回 ACK。

- **警报协议**（Alert Protocol）的职责是向对方发出警报信息，有点像是 HTTP 协议里的状态码。比如，protocol_version 就是不支持旧版本，bad_certificate 就是证书有问题，收到警报后另一方可以选择继续，也可以立即终止连接。

- **握手协议**（Handshake Protocol）是 TLS 里最复杂的子协议，要比 TCP 的 SYN/ACK 复杂的多，浏览器和服务器会在握手过程中协商 TLS 版本号、随机数、密码套件等信息，然后交换证书和密钥参数，最终双方协商得到会话密钥，用于后续的混合加密系统。

- **变更密码规范协议**（Change Cipher Spec Protocol），它非常简单，就是一个“通知”，告诉对方，后续的数据都将使用加密保护。那么反过来，在它之前，数据都是明文的。

## 摘要算法

**实现完整性的手段主要是摘要算法（Digest Algorithm），也就是常说的散列函数、哈希函数。摘要算法能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，且不可逆，不能通过摘要字符串推出原数据。**

只有输入相同的明文数据经过相同的摘要算法才能得到相同的摘要字符串，哪怕明文数据和之前有一个字符的微小差别，生成的摘要字符串也是不同的。

客户端将请求数据通过摘要算法得出摘要字符串，附加到请求数据后（可以区分请求消息和摘要字符串）。服务端接受到之后，解密取出请求字符串，用相同的摘要算法得出摘要字符串，将两份摘要字符串进行比对，如果相同，则数据完整且没有被修改。

![摘要算法过程](https://upload-images.jianshu.io/upload_images/4538003-90b33e252dd30e95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

常用的摘要算法有MD5和SHA-1，能够生成16字节和20字节长度的数字摘要。但这两个算法的安全强度比较低，不够安全，在 TLS 里已经被禁止使用了。

TLS目前推荐使用的SHA-1的后继者——SHA-2。SHA-2 实际上是一系列摘要算法的统称，总共有 6 种，常用的有 SHA224、SHA256、SHA384，分别能够生成 28 字节、32 字节、48 字节的摘要。

TLS使用摘要算法生成摘要字符串，再对摘要字符串用下面的加密方法进行加密，就保证了机密性和完整性。

## 加密算法

TLS/SSL中的加密算法组合实现了HTTPS中的安全特性，下面详细介绍这些加密算法。

### 对称加密算法

对称加密双方约定好一个密钥，称为**会话密钥**，双方通过会话密钥进行加密、解密数据，保证了数据的机密性。
网站通过密钥加密数据明文，把密文发送给客户端，客户端收到之后再通过密钥解析密文，获取数据明文。黑客即使拦截了，获取的只是密文，没有密钥就无法破解得出明文。

TLS 里有非常多的对称加密算法可供选择，比如 RC4、DES、3DES、AES、ChaCha20 等，但前三种算法密钥较短，可以暴力破解，被认为是不安全的，通常都禁止使用。目前常用的只有 AES 和 ChaCha20。

AES 的意思是“高级加密标准”（Advanced Encryption Standard），密钥长度可以是 128、192 或 256。它是 DES 算法的替代者，安全强度很高，性能也很好，而且有的硬件还会做特殊优化，所以非常流行，是应用最广泛的对称加密算法，被许多浏览器和服务器所应用。

ChaCha20 是 Google 设计的另一种加密算法，密钥长度固定为 256 位，纯软件运行性能要超过 AES，曾经在移动客户端上比较流行，但 ARMv8 之后也加入了 AES 硬件优化，所以现在不再具有明显的优势，但仍然算得上是一个不错算法。

### 分组密码模式

AES、ChaCha20 等对称加密算法只能通过固定长度的密钥加密明文，因此能加密的明文长度是受限制的。如果要加密任意长度的明文，需要将明文进行分组，由对称加密算法迭代分组加密，具体迭代的方式就称为分组迭代模式。
![分组加密](https://upload-images.jianshu.io/upload_images/4538003-3156fa0571d246fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

最早有 ECB、CBC、CFB、OFB 等几种分组模式，但都陆续被发现有安全漏洞，所以现在基本都不怎么用了。最新的分组模式被称为 AEAD（Authenticated Encryption with Associated Data），在加密的同时增加了认证的功能，常用的是 GCM、CCM 和 Poly1305。

对称加密算法+分组密码模式，组成TLS协议中加密任意长度明文的方法。比如AES128-GCM，意思是密钥长度为 128 位的 AES 算法，使用的分组模式是 GCM。

### 非对称加密算法

对称加密需要双方持有密钥才能对数据进行加密和解密，这就涉及到密钥传输问题了。如果用明文传输就会被黑客获取，破解密文。如果不用明文，使用对称加密，那么遇到了相同的问题如何传输新密钥，循环往复。**因此密钥传输不能使用对称加密，而采用非对称加密。**

非对称加密基本原理就是先创建一个私钥，只能自己拥有，再用私钥创建一个公钥，是公开的任何人都可以获取。公钥和私钥有个特别的“单向”性，公钥加密的数据只能私钥解密，私钥加密的数据只能公钥解密。

所以非对称加密有两大作用：

**加密数据，公钥加密数据，私钥解密数据**。服务端生成一对私钥和公钥，将公钥传给客户端，客户端用公钥加密数据后传给服务端，服务端在用私钥解密。即使中间商获取了公钥，公钥无法解密数据。

**数字签名，私钥加密数据，公钥解密数据**。数字签名作用就是做身份验证，服务端用私钥加密数据，客户端能用公钥解密，由于私钥只有服务端一个人有，中间商获取不到，所以就可以证明数据确实是服务端发送。
就好比人民币的防伪标志，每个人都知道怎么看防伪标志，但是只有银行拥有这个技术，所以就可以证明钱确实是银行印的。

非对称加密算法的设计要比对称算法难得多，在 TLS 里只有很少的几种，比如 DH、DSA、RSA、ECC 等。

RSA 可能是其中最著名的一个，几乎可以说是非对称加密的代名词，它的安全性基于“整数分解”的数学难题，使用两个超大素数的乘积作为生成密钥的材料，想要从公钥推算出私钥是非常困难的。

10 年前 RSA 密钥的推荐长度是1024，但随着计算机运算能力的提高，现在1024已经不安全，普遍认为至少要2048位。

ECC（Elliptic Curve Cryptography）是非对称加密里的“后起之秀”，它基于“椭圆曲线离散对数”的数学难题，使用特定的曲线方程和基点生成公钥和私钥。

椭圆曲线离散对数，在椭圆上使用固定的基点，从基点出发做连续次数的折射，最终到达椭圆上的另外一个点。折射次数作为私钥，终点作为公钥。即使知道了基点和终点，也很难反推出经过多少次折射，因为私钥安全性很高。

子算法 ECDHE 用于密钥交换，ECDSA 用于数字签名。

### 混合加密

既然非对称加密可以解决公钥加密问题，为什么不用非对称加密算法加密信息呢？**因为非对称加密算法加密效率很低。**如下所示，对称加密算法AES128是13MB/s，非对称加密算法RSA2048是15KB/s，加密效率相差几百倍。

```log
aes_128_cbc enc/dec 1000 times : 0.97ms, 13.11MB/s

rsa_1024 enc/dec 1000 times : 138.59ms, 93.80KB/s
rsa_1024/aes ratio = 143.17

rsa_2048 enc/dec 1000 times : 840.35ms, 15.47KB/s
rsa_2048/aes ratio = 868.13
```

在TLS协议把对称加密算法和非对称加密算法相结合。

**服务端和客户端用非对称加密协商出一套对称密钥，发送方用对称密钥加密数据，接收方用对称密钥解密数据。**

混合加密就解决了对称加密算法的密钥交换问题，而且安全和性能兼顾，完美地实现了机密性。

![混合加密过程](https://upload-images.jianshu.io/upload_images/4538003-c5b16392678809da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 数字签名在HTTPS中应用

**数字签名的作用为验证身份**，主要分为单向认证和双向认证目前主要使用单项认证。

### 单向认证

单向认证在TLS协议中只对服务端的身份进行验证，而客户端的身份在服务端应用层上通过账号、密码等信息进行验证。

所以只要服务端生成公钥和私钥，公钥保存在数字证书中发送给客户端，发送数据并通过公钥对摘要字符串进行加密。客户端则不需要生成公钥和私钥，对数据数字签名。

### 双向验证

双向认证是指在TLS协议中认证双方的身份。客户端和服务端都要生成公钥和私钥，然后互传数字证书，传输数据是要用自己的私钥对摘要字符串加密，收到之后用对方的公钥解密认证身份。

**数字签名主要应用在公钥传输和加密数据传输。**

### 加密数据传输

上述通过加密算法和摘要算法实现了机密性和完整性，黑客无法获取和修改明文数据了，但是黑客可以抓取到发送的密文，然后伪装客户端像服务器发起请求，比如抓取到客户端转账请求的密文，发送给服务器，服务器无法验证具体的身份，就会执行转账请求。

所以服务端会对数据先进行 hash 计算等到 hash code，然后再用私钥加密 hash code。

### 公钥传输

服务端是明文传输公钥给客户端，为什么使用明文传输呢，因为如果对公钥加密又会陷入同样的问题，需要对新密钥进行加密，又是循环往复。

选择使用明文传输，公钥信息就会被黑客获取，然后伪造假的公钥发给客户端，客户端收到假的公钥，用假公钥加密会话密钥，导致服务端无法解密，整个通信过程被破坏。

服务端传输 A公钥给客户端时，服务端需要用 B私钥 对 A公钥进行加密生成数字签名，并且将B公钥传给客户端。

客户端持有B公钥 如果能解密，说明 A公钥确实来自服务端，因为B私钥只有服务端有其他中间商都没有。

![](https://upload-images.jianshu.io/upload_images/4538003-ae17cfa53129c2cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

那么问题来了，我怎么确保B公钥来自服务端呢？于是改成下面这个样子。

![image.png](https://upload-images.jianshu.io/upload_images/4538003-e3d8878bd85455d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

那又要保证C公钥，如此循环下去永无止境，**因此引入了CA(证书认证机构)和数字证书。**


## 数字证书

**数字证书的作用就是保证服务器公钥确实是服务器发的，而不是被中间商伪造。**

CA即为证书认证机构，为服务器的公钥签字担保，保证公钥是真的。相当于我们身份证上的签发单位公安局，公安局的公信力很高，所以大家都相信身份证信息是真的。

**数字证书由证书信息和数字签名组成。**
证书信息主要包括**服务器公钥**，**服务器主机名**，**证书的所有者**类似身份证上的姓名和身份证号，**颁发机构**类似身份证上给办理的公安局，**证书有效期**类似身份证上的有效期等。
1. 服务端会发送 CSR(证书签名请求,包括传递的公钥和证书信息)到 CA。
2. CA 会验证 CSR 中的信息，比如服务器主机名是否存在等。
3. 数字签名，使用摘要算法对 CSR 信息做 Hash 计算，得到一个 Hash 值，使用 CA 私钥加密摘要值。
4. 这个证书包含了公钥、证书信息和签名信息。

中间证书都应由其上一级证书（即其父证书的 CA）签名。客户端会使用父证书的公钥来验证中间证书的签名。
最终信任链顶端的CA没人给他签名了，这个就叫“自签名证书”或者“根证书”。全球大的CA只有几个，操作系统和浏览器都内置了各大 CA 的根证书，所以根证书的签名验证是浏览器或操作系统完成。

![证书](https://upload-images.jianshu.io/upload_images/4538003-79d82b8dafe3f6ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

就像你不相信派出所，可以打电话问市公安局确认派出所的合法性，不相信市公安局，打电话给省公安厅确认市公安局的合法性，往上最终到达公安部。公安部全中国就一个，你不信也得信。

![](https://upload-images.jianshu.io/upload_images/4538003-d01fd359e5910d50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


### 验证过程

服务器把证书传给浏览器，浏览器读取证书中的证书所有者、有效期等信息进行一一校验。**验证host是否和客户端一致**，防止中间商发其他网站的证书，这样即使签名验证正确，但是公钥不是服务端发来的那个。

**校验证书签名**。
1. 从预装在浏览器或操作系统的根证书内的公钥，验证一级中间证书。
2. 一级中间证书拿当前证书公钥，再去验证二级证书，循环往复。
3. 最终验证得出证书没有问题，最后一层证书的公钥即为服务端公钥。

**数字证书可以保证非对称加密的公钥的准确性，那直接把对称加密的密钥放在数字证书中不就好了吗？**
显然不行，因为每个服务端的CA证书都是申请好固定的，但是对称加密的密钥，一次会话结束，就发生变化了，并且服务端和客户端每个连接的对称加密的密钥都是不同的。
不能每次生成一个新的密钥就去申请一个数字证书吧。


## TLS1.2握手过程

TLS 由记录协议、握手协议、警告协议、变更密码规范协议、扩展协议等几个子协议组成，综合使用了对称加密、非对称加密、身份认证等许多密码学前沿技术，下面介绍是如何将子协议和密码学运用在握手过程中。

下面介绍TLS协议中两种握手方式，区别在于使用不同的非对称加密算法，用于交换对称加密的密钥。一种是ECDHE非对称加密算法，一种是RSA非对称加密算法。

### TLS使用ECDHE算法握手过程

握手过程如下图所示，我们使用 WireShark 抓包分析一下，具体如何抓包可以看这篇文章[配置Wireshark抓取https数据包 解密SSL](https://blog.csdn.net/nimasike/article/details/80887436)。

通过分析抓包，TLS算法最多经过两次消息往返（4 个消息）就可以完成握手，然后就可以在安全的通信环境里发送 HTTP 报文，实现 HTTPS 协议。

#### 1. 建立连接

通过TCP协议3次握手建立连接。

#### 2. 客户端Client Hello

客户端会先向服务器发送请求，可以理解成打招呼。
客户端通过`Client Hello`类型的握手子协议，主要发送以下信息给服务器：

Version：TLS的版本号。

Random：客户端随机数用于生成主密钥，会话密钥基于主密钥进行扩展。

Cipher Suites：客户端支持的密钥套件，密钥套件定义一个密钥交换算法、一个数据密算法、一个身份认证（MAC）算法，以及一个伪随机函数（PRF）。
比如`Cipher Suite: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384(0xc030)`：

- `TLS`表示TLS协议。
- `ECDHE`作为密钥交换算法。
- `RSA`作为身份认证算法，用于加密摘要字符串。
- `SHA384`作为伪随机算法或摘要算法，摘要算法生成摘要字符串，伪随机算法用于生成主钥，密钥交换部分会详细介绍。

Extension: 扩展字段。扩展字段可以在不修改协议本身的条件下为TLS协议增加功能。

![Clienet Hello报文](https://upload-images.jianshu.io/upload_images/4538003-407bf196e9a1b023.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 3.服务端Server Hello、Certificate、Server Key Exchange

TLS中的记录子协议，其他子协议作为一个记录单位，一个TCP包可以发送多个握手协议类型。服务器接收到客户端发来`Client Hello`，一次性返回以下4个握手子协议类型数据。

![记录子协议](https://upload-images.jianshu.io/upload_images/4538003-775e8ce57c68427b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### Server Hello

比对TLS版本后，服务器返回 Random(随机数)用于生成主密钥，从客户端密码套间中确定一个在HTTPS中使用的密码套件，这里确定为 `TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 (0xc030)`，还有其他的扩展参数。

![Server Hello报文](https://upload-images.jianshu.io/upload_images/4538003-e62f421283f195ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### Server Certificate

服务端用已确定密码套件中的`RSA`算法生成公钥和私钥，把服务端公钥放入数字证书中，并对数字证书进行签名，发送给客户端，确保服务器身份。

![Certificate报文](https://upload-images.jianshu.io/upload_images/4538003-117092e09de75d42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### Server Key Exchange

因为选择了 ECDHE 算法作为密钥交换算法。

ECDHE算法详细介绍可以看极客时间的透视HTTP协议专栏中的[DHE/ECDHE算法的原理](https://time.geekbang.org/column/article/148188)。

ECDHE（椭圆曲线Diffie-Hellman Ephemeral）算法生成密钥的过程如下：
1. 选择一个椭圆曲线：ECDHE首先需要选择一个椭圆曲线。这个曲线通常是预定义的，并且在所有使用ECDHE的设备中都是一样的。

2. 生成临时密钥对：服务端和客户端各自生成一对临时的 ECDH 公私钥。这对公私钥只会用于当前的 SSL/TLS 会话，会话结束后就会被丢弃。

3. 交换公钥：服务端将其临时 ECDH 公钥`server_ephemeral_key`发送给客户端，客户端也将其临时 ECDH 公钥发送给服务端。这两个公钥都是明文发送的。

4. 计算共享密钥：服务端使用自己的临时ECDH私钥和客户端的临时 ECDH 公钥进行计算，得到一个共享密钥；客户端也使用自己的临时 ECDH 私钥和服务端的临时 ECDH 公钥进行计算，也得到一个共享密钥。由于 ECDH 算法的特性，这两个共享密钥是相同的。

5. 生成会话密钥：最后，这个共享密钥会被用来生成会话密钥，用于后续的通信加密。

6. P1 和 P2 的值相同，作为各自的`pre-master`生成主密钥。就好比 1+10=11,2+10=12, 交换 11 和 12，1+12=2+11。

使用 ECDHE 的优点是，即使有人拦截到了临时的 ECDH 公钥，也无法计算出共享密钥，因为计算共享密钥需要知道临时的 ECDH 私钥，而这个私钥从来不在网络中传输。
另外，由于每个会话都使用不同的临时 ECDH 公私钥，所以ECDHE提供了前向保密，即使服务端的长期私钥被泄露，也不会影响之前的SSL/TLS会话的安全性。


**服务端通过椭圆曲线生成临时 ECDH 公钥，并加上自己的私钥签名，保证身份验证和完整性，`server_key_params`本身并不会被加密**。

这一步并非直接交换对称加密的会话密钥，而是生成密钥的其中一个参数。

![Server Key Exchange报文](https://upload-images.jianshu.io/upload_images/4538003-136455d72dfe064b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### Server Hello Done

表示服务器已经将所有预计的握手消息发送完毕。在此之后，服务器会等待客户端发送消息。

#### 4.客户端Client Key Exchange、Change Cipher Spec、Encrypted Handshake Message

客户端收到服务器的数据，会按照信证书链逐级验证数字证书，确认数字证书是合法的，说明确实来自于服务器，取出服务端公钥`server_pub_key`。

通过一个TCP包返回以下3个握手子协议类型数据。

![客户端](https://upload-images.jianshu.io/upload_images/4538003-0849aa61518da4c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### Client Key Exchange

**客户端根据确定的椭圆曲线也生成客户端的临时 ECDH 公钥和私钥。
由于采用单向认证，服务端不需要在TLS协议层验证客户端的身份，因此没有加数字签名，将客户端临时 ECDH 公钥明文返回给服务端。**
![Client Key Exchange报文](https://upload-images.jianshu.io/upload_images/4538003-5d89325cbceb6e44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### Client Change Cipher Spec

客户端和服务端都拥有了对方临时的 ECDH 公钥，把它们带入 ECDHE 算法得出相同的`pre_master`。

客户端再把`pre_master`、`client_random`和`server_random`，通过密码套件中的伪随机算法`SHA384`得出相同的**主密钥`Master Secret`**。

服务端和客户端都会使用这个预主密钥，以及相同的伪随机函数（Pseudorandom Function，简称PRF），生成一系列的会话密钥。
**包括客户端写密钥（client_write_key）和服务器写密钥（server_write_key）, 用于加密后续的信息。**

为什么对称加密，要生成客户端和服务端两个会话密钥呢？
客户端发送消息使用客户端密钥加密，服务端发送消息使用服务端密钥加密。
使用一个密钥的风险在于，身份验证失效了。中间商获取之后，直接原封不动把消息丢回来，客户端收到之后依然可以解密，就以为真是服务器发来的。

然后返回消息通知服务端后面通信使用`AES_256_GCM`对称加密算法，使用刚生成的会话密钥加密。
![Change Cipher Spec报文](https://upload-images.jianshu.io/upload_images/4538003-c31f23532b8d6815.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


##### Client Encrypted Handshake Message

这是由客户端服务器之间协商的算法和密钥保护的第一个消息。它意味着握手已经完成。消息内容将使用会话密钥加密，以便双发可以安全地交换验证整个握手完整性所需要的数据。

![Encrypted Handshake Message报文](https://upload-images.jianshu.io/upload_images/4538003-cabcc83d1d543a6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 5. 服务端Change Cipher Spec、Encrypted Handshake Message

服务端接收到`client_pub_key`之后，服务端也会生成相同的主密钥`Master Secret`，扩展生成会话密钥，通知客户端传输的数据将使用对称加密。
随后消息内容使用对称加密，发送给客户端。

![服务端Change Cipher Spec、Encrypted Handshake Message报文](https://upload-images.jianshu.io/upload_images/4538003-79a744fbffde3d6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 6.客户端Encrypted Alert

客户端收到服务端的加密信息，表示可以正常通信，握手完成，服务端和客户端会互传数据并加密。

![ECDHE抓包图](https://upload-images.jianshu.io/upload_images/4538003-f46df35ac4b97684.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

ECDHE 传输过程如下：
1. 客户端和服务端建立连接，Client Hello 将客户端端随机数、密码套件等发送给服务端。
2. 服务端收到后Server Hello，将服务端随机数，选定的密码套件等发送给客户端。
3. 服务端再将包含服务器公钥、服务器主机名等数字证书信息和证书签名，CA证书和签名发送给客户端。
4. 客户端先验证数字证书和主机名是否正确，确定是服务器发送的之后，提取出服务器公钥。
5. 客户端再将客户端公钥发送给服务器，如果单向认证不需要证书，如果双向认证需要发送客户端证书。
6. 服务器和客户端根据双方的公钥生成pre_master，加上双方随机数生成master，扩展生成服务端和客户端会话密钥。
7. 客户端使用会话密钥加密，通知服务端以后使用对称加密。
8. 服务端收到后也会使用对称加密。


![ECDHE握手过程](https://upload-images.jianshu.io/upload_images/4538003-fee7dd4e0e099c74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## RAS传输过程

HTTPS中使用**非对称加密算法**加密 生成**对称加密算法**秘钥的关键信息，再使用**对称加密算法**来加密传输信息。这句话有点绕，看下面过程应该就可以理解了：

1. 客户端和服务端建立连接，客户端给服务端发送一个随机数，用于后面加密。

2. 服务端收到，也发给客户端一个随机数，用于后面加密。

3. 服务端生成公钥和私钥，CA证书保存公钥，并发送CA证书给客户端。

4. 客户端收到CA证书，使用CA公钥进行验证解析，获取服务端的公钥，并生成一个随机数字`pre-master`,再把`pre-master`使用解析出的公钥进行加密传输给服务器端。

5. 服务器接收到之后加密的随机数字`pre-master`之后，使用私钥进行解析，获取`pre-master`明文数字。

6. 客户端和服务端使用**客户端的随机数+服务端的随机数+pre-master**计算得出对称加密算法秘钥。

7. 客户端和服务端使用秘钥加密传输信息。

![传输过程](https://upload-images.jianshu.io/upload_images/4538003-94cbc972b09a02f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)