<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.18.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Hexo</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/10/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/okhttp%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/10/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/okhttp%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/" class="post-title-link" itemprop="url">okhttp缓存策略介绍</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-09-10 15:35:14" itemprop="dateCreated datePublished" datetime="2023-09-10T15:35:14+00:00">2023-09-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-09-11 11:02:55" itemprop="dateModified" datetime="2023-09-11T11:02:55+00:00">2023-09-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <meta name="referrer" content="no-referrer" />

<p>在 okhttp 责任链中在建立网络连接之前有个 CacheInterceptor 负责缓存相关。<br>okhttp 实现了 http 协议的所有缓存策略和缓存字段的解析。</p>
<p>在请求之前先调用 <code>CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()</code> 获取缓存策略。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> call = chain.call()</span><br><span class="line"><span class="keyword">val</span> cacheCandidate = cache?.<span class="keyword">get</span>(chain.request())</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> now = System.currentTimeMillis()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> strategy = CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()</span><br><span class="line"><span class="keyword">val</span> networkRequest = strategy.networkRequest</span><br><span class="line"><span class="keyword">val</span> cacheResponse = strategy.cacheResponse</span><br><span class="line"></span><br><span class="line">cache?.trackResponse(strategy)</span><br><span class="line"><span class="keyword">val</span> listener = (call <span class="keyword">as</span>? RealCall)?.eventListener ?: EventListener.NONE</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cacheCandidate != <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="comment">// The cache candidate wasn&#x27;t applicable. Close it.</span></span><br><span class="line">  cacheCandidate.body.closeQuietly()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缓存策略实现逻辑在 <code>CacheStrategy</code> 类中。<br>缓存信息实现逻辑和容器在 <code>Cache</code> 类中。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>在初始化的时候，如果有缓存响应，则从响应头中依次取出:</p>
<ul>
<li>Date, 服务器的时间。</li>
<li>Expires，过期时间。</li>
<li>Last-Modified: 资源被修改的日期，用于条件请求。</li>
<li>ETag: 客户端资源唯一标识，主要是用来解决修改时间无法准确区分文件变化的问题，用于条件请求。</li>
<li>Age: 资源在缓存中存在的时间。<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CacheStrategy.Factory()</span></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.sentRequestMillis = cacheResponse.sentRequestAtMillis</span><br><span class="line">        <span class="keyword">this</span>.receivedResponseMillis = cacheResponse.receivedResponseAtMillis</span><br><span class="line">        <span class="keyword">val</span> headers = cacheResponse.headers</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until headers.size) &#123;</span><br><span class="line">          <span class="keyword">val</span> fieldName = headers.name(i)</span><br><span class="line">          <span class="keyword">val</span> value = headers.value(i)</span><br><span class="line">          <span class="keyword">when</span> &#123;</span><br><span class="line">            fieldName.equals(<span class="string">&quot;Date&quot;</span>, ignoreCase = <span class="literal">true</span>) -&gt; &#123;</span><br><span class="line">              servedDate = value.toHttpDateOrNull()</span><br><span class="line">              servedDateString = value</span><br><span class="line">            &#125;</span><br><span class="line">            fieldName.equals(<span class="string">&quot;Expires&quot;</span>, ignoreCase = <span class="literal">true</span>) -&gt; &#123;</span><br><span class="line">              expires = value.toHttpDateOrNull()</span><br><span class="line">            &#125;</span><br><span class="line">            fieldName.equals(<span class="string">&quot;Last-Modified&quot;</span>, ignoreCase = <span class="literal">true</span>) -&gt; &#123;</span><br><span class="line">              lastModified = value.toHttpDateOrNull()</span><br><span class="line">              lastModifiedString = value</span><br><span class="line">            &#125;</span><br><span class="line">            fieldName.equals(<span class="string">&quot;ETag&quot;</span>, ignoreCase = <span class="literal">true</span>) -&gt; &#123;</span><br><span class="line">              etag = value</span><br><span class="line">            &#125;</span><br><span class="line">            fieldName.equals(<span class="string">&quot;Age&quot;</span>, ignoreCase = <span class="literal">true</span>) -&gt; &#123;</span><br><span class="line">              ageSeconds = value.toNonNegativeInt(-<span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>computeCandidate()</code> 是计算缓存策略的核心逻辑</p>
<p><code>Cache-Controller: only-if-cached</code> 只能用缓存，条件请求不为空，则直接返回 null。 </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">compute</span><span class="params">()</span></span>: CacheStrategy &#123;</span><br><span class="line">    <span class="keyword">val</span> candidate: CacheStrategy = computeCandidate()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We&#x27;re forbidden from using the network and the cache is insufficient.</span></span><br><span class="line">    <span class="keyword">if</span> (candidate.networkRequest != <span class="literal">null</span> &amp;&amp; request.cacheControl.onlyIfCached) &#123;</span><br><span class="line">        <span class="keyword">return</span> CacheStrategy(<span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> candidate</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CacheStrategy-处理缓存"><a href="#CacheStrategy-处理缓存" class="headerlink" title="CacheStrategy 处理缓存"></a>CacheStrategy 处理缓存</h2><p>主要看 <code>compute()</code> 里面处理逻辑，分为好几块。</p>
<h3 id="是否可以缓存"><a href="#是否可以缓存" class="headerlink" title="是否可以缓存"></a>是否可以缓存</h3><ol>
<li>判断 response code 是否符合条件</li>
<li>请求头是否有 Cache-Controller:max-age、private、public 和 Expires:value，没有直接当不需要缓存。<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isCacheable(cacheResponse, request)) &#123;</span><br><span class="line">    <span class="keyword">return</span> CacheStrategy(request, <span class="literal">null</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="判断是否有条件请求"><a href="#判断是否有条件请求" class="headerlink" title="判断是否有条件请求"></a>判断是否有条件请求</h3><ol>
<li>如果缓存的 request 是条件请求，那么下次</li>
<li>Cache-Control:no-cache，表示没有任何缓存。<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> requestCaching = request.cacheControl</span><br><span class="line"><span class="keyword">if</span> (requestCaching.noCache || hasConditions(request)) &#123;</span><br><span class="line">    <span class="keyword">return</span> CacheStrategy(request, <span class="literal">null</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>如果没有条件请求头，但是缓存的响应头有条件请求的参数，根据请求参数生成条件请求头。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> conditionName: String</span><br><span class="line"><span class="keyword">val</span> conditionValue: String?</span><br><span class="line"><span class="keyword">when</span> &#123;</span><br><span class="line">  etag != <span class="literal">null</span> -&gt; &#123;</span><br><span class="line">    conditionName = <span class="string">&quot;If-None-Match&quot;</span></span><br><span class="line">    conditionValue = etag</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  lastModified != <span class="literal">null</span> -&gt; &#123;</span><br><span class="line">    conditionName = <span class="string">&quot;If-Modified-Since&quot;</span></span><br><span class="line">    conditionValue = lastModifiedString</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  servedDate != <span class="literal">null</span> -&gt; &#123;</span><br><span class="line">    conditionName = <span class="string">&quot;If-Modified-Since&quot;</span></span><br><span class="line">    conditionValue = servedDateString</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> -&gt; <span class="keyword">return</span> CacheStrategy(request, <span class="literal">null</span>) <span class="comment">// No condition! Make a regular request.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="根据资源保质期和缓存时间"><a href="#根据资源保质期和缓存时间" class="headerlink" title="根据资源保质期和缓存时间"></a>根据资源保质期和缓存时间</h3><h4 id="资源缓存时间"><a href="#资源缓存时间" class="headerlink" title="资源缓存时间"></a>资源缓存时间</h4><p>ageMillis 表示资源已经缓存的时间，分成 3 部分，3 者相加即为资源缓存时间，因为资源可能在缓存服务器上或者 age&#x3D;null &amp;&amp; data &#x3D; null，导致 receivedAge 为空。<br>虽然当 receivedAge 不为 0 时，前两点可能时间重合，但是为了防止用了过期的资源，这样计算最保险。</p>
<ul>
<li>receivedAge，资源运输过程的损耗时间。</li>
<li>responseDuration，客户端请求响应时间，一个 RTT。</li>
<li>residentDuration，资源本地缓存时间。</li>
</ul>
<h4 id="资源保质期"><a href="#资源保质期" class="headerlink" title="资源保质期"></a>资源保质期</h4><p>freshMillis 保质期时间，服务端可能提供多个保质期，根据优先级，保质期计算公式主要是前两点。</p>
<ul>
<li>Cache-Controller 的 mag-age 优先级最高，返回值就是保质期。</li>
<li>Expires 过期时间，当前时间 - Expires，计算得出保质期。</li>
<li>Last-Modified， 如果资源的最后修改时间确定且没有查询参数，资源到达客户端时间 - 最后修改时间 的 10% 作为保质期。</li>
</ul>
<h4 id="minFreshMillis"><a href="#minFreshMillis" class="headerlink" title="minFreshMillis"></a>minFreshMillis</h4><p>Cache-Controller 的 min-fresh，最小新鲜时间，即保质期时间提前了多久了。</p>
<h4 id="maxStaleMillis"><a href="#maxStaleMillis" class="headerlink" title="maxStaleMillis"></a>maxStaleMillis</h4><p>Cache-Controller 的 max-stale 最大过期时间，即保质期时间延长多久。</p>
<p>最终计算方法 缓存时间 &lt; 保质期 即可以使用缓存<br>ageMillis &lt; freshMillis + maxStaleMillis - minFreshMillis</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> responseCaching = cacheResponse.cacheControl</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> ageMillis = cacheResponseAge()</span><br><span class="line"><span class="keyword">var</span> freshMillis = computeFreshnessLifetime()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (requestCaching.maxAgeSeconds != -<span class="number">1</span>) &#123;</span><br><span class="line">  freshMillis = minOf(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds.toLong()))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> minFreshMillis: <span class="built_in">Long</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> (requestCaching.minFreshSeconds != -<span class="number">1</span>) &#123;</span><br><span class="line">  minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds.toLong())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> maxStaleMillis: <span class="built_in">Long</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> (!responseCaching.mustRevalidate &amp;&amp; requestCaching.maxStaleSeconds != -<span class="number">1</span>) &#123;</span><br><span class="line">  maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds.toLong())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!responseCaching.noCache &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123;</span><br><span class="line">  <span class="keyword">val</span> builder = cacheResponse.newBuilder()</span><br><span class="line">  <span class="keyword">if</span> (ageMillis + minFreshMillis &gt;= freshMillis) &#123;</span><br><span class="line">    builder.addHeader(<span class="string">&quot;Warning&quot;</span>, <span class="string">&quot;110 HttpURLConnection \&quot;Response is stale\&quot;&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">val</span> oneDayMillis = <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span></span><br><span class="line">  <span class="keyword">if</span> (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123;</span><br><span class="line">    builder.addHeader(<span class="string">&quot;Warning&quot;</span>, <span class="string">&quot;113 HttpURLConnection \&quot;Heuristic expiration\&quot;&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> CacheStrategy(<span class="literal">null</span>, builder.build())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="响应缓存"><a href="#响应缓存" class="headerlink" title="响应缓存"></a>响应缓存</h2><p>如果条件请求，服务端返回 304 表示资源为修改，则可以直接使用缓存响应。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (networkResponse?.code == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">    <span class="keyword">val</span> response = cacheResponse.newBuilder()</span><br><span class="line">        .headers(combine(cacheResponse.headers, networkResponse.headers))</span><br><span class="line">        .sentRequestAtMillis(networkResponse.sentRequestAtMillis)</span><br><span class="line">        .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis)</span><br><span class="line">        .cacheResponse(cacheResponse.stripBody())</span><br><span class="line">        .networkResponse(networkResponse.stripBody())</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    networkResponse.body.close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update the cache after combining headers but before stripping the</span></span><br><span class="line">    <span class="comment">// Content-Encoding header (as performed by initContentStream()).</span></span><br><span class="line">    cache!!.trackConditionalCacheHit()</span><br><span class="line">    cache.update(cacheResponse, response)</span><br><span class="line">    <span class="keyword">return</span> response.also &#123;</span><br><span class="line">      listener.cacheHit(call, it)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cacheResponse.body.closeQuietly()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>响应满足缓存条件，则添加到缓存中。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (response.promisesBody() &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">    <span class="comment">// Offer this request to the cache.</span></span><br><span class="line">    <span class="keyword">val</span> cacheRequest = cache.put(response)</span><br><span class="line">    <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response).also &#123;</span><br><span class="line">      <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// This will log a conditional cache miss only.</span></span><br><span class="line">        listener.cacheMiss(call)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      cache.remove(networkRequest)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (_: IOException) &#123;</span><br><span class="line">      <span class="comment">// The cache cannot be written.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/09/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/okhttp%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/09/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/okhttp%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">okhttp介绍</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-09-09 15:38:16" itemprop="dateCreated datePublished" datetime="2023-09-09T15:38:16+00:00">2023-09-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-09-11 11:02:55" itemprop="dateModified" datetime="2023-09-11T11:02:55+00:00">2023-09-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <meta name="referrer" content="no-referrer" />
# OkHttp源码分析

<p>OkHttp是一个高效的客户端 Http 请求框架，OkHttp 是对 HTTP 协议的实现，在Android客户端开发被广泛使用。</p>
<blockquote>
<p>支持Http1、Http2、Quic以及WebSocket</p>
<p>连接池复用底层TCP(Socket)，减少请求延时</p>
<p>无缝的支持GZIP减少数据流量</p>
<p>缓存响应数据减少重复的网络请求</p>
<p>请求失败自动重试主机的其他ip，自动重定向</p>
</blockquote>
<p>学习OKhttp源码就要先看全局，然后根据使用需要再研究细节，体会其精妙之处。<br>了解它的原理，并加以实践，可以实现一个简单的HTTP请求客户端。</p>
<h1 id="OkHttp-的使用"><a href="#OkHttp-的使用" class="headerlink" title="OkHttp 的使用"></a>OkHttp 的使用</h1><p>OkHttpClient是 HTTP 协议中的<strong>请求方</strong>，使用 HTTP 协议获取网络上的各种资源，简单称为客户端，角色和浏览器一样。</p>
<p>OkHttpClient 中包含了各种组件，通过组合使用，实现HTTP请求。</p>
<p>Request 是OkHttp 的请求实体，可以封装各种请求参数。</p>
<p>通过<code>OkHttpClient.newCall()</code>创建出一个网络请求执行器<code>call</code>，有两种请求方式：</p>
<ul>
<li>调用<code>enqueue(callback)</code>实现异步请求，通过子线程请求，当请求完成，将响应结果通过回调函数传递。</li>
<li>调用<code>execute()</code> 实现同步请求，堵塞当前线程，直到请求完成，返回响应结果。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> client = OkHttpClient.Builder().build()</span><br><span class="line"><span class="comment">// 构建请求    </span></span><br><span class="line"><span class="keyword">val</span> request = Request.Builder()</span><br><span class="line">    .url(<span class="string">&quot;https://baidu.com&quot;</span>)</span><br><span class="line">    .build()</span><br><span class="line"><span class="comment">// 网络请求执行器    </span></span><br><span class="line"><span class="keyword">val</span> realCall = client.newCall(request)</span><br><span class="line"><span class="comment">// 执行异步请求    </span></span><br><span class="line"><span class="keyword">val</span> asyncResponse = realCall.enqueue(<span class="keyword">object</span> : Callback &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>, e: <span class="type">IOException</span>)</span></span> &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;okhttp&quot;</span>, <span class="string">&quot;请求失败&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>, response: <span class="type">Response</span>)</span></span> &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;okhttp&quot;</span>, <span class="string">&quot;请求成功&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 执行同步请求</span></span><br><span class="line"><span class="keyword">val</span> syncResponse = realCall.excute()   </span><br></pre></td></tr></table></figure>


<h2 id="OkHttpClient-组件介绍"><a href="#OkHttpClient-组件介绍" class="headerlink" title="OkHttpClient 组件介绍"></a>OkHttpClient 组件介绍</h2><p>要想了解OkHttp 如何实现 HTTP 协议完成网络请求之前，就先要了解 OkHttpClient 中的组件。</p>
<p>两大核心组件是： <strong>Dispatcher(分发器）和 Interceptor(拦截器)</strong> ，这两个着重介绍，它们和OkHttp请求流程息息相关，下面先看看其他组件。</p>
<h3 id="ConnectionPool-连接池"><a href="#ConnectionPool-连接池" class="headerlink" title="ConnectionPool(连接池)"></a>ConnectionPool(连接池)</h3><p>连接池和线程池类似，批量管理 TCP 连接，通过重用和自动回收，实现性能和资源占用的动态平衡。</p>
<p>TCP连接使用完成后不会被直接销毁，而是重新放回到连接池中，等待下次 HTTP 请求使用。</p>
<p>同时连接池中会制定规则，自动回收无用的连接，释放资源。如此就实现了连接的复用，防止一有HTTP请求就重新创建新的连接。</p>
<h3 id="EventListenerFactory-事件监听器工厂"><a href="#EventListenerFactory-事件监听器工厂" class="headerlink" title="EventListenerFactory(事件监听器工厂)"></a>EventListenerFactory(事件监听器工厂)</h3><p>对如连接事件，域名解析成功事件等设置监听器。</p>
<h3 id="retryOnConnectionFailure"><a href="#retryOnConnectionFailure" class="headerlink" title="retryOnConnectionFailure"></a>retryOnConnectionFailure</h3><p>这是一个bool值，当连接、请求失败时，OkHttp是否重试，默认为true。注意请求失败，比如返回状态码500等，不符合重试条件。<br>需要是「同一个域名的多个IP重试」，「Socket连接失败」。</p>
<h3 id="Authenticator-认证器"><a href="#Authenticator-认证器" class="headerlink" title="Authenticator(认证器)"></a>Authenticator(认证器)</h3><p>用于自动重新认证，配置之后当请求收到 401 未授权的状态码后，会直接调用 <code>authenticator</code> ，手动加入请求头字段<code>Authenticator</code>，重新发起请求。</p>
<p>比如当token 过期时，可以配置 <code>authenticator</code> 重新获取新的token，添加到请求头中，再次发起请求。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> client = OkHttpClient.Builder()</span><br><span class="line">    .authenticator(Authenticator &#123; route, response -&gt;</span><br><span class="line">        <span class="keyword">val</span> request = response.request</span><br><span class="line">        <span class="comment">// TODO 重新请求服务器新的token</span></span><br><span class="line">        <span class="keyword">val</span> newToken = requestToken()</span><br><span class="line">        request.newBuilder()</span><br><span class="line">            .addHeader(<span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;Bearer <span class="subst">$&#123;newToken&#125;</span>&quot;</span>)</span><br><span class="line">            .build()</span><br><span class="line">    &#125;)</span><br><span class="line">    .build()</span><br></pre></td></tr></table></figure>



<h3 id="followRedirects-和-followSslRedirects"><a href="#followRedirects-和-followSslRedirects" class="headerlink" title="followRedirects 和 followSslRedirects"></a>followRedirects 和 followSslRedirects</h3><p>这两个都是bool值。</p>
<p>followRedirects，表示是否重定向，跳转到 301 返回的 location url，默认为true。</p>
<p>followSslRedirects，在上面 followRedirects 为true 的基础上，当协议发生切换时，是否依然需要重定向，默认为true。</p>
<p>比如请求的网址是<code>http://baidu.com</code>，重定向需要跳转的网址为<code>https:baidu.com</code>，由http协议变成了https协议。</p>
<h3 id="CookieJar-Cookie管理器"><a href="#CookieJar-Cookie管理器" class="headerlink" title="CookieJar(Cookie管理器)"></a>CookieJar(Cookie管理器)</h3><p>OkHttp 提供了 Cookie 的存取管理类，但和浏览器不同，<code>CookieJar</code> 中没有实现存取的逻辑（什么时候存Cookie，什么时候取Cookie，需要自己实现）。</p>
<p>在OkHttp 中CookieJar的默认实现为<code>NoCookies</code>，里面什么也没有，返回的也是空List，不像浏览器会自动存储请求响应的Cookie。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> NO_COOKIES: CookieJar = NoCookies()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">NoCookies</span> : <span class="type">CookieJar</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">saveFromResponse</span><span class="params">(url: <span class="type">HttpUrl</span>, cookies: <span class="type">List</span>&lt;<span class="type">Cookie</span>&gt;)</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadForRequest</span><span class="params">(url: <span class="type">HttpUrl</span>)</span></span>: List&lt;Cookie&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> emptyList()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以如果需要管理Cookie，需要在OkHttpClient 中配置，并且实现一个CookieJar，编写条件，可以用<code>Map</code>保存在内存中，用<code>SharedPreferences</code>保存在文件中。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> client = OkHttpClient.Builder()</span><br><span class="line">    .cookieJar(<span class="keyword">object</span> : CookieJar &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadForRequest</span><span class="params">(url: <span class="type">HttpUrl</span>)</span></span>: List&lt;Cookie&gt; &#123;</span><br><span class="line">            <span class="comment">// 返回Cookie的逻辑</span></span><br><span class="line">            <span class="keyword">return</span> map.<span class="keyword">get</span>(url)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">saveFromResponse</span><span class="params">(url: <span class="type">HttpUrl</span>, cookies: <span class="type">List</span>&lt;<span class="type">Cookie</span>&gt;)</span></span> &#123;</span><br><span class="line">            <span class="comment">// TODO 存取Cookie的逻辑</span></span><br><span class="line">            map.put(url, cookies)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).build()</span><br></pre></td></tr></table></figure>


<h3 id="Cache-缓存管理配置"><a href="#Cache-缓存管理配置" class="headerlink" title="Cache(缓存管理配置)"></a>Cache(缓存管理配置)</h3><p>缓存用于保存服务器的响应结果，下次相同请求时可以直接使用。Cache，默认是空实现，需要自己配置Cache存储的文件位置和存储空间上限。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val client = OkHttpClient.Builder()</span><br><span class="line">    .cache(Cache(File(Environment.getDownloadCacheDirectory(), &quot;cache&quot;), 100*1024*1024))</span><br><span class="line">    .build()</span><br></pre></td></tr></table></figure>


<h3 id="Dns"><a href="#Dns" class="headerlink" title="Dns"></a>Dns</h3><p>Dns负责将主机名解析成IP地址，默认使用JDK中的<code>InetAddress.getAllByName(hostname).toList()</code>。</p>
<h3 id="Proxy-代理"><a href="#Proxy-代理" class="headerlink" title="Proxy(代理)"></a>Proxy(代理)</h3><p>表示请求代理设置，有三种类型</p>
<ul>
<li><code>DIRECT</code>,直连模式，直接和目标服务器通信，中间没有代理服务器</li>
<li><code>HTTP</code>, 代理模式，客户端请求代理服务器，代理服务器HTTP协议转发HTTP数据包给目标服务器。</li>
<li><code>SOCKS</code>，代理模式，通过Socks服务器和目标服务器通信，Socks代理只是简单地转发数据包(传输层)，而不必关心是何种应用协议（比如FTP、HTTP和NNTP请求）。</li>
</ul>
<h3 id="PoxySelector-代理选择器"><a href="#PoxySelector-代理选择器" class="headerlink" title="PoxySelector(代理选择器)"></a>PoxySelector(代理选择器)</h3><p>代理选择器，根据你要连接的URL自动选择最合适的代理。如果需要编写定制代理选择器，需要继承并实现<code>select</code>方法。</p>
<p>默认实现为<code>NullProxySelector</code>，默认返回直连模式，即不使用代理。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NullProxySelector</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">select</span><span class="params">(uri: <span class="type">URI</span>?)</span></span>: List&lt;Proxy&gt; &#123;</span><br><span class="line">    requireNotNull(uri) &#123; <span class="string">&quot;uri must not be null&quot;</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> listOf(Proxy.NO_PROXY)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Proxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> static Proxy NO_PROXY = new Proxy();</span><br><span class="line"><span class="comment">// Creates the proxy that represents a &#123;@code DIRECT&#125; connection.</span></span><br><span class="line"><span class="keyword">private</span> Proxy() &#123;</span><br><span class="line">    type = Type.DIRECT</span><br><span class="line">    sa = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="ProxyAuthenticator-代理认证器"><a href="#ProxyAuthenticator-代理认证器" class="headerlink" title="ProxyAuthenticator(代理认证器)"></a>ProxyAuthenticator(代理认证器)</h3><p>和上面的<code>authenticator</code>类似，针对代理服务器做授权处理。</p>
<h3 id="SocketFactory-和-SSLSocketFactory"><a href="#SocketFactory-和-SSLSocketFactory" class="headerlink" title="SocketFactory 和 SSLSocketFactory"></a>SocketFactory 和 SSLSocketFactory</h3><p>Socket连接工程，当需要TCP连接建立时，提供Socket服务。</p>
<p>SSLSocketFactory针对HTTPS 请求，在TCP连接基础上再建立一个TLS连接，提供SSLSocket</p>
<h3 id="X509TrustManager-证书验证器"><a href="#X509TrustManager-证书验证器" class="headerlink" title="X509TrustManager(证书验证器)"></a>X509TrustManager(证书验证器)</h3><p>X509表示证书格式，当建立HTTPS连接时，需要验证服务端证书签名，证书签发机构证书签名，根证书签名，这些工作都是由 X509TrustManager 完成。</p>
<h3 id="ConnectionSpecs-TLS连接配置"><a href="#ConnectionSpecs-TLS连接配置" class="headerlink" title="ConnectionSpecs(TLS连接配置)"></a>ConnectionSpecs(TLS连接配置)</h3><p>Https 建立连接时，客户端需要发送支持的TLS版本协议 和 对称加密、非对称加密、摘要(hash)算法套件。</p>
<p>默认使用<code>MODERN_TLS</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">val MODERN_TLS = Builder(true)</span><br><span class="line">    .cipherSuites(*APPROVED_CIPHER_SUITES)</span><br><span class="line">    .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2)</span><br><span class="line">    .supportsTlsExtensions(true)</span><br><span class="line">    .build()</span><br><span class="line">    </span><br><span class="line">// 明文，不加密    </span><br><span class="line">val CLEARTEXT = Builder(false).build()    </span><br></pre></td></tr></table></figure>



<h3 id="Protocols-HTTP协议管理"><a href="#Protocols-HTTP协议管理" class="headerlink" title="Protocols(HTTP协议管理)"></a>Protocols(HTTP协议管理)</h3><p>http协议版本管理，如HTTP&#x2F;1.0、HTTP&#x2F;1.1、HTTP&#x2F;2等</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP_1_0(&quot;http/1.0&quot;),</span><br><span class="line">HTTP_1_1(&quot;http/1.1&quot;),</span><br><span class="line">HTTP_2(&quot;h2&quot;),</span><br><span class="line">H2_PRIOR_KNOWLEDGE(&quot;h2_prior_knowledge&quot;),</span><br><span class="line">QUIC(&quot;quic&quot;);</span><br></pre></td></tr></table></figure>



<h3 id="HostnameVerifier-主机名验证器"><a href="#HostnameVerifier-主机名验证器" class="headerlink" title="HostnameVerifier(主机名验证器)"></a>HostnameVerifier(主机名验证器)</h3><p>用于验证HTTPS 握手中服务端证书中的主机名 是否和 客户端请求的主机一致。</p>
<h3 id="CertificatePinner-证书固定验证"><a href="#CertificatePinner-证书固定验证" class="headerlink" title="CertificatePinner(证书固定验证)"></a>CertificatePinner(证书固定验证)</h3><p>用于设置HTTPS 握手过程中针对某个在Host 额外的 Certificate Public Key Pinner，即把网站证书链中的每一个证书公钥直接拿来提前配置进 OkHttpClient 里去、作为正常证书验证机制外的一次额外验证，一般不使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">hostname</span> <span class="operator">=</span> <span class="string">&quot;publicobject.com&quot;</span>;</span><br><span class="line"><span class="type">CertificatePinner</span> <span class="variable">certificatePinner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CertificatePinner</span>.Builder()</span><br><span class="line">    .add(hostname, <span class="string">&quot;sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;</span>)</span><br><span class="line">    .build();</span><br><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> OkHttpClient.Builder()</span><br><span class="line">    .certificatePinner(certificatePinner)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>



<h3 id="CertificateChainCleaner-验证操作员"><a href="#CertificateChainCleaner-验证操作员" class="headerlink" title="CertificateChainCleaner(验证操作员)"></a>CertificateChainCleaner(验证操作员)</h3><p>使用X509TrustManager 验证整个服务端证书链。</p>
<h3 id="TimeOut超时时间"><a href="#TimeOut超时时间" class="headerlink" title="TimeOut超时时间"></a>TimeOut超时时间</h3><p>connectTimeout：建立连接(TCL 或 TLS) 的超时时间。</p>
<p>readTimeout：发起请求到读 到响应数据的超时时间。</p>
<p>writeTimeout：发起请求并被目标服务器接受的超时时间。有时候对方服务器可能由于某种原因不读取你的Request。</p>
<h1 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h1><p>整个OkHttp 请求主流程 靠分发器 和 拦截器 ，其他组件配合两者。</p>
<p>分发器Dispatcher：负责调配请求任务，内部包含一个线程池执行请求任务，对总请求数和单主机请求数有限制。</p>
<h2 id="一、请求任务分配"><a href="#一、请求任务分配" class="headerlink" title="一、请求任务分配"></a>一、请求任务分配</h2><p><code>okClient.newCall(request)</code> 返回的是 <code>RealCall</code> 类型。下面调用<code>realCall.enqueue(callback)</code>。</p>
<p><code>client.dispatcher</code> 就是分发器<code>Dispatcher</code>，将异步任务<code>AsyncCall</code>交给分发器。</p>
<p><code>AsyncCall</code>继承自<code>RealCall</code>，RealCall是整个网络请求执行器，相当于大管家，管理请求相关的参数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealCall</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(responseCallback: <span class="type">Callback</span>)</span></span> &#123;</span><br><span class="line">  check(executed.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123; <span class="string">&quot;Already Executed&quot;</span> &#125;</span><br><span class="line">  callStart()</span><br><span class="line">  <span class="comment">// Dispatcher.enqueue   </span></span><br><span class="line">  client.dispatcher.enqueue(AsyncCall(responseCallback))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异步请求执行器会先加入到等待执行队列中。<br><code>findExistingCallWithHost()</code> 判断相同域名下，队列是否存在队列请求调用 <code>AsynCall</code>。<br>如果有相同请求执行<code>call.reuseCallsPerHostFrom(existingCall)</code>，同步 <code>callsPerHost</code> 统一主机并发请求次数。 </p>
<p><code>promoteAndExecute</code> 就是从队列中推举并执行请求。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatcher</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有异步请求最多 64 个</span></span><br><span class="line"><span class="keyword">var</span> maxRequests = <span class="number">64</span></span><br><span class="line"><span class="comment">// 相同域名下，最多5个异步请求</span></span><br><span class="line"><span class="keyword">var</span> maxRequestsPerHost = <span class="number">5</span></span><br><span class="line"><span class="comment">// 异步请求等待执行队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> readyAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()</span><br><span class="line"><span class="comment">// 异步请求正在等待执行队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> runningAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()</span><br><span class="line"><span class="comment">// 同步请求正在执行队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> runningSyncCalls = ArrayDeque&lt;RealCall&gt;()</span><br><span class="line"><span class="comment">// 异步请求使用的线程池    </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> executorServiceOrNull: ExecutorService? = <span class="literal">null</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(call: <span class="type">AsyncCall</span>)</span></span> &#123;</span><br><span class="line">  synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">// 先加入到等待执行队列中  </span></span><br><span class="line">    readyAsyncCalls.add(call)</span><br><span class="line">	<span class="comment">// 如果相同域名下的call，callsPerHost会直接被赋值成队列中已有 Call 的callsPerHost</span></span><br><span class="line">    <span class="keyword">if</span> (!call.call.forWebSocket) &#123;</span><br><span class="line">      <span class="keyword">val</span> existingCall = findExistingCallWithHost(call.host)</span><br><span class="line">      <span class="keyword">if</span> (existingCall != <span class="literal">null</span>) call.reuseCallsPerHostFrom(existingCall)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  promoteAndExecute()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">reuseCallsPerHostFrom</span><span class="params">(other: <span class="type">AsyncCall</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.callsPerHost = other.callsPerHost</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>promoteAndExecute()</code>，遍历等待执行队列中，推举出符合要求的 Call，需要满足两个条件才能执行：</p>
<ul>
<li><strong>正在执行队列已有异步请求数量不能超过 64 个。</strong></li>
<li><strong>正在执行队列中相同域名下，<code>callsPerHost</code> 同一主机并发请求数不能超过 5 个，防止服务器资源扛不住，Http 连接管理中对此进行了说明。</strong></li>
</ul>
<p>相同域名下的Call中<code>callsPerHost</code>在上一步都会同步为相同对象，所以当<code>callsPerHost.incrementAndGet()</code>，相同域名下的其他Call 也会 + 1。<br>即使相同域名下建立了多个 Call 请求对象，对相同域名的并发请求数是同步的。<br>想要绕过相同域名连接数限制，只能使用域名分片。</p>
<p>如果都符合条件，</p>
<ul>
<li>加入到<code>executableCalls</code>临时执行队列，<code>promoteAndExecute()</code>执行后队列销毁。</li>
<li><code>runningAsyncCalls</code>正在执行队列中，只要请求没有结束不会被移除。</li>
</ul>
<p>如果线程池被被关闭则移除且不执行所有队列中所有请求。<br>连接整成，遍历<code>executableCalls</code> 执行队列，调用<code>asyncCall.executeOn(executorService)</code> 使用线程池执行请求。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatcher</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">promoteAndExecute</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.assertThreadDoesntHoldLock()</span><br><span class="line">  <span class="comment">// 可执行异步请求容器    </span></span><br><span class="line">  <span class="keyword">val</span> executableCalls = mutableListOf&lt;AsyncCall&gt;()</span><br><span class="line">  <span class="keyword">val</span> isRunning: <span class="built_in">Boolean</span></span><br><span class="line">  synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> i = readyAsyncCalls.iterator()</span><br><span class="line">    <span class="comment">// 遍历等待队列    </span></span><br><span class="line">    <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">      <span class="keyword">val</span> asyncCall = i.next()</span><br><span class="line">      <span class="comment">// 超过异步请求数 64 直接不执行。 </span></span><br><span class="line">      <span class="keyword">if</span> (runningAsyncCalls.size &gt;= <span class="keyword">this</span>.maxRequests) <span class="keyword">break</span> <span class="comment">// Max capacity.</span></span><br><span class="line">      <span class="comment">// 超过相同域名并发请求数，当前不执行，可以执行其他域名的 call</span></span><br><span class="line">      <span class="keyword">if</span> (asyncCall.callsPerHost.<span class="keyword">get</span>() &gt;= <span class="keyword">this</span>.maxRequestsPerHost) <span class="keyword">continue</span> <span class="comment">// Host max capacity.</span></span><br><span class="line">      i.remove()</span><br><span class="line">      <span class="comment">// 并发请求次数+1    </span></span><br><span class="line">      asyncCall.callsPerHost.incrementAndGet()</span><br><span class="line">      <span class="comment">// 添加到执行队列中</span></span><br><span class="line">      executableCalls.add(asyncCall)</span><br><span class="line">      <span class="comment">// 添加到正在执行队列中</span></span><br><span class="line">      runningAsyncCalls.add(asyncCall)</span><br><span class="line">    &#125;</span><br><span class="line">    isRunning = runningCallsCount() &gt; <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (executorService.isShutdown) &#123;</span><br><span class="line">     <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until executableCalls.size) &#123;</span><br><span class="line">        <span class="keyword">val</span> asyncCall = executableCalls[i]</span><br><span class="line">        asyncCall.callsPerHost.decrementAndGet()</span><br><span class="line"></span><br><span class="line">        synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">           runningAsyncCalls.remove(asyncCall)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">           asyncCall.failRejected()</span><br><span class="line">        &#125;</span><br><span class="line">     idleCallback?.run()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until executableCalls.size) &#123;</span><br><span class="line">          <span class="keyword">val</span> asyncCall = executableCalls[i]</span><br><span class="line">          asyncCall.executeOn(executorService)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isRunning</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>executorService</code> 配置线程池参数如下:</p>
<ul>
<li>核心线程数 0: 当没有任务执行时，线程池中没有任何线程资源，最大程度地减少系统资源的占用。</li>
<li>最大线程数为 MAX_VALUE: 这样线程池可以处理任意数量的任务，保证了高并发。</li>
<li>工作队列 SynchronousQueue: 该队列没有存储空间，所有有任务会执行创建线程，保证高并发。</li>
<li>存活时间为 60s: 线程空间超过 60s 就会被销毁，节约资源。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispather</span></span><br><span class="line"><span class="keyword">val</span> executorService: ExecutorService</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (executorServiceOrNull == <span class="literal">null</span>) &#123;</span><br><span class="line">            executorServiceOrNull = ThreadPoolExecutor(<span class="number">0</span>, <span class="built_in">Int</span>.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">                SynchronousQueue(), threadFactory(<span class="string">&quot;<span class="variable">$okHttpName</span> Dispatcher&quot;</span>, <span class="literal">false</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> executorServiceOrNull!!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程池会执行 RealCall 请求。因为RealCall，默认实现了<code>Runnable</code>接口，会执行它的<code>run</code>方法。<br>另外当执行失败时，会调用<code>Dispatcher.finished</code>方法结尾。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealCall</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">executeOn</span><span class="params">(executorService: <span class="type">ExecutorService</span>)</span></span> &#123;</span><br><span class="line">    client.dispatcher.assertThreadDoesntHoldLock()</span><br><span class="line">        <span class="keyword">var</span> success = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行请求，this表示Runnable</span></span><br><span class="line">            executorService.execute(<span class="keyword">this</span>)</span><br><span class="line">            success = <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: RejectedExecutionException) &#123;</span><br><span class="line">            <span class="keyword">val</span> ioException = InterruptedIOException(<span class="string">&quot;executor rejected&quot;</span>)</span><br><span class="line">            ioException.initCause(e)</span><br><span class="line">            noMoreExchanges(ioException)</span><br><span class="line">            responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, ioException)</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!success) &#123; </span><br><span class="line">                <span class="comment">// 请求执行失败</span></span><br><span class="line">                client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>getResponseWithInterceptorChain()</code>发起请求，获取响应结果，返回给调用层。</p>
<p>当执行成功结束后，也会调用<code>Dispatcher.finished</code>方法结尾。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealCall</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">  threadName(<span class="string">&quot;OkHttp <span class="subst">$&#123;redactedUrl()&#125;</span>&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> signalledCallback = <span class="literal">false</span></span><br><span class="line">    timeout.enter()</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">val</span> response = getResponseWithInterceptorChain()</span><br><span class="line">      signalledCallback = <span class="literal">true</span></span><br><span class="line">      responseCallback.onResponse(<span class="keyword">this</span><span class="symbol">@RealCall</span>, response)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125; <span class="keyword">catch</span> (t: Throwable) &#123;</span><br><span class="line">      cancel()</span><br><span class="line">      ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 请求成功完成  </span></span><br><span class="line">      client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>finished()</code>方法中，当一个请求执行结束后，调用<code>promoteAndExecute()</code> 执行等待队列中的下一个请求任务，并且将域名下的并发请求数 -1.</p>
<p>如果等待队列中无任务可以执行，则能利用线程池执行其他任务。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">finished</span><span class="params">(call: <span class="type">AsyncCall</span>)</span></span> &#123;</span><br><span class="line">  call.callsPerHost.decrementAndGet()</span><br><span class="line">  finished(runningAsyncCalls, call)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">finished</span><span class="params">(calls: <span class="type">Deque</span>&lt;<span class="type">T</span>&gt;, call: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> idleCallback: Runnable?</span><br><span class="line">  synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> AssertionError(<span class="string">&quot;Call wasn&#x27;t in-flight!&quot;</span>)</span><br><span class="line">    idleCallback = <span class="keyword">this</span>.idleCallback</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行队列中的下个Call  </span></span><br><span class="line">  <span class="keyword">val</span> isRunning = promoteAndExecute()</span><br><span class="line">  <span class="comment">// 如果线程池空调可以先执行其他任务    </span></span><br><span class="line">  <span class="keyword">if</span> (!isRunning &amp;&amp; idleCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">    idleCallback.run()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、拦截器责任链"><a href="#二、拦截器责任链" class="headerlink" title="二、拦截器责任链"></a>二、拦截器责任链</h2><p>OkHttp 的核心工作是在 <code>getResponseWithInterceptorChain()</code> 中完成。</p>
<p>前部分将自定义的拦截器和 OkHttp 提供的拦截器依次添加到拦截器容器中。</p>
<p>创建 <code>RealInterceptorChain</code> 责任链对象<code>chain</code>，调用<code>chain.proceed(originalRequest)</code>，传入外部构建的<code>request</code>对象，启动责任链。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealCall</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">  <span class="comment">// 创建拦截器容器.</span></span><br><span class="line">  <span class="keyword">val</span> interceptors = mutableListOf&lt;Interceptor&gt;()</span><br><span class="line">  <span class="comment">// 把拦截器添加到容器中</span></span><br><span class="line">  interceptors += client.interceptors</span><br><span class="line">  interceptors += RetryAndFollowUpInterceptor(client)</span><br><span class="line">  interceptors += BridgeInterceptor(client.cookieJar)</span><br><span class="line">  interceptors += CacheInterceptor(client.cache)</span><br><span class="line">  interceptors += ConnectInterceptor</span><br><span class="line">      </span><br><span class="line">  <span class="comment">// 如果不是websocket，则可以自定义networkInterceptors </span></span><br><span class="line">  <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">    interceptors += client.networkInterceptors</span><br><span class="line">  &#125;</span><br><span class="line">  interceptors += CallServerInterceptor(forWebSocket)</span><br><span class="line">  <span class="comment">// 创建责任链对象	</span></span><br><span class="line">  <span class="keyword">val</span> chain = RealInterceptorChain(</span><br><span class="line">      call = <span class="keyword">this</span>,</span><br><span class="line">      interceptors = interceptors,</span><br><span class="line">      index = <span class="number">0</span>,</span><br><span class="line">      exchange = <span class="literal">null</span>,</span><br><span class="line">      request = originalRequest,</span><br><span class="line">      connectTimeoutMillis = client.connectTimeoutMillis,</span><br><span class="line">      readTimeoutMillis = client.readTimeoutMillis,</span><br><span class="line">      writeTimeoutMillis = client.writeTimeoutMillis</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">var</span> calledNoMoreExchanges = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 启动拦截器责任链，等待结果返回  </span></span><br><span class="line">    <span class="keyword">val</span> response = chain.proceed(originalRequest)</span><br><span class="line">    <span class="keyword">if</span> (isCanceled()) &#123;</span><br><span class="line">      response.closeQuietly()</span><br><span class="line">      <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">    calledNoMoreExchanges = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">throw</span> noMoreExchanges(e) <span class="keyword">as</span> Throwable</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!calledNoMoreExchanges) &#123;</span><br><span class="line">      noMoreExchanges(<span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面调用<code> chain.proceed(originalRequest)</code>，整个拦截器链条是如何运转的？</p>
<p>先拷贝一个<code>RealInterceptorChain</code>，然后index + 1，获取当前index 下的 拦截器，调用<code>intercept()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealInterceptorChain</span></span><br><span class="line"><span class="keyword">private</span> val index: Int    override fun <span class="title function_">proceed</span><span class="params">(request: Request)</span>: Response &#123;   </span><br><span class="line">    ...    </span><br><span class="line">    <span class="type">val</span> <span class="variable">next</span> <span class="operator">=</span> copy(index = index + <span class="number">1</span>, request = request)	</span><br><span class="line">    <span class="type">val</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors[index]    </span><br><span class="line">    <span class="type">val</span> <span class="variable">response</span> <span class="operator">=</span> interceptor.intercept(next) ?: <span class="keyword">throw</span> NullPointerException(<span class="string">&quot;interceptor$interceptor returned null&quot;</span>)      </span><br><span class="line">...    </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>在拦截器的<code>interceptors</code>做了 3 件事情：</p>
<ol>
<li>对请求预处理。</li>
<li>调用<code>chain.proceed()</code>，index已经+1，将请求交给下个拦截器，执行<code>intercept()</code>方法。</li>
<li>最后一个拦截器请求完成后，获取响应结果，返回给上个拦截器处理，直至传递到顶部。</li>
</ol>
<p>整个责任链模式就像工程流水线，各司其职。一个玩具飞机有外壳装配员，引擎装配员，螺旋桨装配员，模型包装员组成。</p>
<p>当玩具流到谁那里，谁就负责安装他负责的这一部分，这部分安装完成后流到下一个环节，直到玩具生产完成。<br><img src="https://upload-images.jianshu.io/upload_images/4538003-00d6440ffa1710e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>下面看看具体每个拦截器的作用，整个拦截器链按照Interceptor添加顺序依次调用<code>intercept()</code>方法。</p>
<h3 id="一次完整网络请求"><a href="#一次完整网络请求" class="headerlink" title="一次完整网络请求"></a>一次完整网络请求</h3><p>在开始之前，我们要知道从客户端将网址输入到浏览器，一次完整的网络请求会发生什么。</p>
<h3 id="1、自定义Interceptor"><a href="#1、自定义Interceptor" class="headerlink" title="1、自定义Interceptor"></a>1、自定义Interceptor</h3><p>先执行开发者调用<code>OkHttpClient.Builder().addInterceptor()</code>添加的自定义拦截器，它在系统拦截器之前工作，进行最早的Request预处理工作，已经最后处理响应结果Response，可以根据需要添加header。</p>
<h3 id="2、重试及重定向拦截器RetryAndFollowUpInterceptor"><a href="#2、重试及重定向拦截器RetryAndFollowUpInterceptor" class="headerlink" title="2、重试及重定向拦截器RetryAndFollowUpInterceptor"></a>2、重试及重定向拦截器RetryAndFollowUpInterceptor</h3><p><strong>它会对连接做⼀些初始化⼯作，并且负责在请求失败时的重试，以及重定向的⾃动后续请求</strong>。它的存在，可以让重试和重定向对于开发者是无感知。</p>
<ol>
<li>前置工作，调用<code>call.enterNetworkInterceptorExchange</code>创建<code>ExChangeFinder</code>。</li>
<li>后置工作是调用<code>recover()</code>重试</li>
<li><code>followUpRequest(response, exchange)</code>生成重定向请求，重新请求重定向的链接。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">  <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">  <span class="keyword">var</span> request = chain.request</span><br><span class="line">  <span class="keyword">val</span> call = realChain.call</span><br><span class="line">  <span class="keyword">var</span> followUpCount = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> priorResponse: Response? = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">var</span> newExchangeFinder = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">var</span> recoveredFailures = listOf&lt;IOException&gt;()</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 1、初始化 </span></span><br><span class="line">    call.enterNetworkInterceptorExchange(request, newExchangeFinder)</span><br><span class="line">    <span class="keyword">var</span> response: Response</span><br><span class="line">    <span class="keyword">var</span> closeActiveExchange = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 请求取消  </span></span><br><span class="line">      <span class="keyword">if</span> (call.isCanceled()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2、交给下一个拦截器  </span></span><br><span class="line">        response = realChain.proceed(request)</span><br><span class="line">        newExchangeFinder = <span class="literal">true</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e: RouteException) &#123;</span><br><span class="line">        <span class="comment">// 3、路由异常，连接未成功，请求没有发出去</span></span><br><span class="line">        <span class="keyword">if</span> (!recover(e.lastConnectException, call, request, requestSendStarted = <span class="literal">false</span>)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> e.firstConnectException.withSuppressed(recoveredFailures)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          recoveredFailures += e.firstConnectException</span><br><span class="line">        &#125;</span><br><span class="line">        newExchangeFinder = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">        <span class="comment">// 3、请求发出去了，但是和服务器通信失败，服务器读取请求内容突然关闭</span></span><br><span class="line">        <span class="keyword">if</span> (!recover(e, call, request, requestSendStarted = e !<span class="keyword">is</span> ConnectionShutdownException)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> e.withSuppressed(recoveredFailures)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          recoveredFailures += e</span><br><span class="line">        &#125;</span><br><span class="line">        newExchangeFinder = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 重定向会执行两次请求，第一次响应结果保存到重定向后的response中</span></span><br><span class="line">      <span class="keyword">if</span> (priorResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">        response = response.newBuilder()</span><br><span class="line">            .priorResponse(priorResponse.newBuilder()</span><br><span class="line">                .body(<span class="literal">null</span>)</span><br><span class="line">                .build())</span><br><span class="line">            .build()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">val</span> exchange = call.interceptorScopedExchange</span><br><span class="line">      <span class="comment">// 构建重定向请求    </span></span><br><span class="line">      <span class="keyword">val</span> followUp = followUpRequest(response, exchange)</span><br><span class="line">      <span class="comment">// 为空直接返回response   </span></span><br><span class="line">      <span class="keyword">if</span> (followUp == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exchange != <span class="literal">null</span> &amp;&amp; exchange.isDuplex) &#123;</span><br><span class="line">          call.timeoutEarlyExit()</span><br><span class="line">        &#125;</span><br><span class="line">        closeActiveExchange = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">val</span> followUpBody = followUp.body</span><br><span class="line">      <span class="comment">// isOneShot默认返回false，true表示只请求一次，所以重定向失效。   </span></span><br><span class="line">      <span class="keyword">if</span> (followUpBody != <span class="literal">null</span> &amp;&amp; followUpBody.isOneShot()) &#123;</span><br><span class="line">        closeActiveExchange = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">      &#125;</span><br><span class="line">      response.body?.closeQuietly()</span><br><span class="line">      <span class="comment">// 最多重定向20次    </span></span><br><span class="line">      <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ProtocolException(<span class="string">&quot;Too many follow-up requests: <span class="variable">$followUpCount</span>&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 保存重定向请求参数  </span></span><br><span class="line">      request = followUp</span><br><span class="line">      <span class="comment">// 保存上个重定向结果    </span></span><br><span class="line">      priorResponse = response</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      call.exitNetworkInterceptorExchange(closeActiveExchange)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="enterNetworkInterceptorExchange-初始化"><a href="#enterNetworkInterceptorExchange-初始化" class="headerlink" title="enterNetworkInterceptorExchange()初始化"></a>enterNetworkInterceptorExchange()初始化</h4><p>Exchange 表示请求- 响应一次数据交换，只有建立连接才能数据交换。</p>
<p>ExchangeFinder 的作用就是将寻找可重用的连接，此类的实例不是线程安全的。</p>
<ol>
<li>先检查上次连接是否已经关闭，没有关闭直接抛出一个异常</li>
<li>创建 <code>RealRoutePlanner</code> 选择和建立一个可用连接，调用 <code>createAddress()</code> 将核心信息保存下来。</li>
<li><code>client.fastFallback</code> 默认为 true，所以会创建<code>FastFallbackExchangeFinder</code> 对象。<br>这些初始化信息是为了后面网络连接使用。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealCall</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">enterNetworkInterceptorExchange</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    request: <span class="type">Request</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    newRoutePlanner: <span class="type">Boolean</span> = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    chain: <span class="type">RealInterceptorChain</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    check(interceptorScopedExchange == <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">        check(!responseBodyOpen) &#123;</span><br><span class="line">            <span class="string">&quot;cannot make a new request because the previous response is still open: &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;please call response.close()&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        check(!requestBodyOpen)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newRoutePlanner) &#123;</span><br><span class="line">        <span class="keyword">val</span> routePlanner = RealRoutePlanner(</span><br><span class="line">            client,</span><br><span class="line">            createAddress(request.url),</span><br><span class="line">            <span class="keyword">this</span>,</span><br><span class="line">            chain,</span><br><span class="line">            connectionListener = connectionPool.connectionListener</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">this</span>.exchangeFinder = <span class="keyword">when</span> &#123;</span><br><span class="line">            client.fastFallback -&gt; FastFallbackExchangeFinder(routePlanner, client.taskRunner)</span><br><span class="line">            <span class="keyword">else</span> -&gt; SequentialExchangeFinder(routePlanner)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="recover请求重试"><a href="#recover请求重试" class="headerlink" title="recover请求重试"></a>recover请求重试</h5><p>只有满足以下所有的条件，才能发起重连：</p>
<ol>
<li><code>retryOnConnectionFailure = true</code> okhttpClient 配置时 允许重连。</li>
<li><code>isRecoverable()</code>，如果是协议异常、超时异常、HTTPS 连接异常导致连接失败，则不能重试</li>
<li>还有新的路由可以连接</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RouteException</span></span><br><span class="line">recover(e.lastConnectException, call, request, requestSendStarted = <span class="literal">false</span>)</span><br><span class="line">    <span class="comment">// IOException    </span></span><br><span class="line">    recover(e, call, request, requestSendStarted = e !<span class="keyword">is</span> ConnectionShutdownException)    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">recover</span><span class="params">(e: <span class="type">IOException</span>, call: <span class="type">RealCall</span>,userRequest: <span class="type">Request</span>, requestSendStarted: <span class="type">Boolean</span>)</span></span>: <span class="built_in">Boolean</span> &#123;  </span><br><span class="line">    <span class="comment">// 如果配置不重连，则直接返回false  </span></span><br><span class="line">    <span class="keyword">if</span> (!client.retryOnConnectionFailure) <span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">    <span class="comment">// 一般不满足  </span></span><br><span class="line">    <span class="keyword">if</span> (requestSendStarted &amp;&amp; requestIsOneShot(e, userRequest)) <span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">    <span class="comment">// 是否是重连的异常  </span></span><br><span class="line">    <span class="keyword">if</span> (!isRecoverable(e, requestSendStarted)) <span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">   <span class="comment">// 没有新的路由可以重连  </span></span><br><span class="line">    <span class="keyword">if</span> (!call.retryAfterFailure()) <span class="keyword">return</span> <span class="literal">false</span> </span><br><span class="line">    <span class="comment">// For failure recovery, use the same route selector with a new connection. </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h5><p>重定向是当客户端和服务端建立TCP连接成功，但是HTTP请求失败，会根据状态码是否重试。</p>
<p>407和401 因为未授权导致请求失败，会调用在OkHttpClient 组件介绍部分的认证器重新认证再次发起请求。</p>
<p>3XX，重定向状态码，会调用<code>buildRedirectRequest()</code> ，取出location字段的url，重新建立请求。</p>
<p>408、503、421 因为客户端和服务端自身原因导致失败，会根据条件判断是否发起一个新的请求。</p>
<p><strong>重定向次数最多只有20次</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">followUpRequest</span><span class="params">(userResponse: <span class="type">Response</span>, exchange: <span class="type">Exchange</span>?)</span></span>: Request? &#123;</span><br><span class="line">    <span class="keyword">val</span> route = exchange?.connection?.route()</span><br><span class="line">        <span class="keyword">val</span> responseCode = userResponse.code</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> method = userResponse.request.method</span><br><span class="line">        <span class="keyword">when</span> (responseCode) &#123;</span><br><span class="line">       	<span class="comment">//  407 代理服务器未授权，会调用proxyAuthenticator重新授权再发起请求</span></span><br><span class="line">        HTTP_PROXY_AUTH -&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> selectedProxy = route!!.proxy</span><br><span class="line">                <span class="keyword">if</span> (selectedProxy.type() != Proxy.Type.HTTP) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> ProtocolException(<span class="string">&quot;Received HTTP_PROXY_AUTH (407) code while not using proxy&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">return</span> client.proxyAuthenticator.authenticate(route, userResponse)</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 401 目的服务器未授权，调用authenticator重新授权</span></span><br><span class="line">        HTTP_UNAUTHORIZED -&gt; <span class="keyword">return</span> client.authenticator.authenticate(route, userResponse)</span><br><span class="line">        <span class="comment">//  3xx 重定向状态码，发起重定向请求   </span></span><br><span class="line">        HTTP_PERM_REDIRECT, HTTP_TEMP_REDIRECT, HTTP_MULT_CHOICE, HTTP_MOVED_PERM, HTTP_MOVED_TEMP, HTTP_SEE_OTHER -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> buildRedirectRequest(userResponse, method)</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">        <span class="comment">// 408 客户端连接超时</span></span><br><span class="line">        HTTP_CLIENT_TIMEOUT -&gt; &#123;</span><br><span class="line">           	<span class="comment">// 是否允许能连接重试</span></span><br><span class="line">            <span class="keyword">if</span> (!client.retryOnConnectionFailure) &#123;</span><br><span class="line">                <span class="comment">// The application layer has directed us not to retry the request.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> requestBody = userResponse.request.body</span><br><span class="line">                <span class="keyword">if</span> (requestBody != <span class="literal">null</span> &amp;&amp; requestBody.isOneShot()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">val</span> priorResponse = userResponse.priorResponse</span><br><span class="line">                <span class="keyword">if</span> (priorResponse != <span class="literal">null</span> &amp;&amp; priorResponse.code == HTTP_CLIENT_TIMEOUT) &#123;</span><br><span class="line">                    <span class="comment">// We attempted to retry and got another timeout. Give up.</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (retryAfter(userResponse, <span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> userResponse.request</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 503 服务不可用</span></span><br><span class="line">        HTTP_UNAVAILABLE -&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> priorResponse = userResponse.priorResponse</span><br><span class="line">                <span class="keyword">if</span> (priorResponse != <span class="literal">null</span> &amp;&amp; priorResponse.code == HTTP_UNAVAILABLE) &#123;</span><br><span class="line">                    <span class="comment">// We attempted to retry and got another timeout. Give up.</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (retryAfter(userResponse, Integer.MAX_VALUE) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// specifically received an instruction to retry without delay</span></span><br><span class="line">                <span class="keyword">return</span> userResponse.request</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">	    <span class="comment">// 421 从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围</span></span><br><span class="line">        HTTP_MISDIRECTED_REQUEST -&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> requestBody = userResponse.request.body</span><br><span class="line">                <span class="keyword">if</span> (requestBody != <span class="literal">null</span> &amp;&amp; requestBody.isOneShot()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (exchange == <span class="literal">null</span> || !exchange.isCoalescedConnection) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            exchange.connection.noCoalescedConnections()</span><br><span class="line">                <span class="keyword">return</span> userResponse.request</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3、桥接拦截器BridgeInterceptor"><a href="#3、桥接拦截器BridgeInterceptor" class="headerlink" title="3、桥接拦截器BridgeInterceptor"></a>3、桥接拦截器BridgeInterceptor</h3><p>它负责为请求添加一些开发者不需要手动添加，但服务端需要的请求字段，加载保存的cookie。</p>
<p>请求头，一般实际开发中配合 Retrofit 注解配合构建 RequestBody:</p>
<ol>
<li>请求实体 RequestBody 有 content-type，header 添加 <code>Content-Type</code>。</li>
<li>请求实体有 content-length 大小，header 添加 <code>Content-Length</code>，没有值添加 <code>Transfer-Encoding:chunked</code>，分块传输，它两互斥。</li>
<li>header 添加 <code>host</code>, 把 url 中的域名部分作为 host。</li>
<li>header 添加 <code>Connection:Keep-Alive</code>，保证单次请求后连接不断开。</li>
<li>如果不是范围请求，header 默认添加 <code>Accept-Encoding:gzip</code> 支持服务器资源 gzip 压缩。</li>
<li>有 cookie header 添加 <code>Cookie</code> 信息。</li>
<li>header 添加 <code>User-Agent:okhttp/$&#123;CONST_VERSION&#125;</code>。</li>
</ol>
<p>获取响应后，解析响应头:</p>
<ol>
<li>响应头有<code>Set-Cookie</code>，会用 CookieJar 保存服务器返回的cookie。</li>
<li>响应头有<code>Content-Encoding:gzip</code> 且根据<code>networkResponse.promisesBody()</code>服务端有返回压缩实体，则使用<code>GzipSource</code>用于解压。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">  <span class="keyword">val</span> userRequest = chain.request()</span><br><span class="line">  <span class="keyword">val</span> requestBuilder = userRequest.newBuilder()</span><br><span class="line">  <span class="comment">// 1、处理请求头    </span></span><br><span class="line">  <span class="keyword">val</span> body = userRequest.body</span><br><span class="line">  <span class="comment">// 添加实体首部   </span></span><br><span class="line">  <span class="keyword">if</span> (body != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> contentType = body.contentType()</span><br><span class="line">    <span class="keyword">if</span> (contentType != <span class="literal">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">&quot;Content-Type&quot;</span>, contentType.toString())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> contentLength = body.contentLength()</span><br><span class="line">    <span class="keyword">if</span> (contentLength != -<span class="number">1L</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">&quot;Content-Length&quot;</span>, contentLength.toString())</span><br><span class="line">      requestBuilder.removeHeader(<span class="string">&quot;Transfer-Encoding&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">&quot;Transfer-Encoding&quot;</span>, <span class="string">&quot;chunked&quot;</span>)</span><br><span class="line">      requestBuilder.removeHeader(<span class="string">&quot;Content-Length&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加host  </span></span><br><span class="line">  <span class="keyword">if</span> (userRequest.header(<span class="string">&quot;Host&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">    requestBuilder.header(<span class="string">&quot;Host&quot;</span>, userRequest.url.toHostHeader())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 默认为长连接  </span></span><br><span class="line">  <span class="keyword">if</span> (userRequest.header(<span class="string">&quot;Connection&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">    requestBuilder.header(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;Keep-Alive&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 默认期望服务器返回压缩字段</span></span><br><span class="line">  <span class="keyword">var</span> transparentGzip = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">if</span> (userRequest.header(<span class="string">&quot;Accept-Encoding&quot;</span>) == <span class="literal">null</span> &amp;&amp; userRequest.header(<span class="string">&quot;Range&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">    transparentGzip = <span class="literal">true</span></span><br><span class="line">    requestBuilder.header(<span class="string">&quot;Accept-Encoding&quot;</span>, <span class="string">&quot;gzip&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 加载cookie  </span></span><br><span class="line">  <span class="keyword">val</span> cookies = cookieJar.loadForRequest(userRequest.url)</span><br><span class="line">  <span class="keyword">if</span> (cookies.isNotEmpty()) &#123;</span><br><span class="line">    requestBuilder.header(<span class="string">&quot;Cookie&quot;</span>, cookieHeader(cookies))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加UA  </span></span><br><span class="line">  <span class="keyword">if</span> (userRequest.header(<span class="string">&quot;User-Agent&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">    requestBuilder.header(<span class="string">&quot;User-Agent&quot;</span>, userAgent)</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 2、发给下一个拦截器  </span></span><br><span class="line">  <span class="keyword">val</span> networkResponse = chain.proceed(requestBuilder.build())</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3、处理响应头   </span></span><br><span class="line">  <span class="comment">// 保存cookie    </span></span><br><span class="line">  cookieJar.receiveHeaders(userRequest.url, networkResponse.headers)</span><br><span class="line">  <span class="keyword">val</span> responseBuilder = networkResponse.newBuilder()</span><br><span class="line">      .request(userRequest)</span><br><span class="line">  <span class="comment">// 如果服务器返回压缩格式数据，进行解压    </span></span><br><span class="line">  <span class="keyword">if</span> (transparentGzip &amp;&amp;</span><br><span class="line">      <span class="string">&quot;gzip&quot;</span>.equals(networkResponse.header(<span class="string">&quot;Content-Encoding&quot;</span>), ignoreCase = <span class="literal">true</span>) &amp;&amp;</span><br><span class="line">      networkResponse.promisesBody()) &#123;</span><br><span class="line">    <span class="keyword">val</span> responseBody = networkResponse.body</span><br><span class="line">    <span class="keyword">if</span> (responseBody != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">val</span> gzipSource = GzipSource(responseBody.source())</span><br><span class="line">      <span class="keyword">val</span> strippedHeaders = networkResponse.headers.newBuilder()</span><br><span class="line">          .removeAll(<span class="string">&quot;Content-Encoding&quot;</span>)</span><br><span class="line">          .removeAll(<span class="string">&quot;Content-Length&quot;</span>)</span><br><span class="line">          .build()</span><br><span class="line">      responseBuilder.headers(strippedHeaders)</span><br><span class="line">      <span class="keyword">val</span> contentType = networkResponse.header(<span class="string">&quot;Content-Type&quot;</span>)</span><br><span class="line">      responseBuilder.body(RealResponseBody(contentType, -<span class="number">1L</span>, gzipSource.buffer()))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> responseBuilder.build()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4、缓存拦截器CacheInterceptor"><a href="#4、缓存拦截器CacheInterceptor" class="headerlink" title="4、缓存拦截器CacheInterceptor"></a>4、缓存拦截器CacheInterceptor</h3><p>负责HTTP的缓存处理，在建立连接发出请求前，先判断是否存在本地响应结果缓存，如果存在可以直接返回不请求服务器。，</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">  <span class="keyword">val</span> call = chain.call()</span><br><span class="line">  <span class="keyword">val</span> cacheCandidate = cache?.<span class="keyword">get</span>(chain.request())</span><br><span class="line">  <span class="keyword">val</span> now = System.currentTimeMillis()</span><br><span class="line">  <span class="keyword">val</span> strategy = CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()</span><br><span class="line">  <span class="keyword">val</span> networkRequest = strategy.networkRequest</span><br><span class="line">  <span class="keyword">val</span> cacheResponse = strategy.cacheResponse</span><br><span class="line">  cache?.trackResponse(strategy)</span><br><span class="line">  <span class="keyword">val</span> listener = (call <span class="keyword">as</span>? RealCall)?.eventListener ?: EventListener.NONE</span><br><span class="line">  <span class="keyword">if</span> (cacheCandidate != <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// The cache candidate wasn&#x27;t applicable. Close it.</span></span><br><span class="line">    cacheCandidate.body?.closeQuietly()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// If we&#x27;re forbidden from using the network and the cache is insufficient, fail.</span></span><br><span class="line">  <span class="keyword">if</span> (networkRequest == <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Response.Builder()</span><br><span class="line">        .request(chain.request())</span><br><span class="line">        .protocol(Protocol.HTTP_1_1)</span><br><span class="line">        .code(HTTP_GATEWAY_TIMEOUT)</span><br><span class="line">        .message(<span class="string">&quot;Unsatisfiable Request (only-if-cached)&quot;</span>)</span><br><span class="line">        .body(EMPTY_RESPONSE)</span><br><span class="line">        .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build().also &#123;</span><br><span class="line">          listener.satisfactionFailure(call, it)</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// If we don&#x27;t need the network, we&#x27;re done.</span></span><br><span class="line">  <span class="keyword">if</span> (networkRequest == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> cacheResponse!!.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .build().also &#123;</span><br><span class="line">          listener.cacheHit(call, it)</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">    listener.cacheConditionalHit(call, cacheResponse)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">    listener.cacheMiss(call)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> networkResponse: Response? = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 2、转向下一个拦截器  </span></span><br><span class="line">    networkResponse = chain.proceed(networkRequest)</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// If we&#x27;re crashing on I/O or otherwise, don&#x27;t leak the cache body.</span></span><br><span class="line">    <span class="keyword">if</span> (networkResponse == <span class="literal">null</span> &amp;&amp; cacheCandidate != <span class="literal">null</span>) &#123;</span><br><span class="line">      cacheCandidate.body?.closeQuietly()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// If we have a cache response too, then we&#x27;re doing a conditional get.</span></span><br><span class="line">  <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (networkResponse?.code == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">      <span class="keyword">val</span> response = cacheResponse.newBuilder()</span><br><span class="line">          .headers(combine(cacheResponse.headers, networkResponse.headers))</span><br><span class="line">          .sentRequestAtMillis(networkResponse.sentRequestAtMillis)</span><br><span class="line">          .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis)</span><br><span class="line">          .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">          .networkResponse(stripBody(networkResponse))</span><br><span class="line">          .build()</span><br><span class="line">      networkResponse.body!!.close()</span><br><span class="line">      <span class="comment">// Update the cache after combining headers but before stripping the</span></span><br><span class="line">      <span class="comment">// Content-Encoding header (as performed by initContentStream()).</span></span><br><span class="line">      cache!!.trackConditionalCacheHit()</span><br><span class="line">      cache.update(cacheResponse, response)</span><br><span class="line">      <span class="keyword">return</span> response.also &#123;</span><br><span class="line">        listener.cacheHit(call, it)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cacheResponse.body?.closeQuietly()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">val</span> response = networkResponse!!.newBuilder()</span><br><span class="line">      .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">      .networkResponse(stripBody(networkResponse))</span><br><span class="line">      .build()</span><br><span class="line">  <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (response.promisesBody() &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">      <span class="comment">// Offer this request to the cache.</span></span><br><span class="line">      <span class="keyword">val</span> cacheRequest = cache.put(response)</span><br><span class="line">      <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response).also &#123;</span><br><span class="line">        <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// This will log a conditional cache miss only.</span></span><br><span class="line">          listener.cacheMiss(call)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cache.remove(networkRequest)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (_: IOException) &#123;</span><br><span class="line">        <span class="comment">// The cache cannot be written.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> response</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5、连接拦截器ConnectInterceptor"><a href="#5、连接拦截器ConnectInterceptor" class="headerlink" title="5、连接拦截器ConnectInterceptor"></a>5、连接拦截器ConnectInterceptor</h3><p>它负责建立连接，会使用Socket建立TCP连接，如果是HTTPS 协议，则在TCP之上建立TLS连接，返回对应的 HttpCodec 对象（⽤于编码解码 HTTP 请求）。</p>
<p>代码虽然不多，但是大多数功能逻辑都封装到其他类中，核心代码<code>realChain.call.initExchange(chain)</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">  <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">  <span class="keyword">val</span> exchange = realChain.call.initExchange(chain)</span><br><span class="line">  <span class="keyword">val</span> connectedChain = realChain.copy(exchange = exchange)</span><br><span class="line">  <span class="keyword">return</span> connectedChain.proceed(realChain.request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>调用<code>exchangeFinder.find()</code>返回HTTPCodec，负责请求编解码，然后组成一个<code>Exchange</code>，负责传输单个 HTTP 请求和响应对，完成一次数据交换，保存到<code>RealCall</code>的 <code>exchange</code>字段中。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealCall</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">initExchange</span><span class="params">(chain: <span class="type">RealInterceptorChain</span>)</span></span>: Exchange &#123;</span><br><span class="line">  synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">    check(expectMoreExchanges) &#123; <span class="string">&quot;released&quot;</span> &#125;</span><br><span class="line">    check(!responseBodyOpen)</span><br><span class="line">    check(!requestBodyOpen)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">val</span> exchangeFinder = <span class="keyword">this</span>.exchangeFinder!!</span><br><span class="line">  <span class="comment">// 找连接，返回codc    </span></span><br><span class="line">  <span class="keyword">val</span> codec = exchangeFinder.find(client, chain) </span><br><span class="line">  <span class="keyword">val</span> result = Exchange(<span class="keyword">this</span>, eventListener, exchangeFinder, codec)</span><br><span class="line">  <span class="keyword">this</span>.interceptorScopedExchange = result</span><br><span class="line">  <span class="keyword">this</span>.exchange = result</span><br><span class="line">  synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.requestBodyOpen = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">this</span>.responseBodyOpen = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (canceled) <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li>调用<code>findHealthyConnection</code>查找可用连接。</li>
<li>调用<code>resultConnection.newCodec</code>创建HTTP编解码器。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExchangeFinder</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">find</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  client: <span class="type">OkHttpClient</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  chain: <span class="type">RealInterceptorChain</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: ExchangeCodec &#123;</span><br><span class="line">    <span class="comment">// 找到一个可用的连接</span></span><br><span class="line"> 	<span class="keyword">val</span> resultConnection = findHealthyConnection(</span><br><span class="line">        connectTimeout = chain.connectTimeoutMillis,</span><br><span class="line">        readTimeout = chain.readTimeoutMillis,</span><br><span class="line">        writeTimeout = chain.writeTimeoutMillis,</span><br><span class="line">        pingIntervalMillis = client.pingIntervalMillis,</span><br><span class="line">        connectionRetryEnabled = client.retryOnConnectionFailure,</span><br><span class="line">        doExtensiveHealthChecks = chain.request.method != <span class="string">&quot;GET&quot;</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 根据连接创建Codec    </span></span><br><span class="line">    <span class="keyword">return</span> resultConnection.newCodec(client, chain)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li><code>findConnection()</code> 查找连接</li>
<li><code>isHealthy()</code>判断连接是否可用</li>
</ol>
<p>如果获取的Connection不可用，则再次循环调用<code>findConnection()</code>再从连接池中获取连接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExchangeFinder</span></span><br><span class="line"><span class="keyword">private</span> fun <span class="title function_">findHealthyConnection</span><span class="params">(</span></span><br><span class="line"><span class="params">  connectTimeout: Int,</span></span><br><span class="line"><span class="params">  readTimeout: Int,</span></span><br><span class="line"><span class="params">  writeTimeout: Int,</span></span><br><span class="line"><span class="params">  pingIntervalMillis: Int,</span></span><br><span class="line"><span class="params">  connectionRetryEnabled: Boolean,</span></span><br><span class="line"><span class="params">  doExtensiveHealthChecks: Boolean</span></span><br><span class="line"><span class="params">)</span>: RealConnection &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">//查找连接  </span></span><br><span class="line">    <span class="type">val</span> <span class="variable">candidate</span> <span class="operator">=</span> findConnection(</span><br><span class="line">        connectTimeout = connectTimeout,</span><br><span class="line">        readTimeout = readTimeout,</span><br><span class="line">        writeTimeout = writeTimeout,</span><br><span class="line">        pingIntervalMillis = pingIntervalMillis,</span><br><span class="line">        connectionRetryEnabled = connectionRetryEnabled</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 确认Connection可用</span></span><br><span class="line">    <span class="keyword">if</span> (candidate.isHealthy(doExtensiveHealthChecks)) &#123;</span><br><span class="line">      <span class="keyword">return</span> candidate</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>从连接池获取连接的逻辑非常复杂，我们需要拆分来看，整体逻辑如下，从连接池获取连接的核心代码<code>connectionPool.callAcquirePooledConnection()</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExchangeFinder</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">findConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  connectTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  readTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  writeTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  pingIntervalMillis: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  connectionRetryEnabled: <span class="type">Boolean</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: RealConnection &#123;</span><br><span class="line">  <span class="comment">// 请求被取消直接抛出异常  </span></span><br><span class="line">  <span class="keyword">if</span> (call.isCanceled()) <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line">  <span class="comment">// Attempt to reuse the connection from the call.</span></span><br><span class="line">  <span class="keyword">val</span> callConnection = call.connection </span><br><span class="line">  <span class="comment">// 1、第一次请求时connection = null，跳过，第二次请求连接可能已经建立</span></span><br><span class="line">  <span class="keyword">if</span> (callConnection != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> toClose: Socket? = <span class="literal">null</span></span><br><span class="line">    synchronized(callConnection) &#123;</span><br><span class="line">      <span class="keyword">if</span> (callConnection.noNewExchanges || !sameHostAndPort(callConnection.route().address.url)) &#123;</span><br><span class="line">        toClose = call.releaseConnectionNoEvents()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If the call&#x27;s connection wasn&#x27;t released, reuse it. We don&#x27;t call connectionAcquired() here</span></span><br><span class="line">    <span class="comment">// because we already acquired it.</span></span><br><span class="line">    <span class="keyword">if</span> (call.connection != <span class="literal">null</span>) &#123;</span><br><span class="line">      check(toClose == <span class="literal">null</span>)</span><br><span class="line">      <span class="keyword">return</span> callConnection</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The call&#x27;s connection was released.</span></span><br><span class="line">    toClose?.closeQuietly()</span><br><span class="line">    eventListener.connectionReleased(call, callConnection)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  refusedStreamCount = <span class="number">0</span></span><br><span class="line">  connectionShutdownCount = <span class="number">0</span></span><br><span class="line">  otherFailureCount = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 2、从连接池中获取连接</span></span><br><span class="line">  <span class="keyword">if</span> (connectionPool.callAcquirePooledConnection(address, call, <span class="literal">null</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">    <span class="keyword">val</span> result = call.connection!!</span><br><span class="line">    eventListener.connectionAcquired(call, result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Nothing in the pool. Figure out what route we&#x27;ll try next.</span></span><br><span class="line">  <span class="keyword">val</span> routes: List&lt;Route&gt;?</span><br><span class="line">  <span class="keyword">val</span> route: Route</span><br><span class="line">  <span class="keyword">if</span> (nextRouteToTry != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Use a route from a preceding coalesced connection.</span></span><br><span class="line">    routes = <span class="literal">null</span></span><br><span class="line">    route = nextRouteToTry!!</span><br><span class="line">    nextRouteToTry = <span class="literal">null</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (routeSelection != <span class="literal">null</span> &amp;&amp; routeSelection!!.hasNext()) &#123;</span><br><span class="line">    <span class="comment">// Use a route from an existing route selection.</span></span><br><span class="line">    routes = <span class="literal">null</span></span><br><span class="line">    route = routeSelection!!.next()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Compute a new route selection. This is a blocking operation!</span></span><br><span class="line">    <span class="keyword">var</span> localRouteSelector = routeSelector</span><br><span class="line">    <span class="keyword">if</span> (localRouteSelector == <span class="literal">null</span>) &#123;</span><br><span class="line">      localRouteSelector = RouteSelector(address, call.client.routeDatabase, call, eventListener)</span><br><span class="line">      <span class="keyword">this</span>.routeSelector = localRouteSelector</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> localRouteSelection = localRouteSelector.next()</span><br><span class="line">    routeSelection = localRouteSelection</span><br><span class="line">    routes = localRouteSelection.routes</span><br><span class="line">    <span class="keyword">if</span> (call.isCanceled()) <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line">    <span class="comment">// 3、从连接池中获取连接</span></span><br><span class="line">    <span class="keyword">if</span> (connectionPool.callAcquirePooledConnection(address, call, routes, <span class="literal">false</span>)) &#123;</span><br><span class="line">      <span class="keyword">val</span> result = call.connection!!</span><br><span class="line">      eventListener.connectionAcquired(call, result)</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    route = localRouteSelection.next()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 4、创建一个新的连接</span></span><br><span class="line">  <span class="keyword">val</span> newConnection = RealConnection(connectionPool, route)</span><br><span class="line">  call.connectionToCancel = newConnection</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    newConnection.connect(</span><br><span class="line">        connectTimeout,</span><br><span class="line">        readTimeout,</span><br><span class="line">        writeTimeout,</span><br><span class="line">        pingIntervalMillis,</span><br><span class="line">        connectionRetryEnabled,</span><br><span class="line">        call,</span><br><span class="line">        eventListener</span><br><span class="line">    )</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    call.connectionToCancel = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  call.client.routeDatabase.connected(newConnection.route())</span><br><span class="line">  <span class="comment">// 5、从连接池获取连接</span></span><br><span class="line">  <span class="keyword">if</span> (connectionPool.callAcquirePooledConnection(address, call, routes, <span class="literal">true</span>)) &#123;</span><br><span class="line">    <span class="keyword">val</span> result = call.connection!!</span><br><span class="line">    nextRouteToTry = route</span><br><span class="line">    newConnection.socket().closeQuietly()</span><br><span class="line">    eventListener.connectionAcquired(call, result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  synchronized(newConnection) &#123;</span><br><span class="line">    connectionPool.put(newConnection)</span><br><span class="line">    call.acquireConnectionNoEvents(newConnection)</span><br><span class="line">  &#125;</span><br><span class="line">  eventListener.connectionAcquired(call, newConnection)</span><br><span class="line">  <span class="keyword">return</span> newConnection</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>第一个条件，<code>requireMultiplexed</code>表示 是否只获取多路复用的连接，即HTTP2连接。</p>
<p>因为HTTP 1.0 和 1.1 请求需要排队发送，当队头请求堵塞时，后面的请求都会被影响。因此HTTP2 做了优化，采用多路复用技术，多个请求合并使用同一个连接。</p>
<p>如果<code>requireMultiplexed = true</code>要求只拿HTTP2连接，但连接池中连接不支持，则continue，遍历下个连接，反之连接支持HTTP2则执行第二个条件。</p>
<p>如果<code>requireMultiplexed = false</code>不强求连接支持多路复用，直接执行第二个条件。</p>
<p>第二个条件<code>isEligible()</code>需要根据代码来判断是否有符合条件的连接，传入<code>address</code> 和 <code>routes</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealConnectionPool</span></span><br><span class="line">fun <span class="title function_">callAcquirePooledConnection</span><span class="params">(</span></span><br><span class="line"><span class="params">  address: Address,</span></span><br><span class="line"><span class="params">  call: RealCall,</span></span><br><span class="line"><span class="params">  routes: List&lt;Route&gt;?,</span></span><br><span class="line"><span class="params">  requireMultiplexed: Boolean</span></span><br><span class="line"><span class="params">)</span>: Boolean &#123;</span><br><span class="line">  <span class="keyword">for</span> (connection in connections) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(connection) &#123;</span><br><span class="line">      <span class="comment">// http2多路复用  </span></span><br><span class="line">      <span class="keyword">if</span> (requireMultiplexed &amp;&amp; !connection.isMultiplexed) <span class="keyword">return</span><span class="meta">@synchronized</span></span><br><span class="line">      <span class="keyword">if</span> (!connection.isEligible(address, routes)) <span class="keyword">return</span><span class="meta">@synchronized</span></span><br><span class="line">      call.acquireConnectionNoEvents(connection)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果HTTP 1.0 或 1.1 连接，满足以下两个条件则可复用连接</p>
<ol>
<li>先判断连接中已有的请求数，一个连接每次只能执行 1 个HTTP请求，并且当前连接没有正在执行的请求。</li>
<li>端口、主机名、代理、TLS版本、密码套件等连接相关的配置都要一致，则证明连接的是同一个服务器，比如请求<code>https://baidu.com/index/1</code> 和 <code>https://baidu.com/index/2</code>，两者可共用同一个连接。</li>
</ol>
<p>如果HTTP1.0或1.1条件不满足，再验证HTTP2，HTTP2一个连接支持执行多个请求，需要满足以下4个条件：</p>
<ol>
<li>支持HTTP2连接</li>
<li><code>routes</code> 不为空，且使用直连模式，ip相同</li>
<li>主机名可以不同，但证书为多域名证书，当前主机名可以验证通过。</li>
</ol>
<p>如果<code>https://github.com</code> 和 <code>https://githlab.com</code>是同一个服务器的虚拟主机，支持HTTP2，则请求这两个主机名都可以复用同一个连接。</p>
<ul>
<li>如果<code>routes = null</code>，则只能获取HTTP 1.0 &#x2F; 1.1 的连接</li>
<li>如果<code>routes != null</code>，则可以获取HTTP 1.0 &#x2F; 1.1 的连接HTTP2 的连接</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealConnection</span></span><br><span class="line">internal fun <span class="title function_">isEligible</span><span class="params">(address: Address, routes: List&lt;Route&gt;?)</span>: Boolean &#123;</span><br><span class="line">  assertThreadHoldsLock()</span><br><span class="line">  <span class="comment">// http1.0或1.1</span></span><br><span class="line">  <span class="keyword">if</span> (calls.size &gt;= allocationLimit || noNewExchanges) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  </span><br><span class="line">  <span class="title function_">if</span> <span class="params">(!<span class="built_in">this</span>.route.address.equalsNonHost(address)</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  </span><br><span class="line">  <span class="title function_">if</span> <span class="params">(address.url.host == <span class="built_in">this</span>.route()</span>.address.url.host) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// HTTP/2</span></span><br><span class="line">  <span class="keyword">if</span> (http2Connection == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"> </span><br><span class="line">  <span class="title function_">if</span> <span class="params">(routes == <span class="literal">null</span> || !routeMatchesAny(routes)</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"> </span><br><span class="line">  <span class="title function_">if</span> <span class="params">(address.hostnameVerifier !== OkHostnameVerifier)</span> <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="title function_">if</span> <span class="params">(!supportsUrl(address.url)</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    address.certificatePinner!!.check(address.url.host, handshake()!!.peerCertificates)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (_: SSLPeerUnverifiedException) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="从连接池获取连接过程"><a href="#从连接池获取连接过程" class="headerlink" title="从连接池获取连接过程"></a>从连接池获取连接过程</h4><p>下面会拆分<code>ExchangeFinder.findConnection()</code></p>
<p>第一次请求，connection 默认为null，当请求重试，比如重新刷新token，重定向。第一次请求完成后，当前connection已经建立可以直接复用。</p>
<p>比如请求<code>https://baidu.com/index1</code> 重定向返回的<code>https://baidu.com/index2</code>，则重定向可以复用连接。</p>
<p>如果第二次请求连接不能被复用，则会调用<code>closeQuietly()</code>方法安全释放当前连接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、第一次请求时connection = null，跳过，第二次请求连接可能已经建立</span></span><br><span class="line"> <span class="keyword">if</span> (callConnection != <span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> toClose: Socket? = <span class="literal">null</span></span><br><span class="line">   <span class="title function_">synchronized</span><span class="params">(callConnection)</span> &#123;</span><br><span class="line">     <span class="comment">// 当前连接不接受新请求或post、host不同，则会释放当前连接  </span></span><br><span class="line">     <span class="keyword">if</span> (callConnection.noNewExchanges || !sameHostAndPort(callConnection.route().address.url)) &#123;</span><br><span class="line">       toClose = call.releaseConnectionNoEvents()</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 如果当前连接可以直接复用</span></span><br><span class="line">   <span class="keyword">if</span> (call.connection != <span class="literal">null</span>) &#123;</span><br><span class="line">     check(toClose == <span class="literal">null</span>)</span><br><span class="line">     <span class="keyword">return</span> callConnection</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// The call&#x27;s connection was released.</span></span><br><span class="line">   toClose?.closeQuietly()</span><br><span class="line">   eventListener.connectionReleased(call, callConnection)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><code>routes = null</code>，<code>requireMultiplexed = false</code>，这两个条件一综合，先向连接池中获取HTTP1.0&#x2F;1.1的连接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">refusedStreamCount = <span class="number">0</span></span><br><span class="line">connectionShutdownCount = <span class="number">0</span></span><br><span class="line">otherFailureCount = <span class="number">0</span></span><br><span class="line"><span class="comment">// 2、从连接池中获取连接</span></span><br><span class="line"><span class="keyword">if</span> (connectionPool.callAcquirePooledConnection(address, call, <span class="literal">null</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">  <span class="type">val</span> <span class="variable">result</span> <span class="operator">=</span> call.connection!!</span><br><span class="line">  eventListener.connectionAcquired(call, result)</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Route</code>：包含<code>address</code>、<code>proxy</code>、<code>socketAddress</code>，<code>address</code>包括<code>host</code>和<code>port</code>。</p>
<p>一个域名下有多个IP，<code>proxy</code>包含直连和代理两种模式，路由就是IP、Port、主机名、代理模式的不同组合，网络数据包客户端-&gt;代理服务器-&gt;源服务器之间的传输路径。</p>
<p>Selection 按照Proxy 进行分类，直连模式下route分为一类，代理模式下route 分为一类。</p>
<p>如果有新的路由信息，再尝试从连接池获取连接，由于<code>routes != null</code>、<code>requireMultiplexed  = false</code>,既可以获取到HTTP1.0&#x2F;1.1的连接，也可以获取到HTTP2的连接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Nothing in the pool. Figure out what route we&#x27;ll try next.</span></span><br><span class="line">  val routes: List&lt;Route&gt;?</span><br><span class="line">  val route: Route</span><br><span class="line">    </span><br><span class="line">  <span class="title function_">if</span> <span class="params">(nextRouteToTry != <span class="literal">null</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// Use a route from a preceding coalesced connection.</span></span><br><span class="line">    routes = <span class="type">null</span></span><br><span class="line">    <span class="variable">route</span> <span class="operator">=</span> nextRouteToTry!!</span><br><span class="line">    nextRouteToTry = <span class="literal">null</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (routeSelection != <span class="literal">null</span> &amp;&amp; routeSelection!!.hasNext()) &#123;</span><br><span class="line">    <span class="comment">// Use a route from an existing route selection.</span></span><br><span class="line">    routes = <span class="type">null</span></span><br><span class="line">    <span class="variable">route</span> <span class="operator">=</span> routeSelection!!.next()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果有新的路由选择器</span></span><br><span class="line">    <span class="type">var</span> <span class="variable">localRouteSelector</span> <span class="operator">=</span> routeSelector</span><br><span class="line">    <span class="title function_">if</span> <span class="params">(localRouteSelector == <span class="literal">null</span>)</span> &#123;</span><br><span class="line">      localRouteSelector = RouteSelector(address, call.client.routeDatabase, call, eventListener)</span><br><span class="line">      <span class="built_in">this</span>.routeSelector = localRouteSelector</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">val</span> <span class="variable">localRouteSelection</span> <span class="operator">=</span> localRouteSelector.next()</span><br><span class="line">    routeSelection = <span class="type">localRouteSelection</span></span><br><span class="line">    <span class="variable">routes</span> <span class="operator">=</span> localRouteSelection.routes</span><br><span class="line">    <span class="title function_">if</span> <span class="params">(call.isCanceled()</span>) <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line">    <span class="comment">// 3、从连接池中获取连接</span></span><br><span class="line">    <span class="keyword">if</span> (connectionPool.callAcquirePooledConnection(address, call, routes, <span class="literal">false</span>)) &#123;</span><br><span class="line">      <span class="type">val</span> <span class="variable">result</span> <span class="operator">=</span> call.connection!!</span><br><span class="line">      eventListener.connectionAcquired(call, result)</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    route = localRouteSelection.next()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>如果前三次都没有从连接池中获取连接，则会创建一个新的连接，然后放入到缓存池当中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4、创建一个新的连接</span></span><br><span class="line"><span class="type">val</span> <span class="variable">newConnection</span> <span class="operator">=</span> RealConnection(connectionPool, route)</span><br><span class="line">call.connectionToCancel = newConnection</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  newConnection.connect(</span><br><span class="line">      connectTimeout,</span><br><span class="line">      readTimeout,</span><br><span class="line">      writeTimeout,</span><br><span class="line">      pingIntervalMillis,</span><br><span class="line">      connectionRetryEnabled,</span><br><span class="line">      call,</span><br><span class="line">      eventListener</span><br><span class="line">  )</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  call.connectionToCancel = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line">call.client.routeDatabase.connected(newConnection.route())</span><br></pre></td></tr></table></figure>



<p>创建完连接为什么还要再从连接池中获取。</p>
<p>这是考虑到极端情况，在上面线程池中并发执行两个相同域名的请求，同时创建了两个连接。</p>
<p>如果连接支持HTTP2，则可以将尝试两个请求合并到一个连接中。</p>
<p>所以<code>routes != null</code>，<code>requireMultiplexed = true</code>只获取HTTP2的连接。</p>
<p>如果获取到则之前创建的2个连接会弃用其中一个，节约资源。</p>
<p>如果没获取到则将新创建的连接放入到连接池中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5、从连接池获取连接</span></span><br><span class="line"> <span class="keyword">if</span> (connectionPool.callAcquirePooledConnection(address, call, routes, <span class="literal">true</span>)) &#123;</span><br><span class="line">   <span class="type">val</span> <span class="variable">result</span> <span class="operator">=</span> call.connection!!</span><br><span class="line">   nextRouteToTry = route</span><br><span class="line">   <span class="comment">// 关闭弃用当前新创建的连接    </span></span><br><span class="line">   newConnection.socket().closeQuietly()</span><br><span class="line">   eventListener.connectionAcquired(call, result)</span><br><span class="line">   <span class="keyword">return</span> result</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 新连接放入到连接池中</span></span><br><span class="line"> <span class="keyword">synchronized</span>(newConnection) &#123;</span><br><span class="line">   connectionPool.put(newConnection)</span><br><span class="line">   call.acquireConnectionNoEvents(newConnection)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="连接池管理"><a href="#连接池管理" class="headerlink" title="连接池管理"></a>连接池管理</h4><p>ConnectionPool 初始画有两个构造函数，需要传入一个代理对象<code>RealConnectionPool</code>，主要功能都由<code>RealConnectionPool</code>完成。</p>
<p><code>maxIdleConnections = 5</code> 表示连接池中最大空闲连接为5个。</p>
<p><code>keepAliveDuration = 5</code>表示连接池中连接的最长空闲时间为5分钟。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConnectionPool</span> internal <span class="title function_">constructor</span><span class="params">(</span></span><br><span class="line"><span class="params">  internal val delegate: RealConnectionPool</span></span><br><span class="line"><span class="params">)</span> &#123;	</span><br><span class="line">  constructor(</span><br><span class="line">    maxIdleConnections: Int,</span><br><span class="line">    keepAliveDuration: Long,</span><br><span class="line">    timeUnit: TimeUnit</span><br><span class="line">  ) : <span class="built_in">this</span>(RealConnectionPool(</span><br><span class="line">      taskRunner = TaskRunner.INSTANCE,</span><br><span class="line">      maxIdleConnections = maxIdleConnections,</span><br><span class="line">      keepAliveDuration = keepAliveDuration,</span><br><span class="line">      timeUnit = timeUnit</span><br><span class="line">  ))</span><br><span class="line">  constructor() : <span class="built_in">this</span>(<span class="number">5</span>, <span class="number">5</span>, TimeUnit.MINUTES)</span><br><span class="line">  <span class="comment">/** Returns the number of idle connections in the pool. */</span></span><br><span class="line">  fun <span class="title function_">idleConnectionCount</span><span class="params">()</span>: Int = delegate.idleConnectionCount()</span><br><span class="line">  <span class="comment">/** Returns total number of connections in the pool. */</span></span><br><span class="line">  fun <span class="title function_">connectionCount</span><span class="params">()</span>: Int = delegate.connectionCount()</span><br><span class="line">  <span class="comment">/** Close and remove all idle connections in the pool. */</span></span><br><span class="line">  fun <span class="title function_">evictAll</span><span class="params">()</span> &#123;</span><br><span class="line">    delegate.evictAll()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>会先将<code>connection</code>添加到线程安全的队列<code>connections</code>中，然后添加到任务队列中，执行连接清理任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealConnectionPool</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">val</span> <span class="variable">connections</span> <span class="operator">=</span> ConcurrentLinkedQueue&lt;RealConnection&gt;()</span><br><span class="line"><span class="keyword">private</span> val cleanupQueue: TaskQueue = taskRunner.newQueue()</span><br><span class="line"><span class="keyword">private</span> <span class="type">val</span> <span class="variable">cleanupTask</span> <span class="operator">=</span> object : Task(<span class="string">&quot;$okHttpName ConnectionPool&quot;</span>) &#123;</span><br><span class="line">  override fun <span class="title function_">runOnce</span><span class="params">()</span> = cleanup(System.nanoTime())</span><br><span class="line">&#125;</span><br><span class="line">fun <span class="title function_">put</span><span class="params">(connection: RealConnection)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.assertThreadHoldsLock()</span><br><span class="line">  connections.add(connection)</span><br><span class="line">  cleanupQueue.schedule(cleanupTask)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>task.runOnce()</code> 即 <code>RealConnectionPool.cleanup()</code>方法执行清理任务。</p>
<p>先遍历任务队列中的任务，正在使用的连接跳过，如果有空闲连接，则获取一个空闲时间最长的连接。</p>
<ul>
<li>队列中空闲连接已经超过 5 个，则移除空闲时间最长的连接。</li>
<li>连接空闲时间超过 5 分钟 则直接移除</li>
<li>连接空闲时间没有超过 5 分钟，比如只有 3 分钟，则记录剩余时间，2 分钟之后再调用<code>afterRun()</code>再执行。</li>
<li>没有空闲连接，但有正在使用的连接，则等5分钟之后再检查。</li>
<li>没有连接，则退出清理任务。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TaskRunner</span></span><br><span class="line"><span class="keyword">private</span> fun <span class="title function_">runTask</span><span class="params">(task: Task)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.assertThreadDoesntHoldLock()</span><br><span class="line">  <span class="type">val</span> <span class="variable">currentThread</span> <span class="operator">=</span> Thread.currentThread()</span><br><span class="line">  <span class="type">val</span> <span class="variable">oldName</span> <span class="operator">=</span> currentThread.name</span><br><span class="line">  currentThread.name = task.name</span><br><span class="line">  <span class="type">var</span> <span class="variable">delayNanos</span> <span class="operator">=</span> -<span class="number">1L</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    delayNanos = task.runOnce()</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">      afterRun(task, delayNanos)</span><br><span class="line">    &#125;</span><br><span class="line">    currentThread.name = oldName</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RealConnectionPool</span></span><br><span class="line">fun <span class="title function_">cleanup</span><span class="params">(now: Long)</span>: Long &#123;</span><br><span class="line">  <span class="type">var</span> <span class="variable">inUseConnectionCount</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">  <span class="type">var</span> <span class="variable">idleConnectionCount</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> longestIdleConnection: RealConnection? = <span class="literal">null</span></span><br><span class="line">  <span class="type">var</span> <span class="variable">longestIdleDurationNs</span> <span class="operator">=</span> Long.MIN_VALUE</span><br><span class="line">  <span class="comment">// Find either a connection to evict, or the time that the next eviction is due.</span></span><br><span class="line">  <span class="keyword">for</span> (connection in connections) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(connection) &#123;</span><br><span class="line">      <span class="comment">// 检查连接是否正在使用</span></span><br><span class="line">      <span class="keyword">if</span> (pruneAndGetAllocationCount(connection, now) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        inUseConnectionCount++</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是空闲连接  </span></span><br><span class="line">        idleConnectionCount++</span><br><span class="line">        <span class="comment">// 计算空闲时间</span></span><br><span class="line">        <span class="type">val</span> <span class="variable">idleDurationNs</span> <span class="operator">=</span> now - connection.idleAtNs</span><br><span class="line">         <span class="comment">// 获取最长空闲时间的连接</span></span><br><span class="line">        <span class="keyword">if</span> (idleDurationNs &gt; longestIdleDurationNs) &#123;</span><br><span class="line">          longestIdleDurationNs = <span class="type">idleDurationNs</span></span><br><span class="line">          <span class="variable">longestIdleConnection</span> <span class="operator">=</span> connection</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          Unit</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  when &#123;</span><br><span class="line">    <span class="comment">// 如果推举的连接最长闲置时间 &gt; 5分钟 或者 空闲连接数超过 5 个，则移除它</span></span><br><span class="line">    longestIdleDurationNs &gt;= <span class="built_in">this</span>.keepAliveDurationNs</span><br><span class="line">        || idleConnectionCount &gt; <span class="built_in">this</span>.maxIdleConnections -&gt; &#123;</span><br><span class="line">      <span class="comment">// We&#x27;ve chosen a connection to evict. Confirm it&#x27;s still okay to be evict, then close i</span></span><br><span class="line">      <span class="type">val</span> <span class="variable">connection</span> <span class="operator">=</span> longestIdleConnection!!</span><br><span class="line">      <span class="keyword">synchronized</span>(connection) &#123;</span><br><span class="line">        <span class="keyword">if</span> (connection.calls.isNotEmpty()) <span class="keyword">return</span> <span class="number">0L</span> <span class="comment">// No longer idle.</span></span><br><span class="line">        <span class="keyword">if</span> (connection.idleAtNs + longestIdleDurationNs != now) <span class="keyword">return</span> <span class="number">0L</span> <span class="comment">// No longer oldest.</span></span><br><span class="line">        connection.noNewExchanges = <span class="literal">true</span></span><br><span class="line">        connections.remove(longestIdleConnection)</span><br><span class="line">      &#125;</span><br><span class="line">      connection.socket().closeQuietly()</span><br><span class="line">      <span class="keyword">if</span> (connections.isEmpty()) cleanupQueue.cancelAll()</span><br><span class="line">      <span class="comment">// Clean up again immediately.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0L</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果空闲连接没有超过5分钟，则计算还有多久。</span></span><br><span class="line">    idleConnectionCount &gt; <span class="number">0</span> -&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> keepAliveDurationNs - longestIdleDurationNs</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有正在使用的连接则等5分钟后再检查  </span></span><br><span class="line">    inUseConnectionCount &gt; <span class="number">0</span> -&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> keepAliveDurationNs</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">      <span class="comment">// 如果没有连接，则等有连接了再说，退出任务</span></span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h5 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h5><p><code>newConnection.connect()</code>中先判断是否支持http tunnel，如果支持调用<code>connectTunnel()</code>。</p>
<p>如果是常用的HTTP连接，调用<code>connectSocket()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealConnection</span></span><br><span class="line">fun <span class="title function_">connect</span><span class="params">(</span></span><br><span class="line"><span class="params">  connectTimeout: Int,</span></span><br><span class="line"><span class="params">  readTimeout: Int,</span></span><br><span class="line"><span class="params">  writeTimeout: Int,</span></span><br><span class="line"><span class="params">  pingIntervalMillis: Int,</span></span><br><span class="line"><span class="params">  connectionRetryEnabled: Boolean,</span></span><br><span class="line"><span class="params">  call: Call,</span></span><br><span class="line"><span class="params">  eventListener: EventListener</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">  check(protocol == <span class="literal">null</span>) &#123; <span class="string">&quot;already connected&quot;</span> &#125;</span><br><span class="line">  <span class="keyword">var</span> routeException: RouteException? = <span class="literal">null</span></span><br><span class="line">  <span class="type">val</span> <span class="variable">connectionSpecs</span> <span class="operator">=</span> route.address.connectionSpecs</span><br><span class="line">  <span class="type">val</span> <span class="variable">connectionSpecSelector</span> <span class="operator">=</span> ConnectionSpecSelector(connectionSpecs)</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (route.requiresTunnel()) &#123;</span><br><span class="line">        <span class="comment">// 建立httpTunnel</span></span><br><span class="line">        connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener)</span><br><span class="line">        <span class="keyword">if</span> (rawSocket == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// We were unable to connect the tunnel but properly closed down our resources.</span></span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 连接socket  </span></span><br><span class="line">        connectSocket(connectTimeout, readTimeout, call, eventListener)</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="comment">// 建立tls、http连接   </span></span><br><span class="line">      establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener)</span><br><span class="line">      eventListener.connectEnd(call, route.socketAddress, route.proxy, protocol)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">      socket?.closeQuietly()</span><br><span class="line">      rawSocket?.closeQuietly()</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果是直连，调用<code>socketFactory.createSocket()</code>，<code>rawSocket</code>用于保存Socket 对象，调用<code>connectSocket()</code>建立TCP连接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealConnection</span></span><br><span class="line"><span class="keyword">private</span> fun <span class="title function_">connectSocket</span><span class="params">(</span></span><br><span class="line"><span class="params">  connectTimeout: Int,</span></span><br><span class="line"><span class="params">  readTimeout: Int,</span></span><br><span class="line"><span class="params">  call: Call,</span></span><br><span class="line"><span class="params">  eventListener: EventListener</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">  <span class="type">val</span> <span class="variable">proxy</span> <span class="operator">=</span> route.proxy</span><br><span class="line">  <span class="type">val</span> <span class="variable">address</span> <span class="operator">=</span> route.address</span><br><span class="line">  <span class="type">val</span> <span class="variable">rawSocket</span> <span class="operator">=</span> when (proxy.type()) &#123;</span><br><span class="line">    Proxy.Type.DIRECT, Proxy.Type.HTTP -&gt; address.socketFactory.createSocket()!!</span><br><span class="line">    <span class="keyword">else</span> -&gt; Socket(proxy)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.rawSocket = rawSocket</span><br><span class="line">  eventListener.connectStart(call, route.socketAddress, proxy)</span><br><span class="line">  rawSocket.soTimeout = readTimeout</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Platform.get().connectSocket(rawSocket, route.socketAddress, connectTimeout)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e: ConnectException) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ConnectException(<span class="string">&quot;Failed to connect to $&#123;route.socketAddress&#125;&quot;</span>).apply &#123;</span><br><span class="line">      initCause(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>如果Socket创建TCP连接成功，调用<code>establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener)</code></p>
<p>分为两种情况，HTTP连接 和 HTTPS连接。</p>
<ul>
<li>HTTP连接，HTTP1.0或1.1的协议则不需要做什么，直接返回<code>rawSocket</code>，如果支持HTTP2协议则调用<code>startHttp2()</code>,则会写入<code>&gt;&gt; CONNECTION PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n</code> 开启HTTP2 连接。</li>
<li>HTTPS连接，先会调用<code>connectTls()</code> 建立TLS连接，然后再判断支持需要开启HTTP2连接。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealConnection</span></span><br><span class="line"><span class="keyword">private</span> fun <span class="title function_">establishProtocol</span><span class="params">(</span></span><br><span class="line"><span class="params">  connectionSpecSelector: ConnectionSpecSelector,</span></span><br><span class="line"><span class="params">  pingIntervalMillis: Int,</span></span><br><span class="line"><span class="params">  call: Call,</span></span><br><span class="line"><span class="params">  eventListener: EventListener</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (route.address.sslSocketFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Protocol .H2_PRIOR_KNOWLEDGE in route.address.protocols) &#123;</span><br><span class="line">      socket = <span class="type">rawSocket</span></span><br><span class="line">      <span class="variable">protocol</span> <span class="operator">=</span> Protocol.H2_PRIOR_KNOWLEDGE</span><br><span class="line">      <span class="title function_">startHttp2</span><span class="params">(pingIntervalMillis)</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    socket = <span class="type">rawSocket</span></span><br><span class="line">    <span class="variable">protocol</span> <span class="operator">=</span> Protocol.HTTP_1_1</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  eventListener.secureConnectStart(call)</span><br><span class="line">  connectTls(connectionSpecSelector)</span><br><span class="line">  eventListener.secureConnectEnd(call, handshake)</span><br><span class="line">  <span class="keyword">if</span> (protocol === Protocol.HTTP_2) &#123;</span><br><span class="line">    startHttp2(pingIntervalMillis)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="获取HTTP编解码器"><a href="#获取HTTP编解码器" class="headerlink" title="获取HTTP编解码器"></a>获取HTTP编解码器</h4><p>当成功获取可用连接后，会调用<code>resultConnection.newCodec()</code>创建HTTP编解码器。</p>
<p>由于HTTP1.0 或 1.1 和 HTTP2 的报文格式不同，因此根据HTTP协议有<code>Http1ExchangeCodec</code> 和  <code>Http2ExchangeCodec</code> 两种编解码器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">internal fun <span class="title function_">newCodec</span><span class="params">(client: OkHttpClient, chain: RealInterceptorChain)</span>: ExchangeCodec &#123;</span><br><span class="line">  <span class="type">val</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="built_in">this</span>.socket!!</span><br><span class="line">  <span class="type">val</span> <span class="variable">source</span> <span class="operator">=</span> <span class="built_in">this</span>.source!!</span><br><span class="line">  <span class="type">val</span> <span class="variable">sink</span> <span class="operator">=</span> <span class="built_in">this</span>.sink!!</span><br><span class="line">  <span class="type">val</span> <span class="variable">http2Connection</span> <span class="operator">=</span> <span class="built_in">this</span>.http2Connection</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">if</span> (http2Connection != <span class="literal">null</span>) &#123;</span><br><span class="line">    Http2ExchangeCodec(client, <span class="built_in">this</span>, chain, http2Connection)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    socket.soTimeout = chain.readTimeoutMillis()</span><br><span class="line">    source.timeout().timeout(chain.readTimeoutMillis.toLong(), MILLISECONDS)</span><br><span class="line">    sink.timeout().timeout(chain.writeTimeoutMillis.toLong(), MILLISECONDS)</span><br><span class="line">    Http1ExchangeCodec(client, <span class="built_in">this</span>, source, sink)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Http1ExchangeCodec 会将headers 中的字段编码为 HTTP的请求报文格式，比如<code>Host: www.baidu.com\r\n</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Http1ExchangeCodec</span></span><br><span class="line">fun <span class="title function_">writeRequest</span><span class="params">(headers: Headers, requestLine: String)</span> &#123;</span><br><span class="line">  check(state == STATE_IDLE) &#123; <span class="string">&quot;state: $state&quot;</span> &#125;</span><br><span class="line">  sink.writeUtf8(requestLine).writeUtf8(<span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">  <span class="keyword">for</span> (i in <span class="number">0</span> until headers.size) &#123;</span><br><span class="line">    sink.writeUtf8(headers.name(i))</span><br><span class="line">        .writeUtf8(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">        .writeUtf8(headers.value(i))</span><br><span class="line">        .writeUtf8(<span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  sink.writeUtf8(<span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">  state = STATE_OPEN_REQUEST_BODY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>HTTP2 使用二进制分帧<code>Steam</code>，由</p>
<ul>
<li><strong>帧长度</strong></li>
<li><strong>帧类型</strong>(HEADERS 帧和 DATA 帧属于数据帧，存放的是 HTTP 报文，而 SETTINGS、PING、PRIORITY 等则是用来管理流的控制帧。)**</li>
<li>帧标志（ND_HEADERS<strong>表示头数据结束，相当于 HTTP&#x2F;1 里头后的空行（“\r\n”），</strong>END_STREAM**表示单方向数据发送结束（即 EOS，End of Stream），相当于 HTTP&#x2F;1 里 Chunked 分块结束标志（“0\r\n\r\n”））</li>
<li><strong>流标识符</strong>，也就是帧所属的“流”，接收方使用它就可以从乱序的帧里识别出具有相同流 ID 的帧序列，按顺序组装起来就实现了虚拟的“流”</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Http2ExchangeCodec </span></span><br><span class="line">override fun <span class="title function_">writeRequestHeaders</span><span class="params">(request: Request)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (stream != <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="type">val</span> <span class="variable">hasRequestBody</span> <span class="operator">=</span> request.body != <span class="literal">null</span></span><br><span class="line">  <span class="type">val</span> <span class="variable">requestHeaders</span> <span class="operator">=</span> http2HeadersList(request)</span><br><span class="line">  stream = http2Connection.newStream(requestHeaders, hasRequestBody)</span><br><span class="line">  <span class="comment">// We may have been asked to cancel while creating the new stream and sending the request</span></span><br><span class="line">  <span class="comment">// headers, but there was still no stream to close.</span></span><br><span class="line">  <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">    stream!!.closeLater(ErrorCode.CANCEL)</span><br><span class="line">    <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  stream!!.readTimeout().timeout(chain.readTimeoutMillis.toLong(), TimeUnit.MILLISECONDS)</span><br><span class="line">  stream!!.writeTimeout().timeout(chain.writeTimeoutMillis.toLong(), TimeUnit.MILLISECONDS)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>至此ConnectInterceptor工作完成，将HTTP编解码器，建立成功的连接，都放到<code>Exchange(this, eventListener, exchangeFinder, codec)</code>对象中。</p>
<p>Exchanage 具备了发送请求接收响应，对请求参数编码和对响应参数接码的功能，可以完成一次数据交换了。</p>
<h3 id="6、NetworkInterceptor-网络调试拦截器"><a href="#6、NetworkInterceptor-网络调试拦截器" class="headerlink" title="6、NetworkInterceptor 网络调试拦截器"></a>6、NetworkInterceptor 网络调试拦截器</h3><p><code>addNetworkInterceptor(Interceptor)</code> 和 前面介绍的 <code>addInterceptor(Interceptor)</code> 创建的拦截器行为逻辑使用都一样，唯一区别是位置不同。</p>
<p>它在发送请求拦截器前，重试重定向拦截器后，它可以获取每个请求和响应的完整原始数据（包括重定向以及重试的⼀些中间请求和响应)，主要用于做网络调试。</p>
<h3 id="7、CallServerInterceptor"><a href="#7、CallServerInterceptor" class="headerlink" title="7、CallServerInterceptor"></a>7、CallServerInterceptor</h3><p>它负责实质的请求与响应的 I&#x2F;O 操作，即往 Socket ⾥写⼊请求数据，和从 Socket ⾥读取响应数据。</p>
<p>主要通过<code>Exchange</code>实现，通过调用<code>writeRequestHeaders</code>写入数据、<code>flushRequest()</code>发送请求，<code>readResponseHeaders()</code>读取数据。</p>
<p>最后处理响应结果返回给上个拦截器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CallServerInterceptor</span>(<span class="keyword">private</span> val forWebSocket: Boolean) : Interceptor &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Throws(IOException::class)</span></span><br><span class="line">  override fun <span class="title function_">intercept</span><span class="params">(chain: Interceptor.Chain)</span>: Response &#123;</span><br><span class="line">    <span class="type">val</span> <span class="variable">realChain</span> <span class="operator">=</span> chain as RealInterceptorChain</span><br><span class="line">    <span class="type">val</span> <span class="variable">exchange</span> <span class="operator">=</span> realChain.exchange!!</span><br><span class="line">    <span class="type">val</span> <span class="variable">request</span> <span class="operator">=</span> realChain.request</span><br><span class="line">    <span class="type">val</span> <span class="variable">requestBody</span> <span class="operator">=</span> request.body</span><br><span class="line">    <span class="type">val</span> <span class="variable">sentRequestMillis</span> <span class="operator">=</span> System.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入请求报文</span></span><br><span class="line">    exchange.writeRequestHeaders(request)</span><br><span class="line"></span><br><span class="line">    <span class="type">var</span> <span class="variable">invokeStartEvent</span> <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> responseBuilder: Response.Builder? = <span class="literal">null</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 允许使用请求体，除了HEAD 和 GET请求</span></span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method) &amp;&amp; requestBody != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 客户端有POST数据要上传，可以考虑使用100-continue协议。加入头&#123;&quot;Expect&quot;:&quot;100-continue&quot;&#125;，征询服务器情况，看服务器是否处理POST的数据</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;100-continue&quot;</span>.equals(request.header(<span class="string">&quot;Expect&quot;</span>), ignoreCase = <span class="literal">true</span>)) &#123;</span><br><span class="line">        <span class="comment">// 发送请求  </span></span><br><span class="line">        exchange.flushRequest()</span><br><span class="line">        responseBuilder = exchange.readResponseHeaders(expectContinue = <span class="literal">true</span>)</span><br><span class="line">        exchange.responseHeadersStart()</span><br><span class="line">        invokeStartEvent = <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (responseBuilder == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (requestBody.isDuplex()) &#123;</span><br><span class="line">          <span class="comment">// Prepare a duplex body so that the application can send a request body later.</span></span><br><span class="line">          exchange.flushRequest()</span><br><span class="line">          <span class="type">val</span> <span class="variable">bufferedRequestBody</span> <span class="operator">=</span> exchange.createRequestBody(request, <span class="literal">true</span>).buffer()</span><br><span class="line">          requestBody.writeTo(bufferedRequestBody)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// Write the request body if the &quot;Expect: 100-continue&quot; expectation was met.</span></span><br><span class="line">          <span class="type">val</span> <span class="variable">bufferedRequestBody</span> <span class="operator">=</span> exchange.createRequestBody(request, <span class="literal">false</span>).buffer()</span><br><span class="line">          requestBody.writeTo(bufferedRequestBody)</span><br><span class="line">          bufferedRequestBody.close()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        exchange.noRequestBody()</span><br><span class="line">        <span class="keyword">if</span> (!exchange.connection.isMultiplexed) &#123;</span><br><span class="line">          <span class="comment">// If the &quot;Expect: 100-continue&quot; expectation wasn&#x27;t met, prevent the HTTP/1 connection</span></span><br><span class="line">          <span class="comment">// from being reused. Otherwise we&#x27;re still obligated to transmit the request body to</span></span><br><span class="line">          <span class="comment">// leave the connection in a consistent state.</span></span><br><span class="line">          exchange.noNewExchangesOnConnection()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      exchange.noRequestBody()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (requestBody == <span class="literal">null</span> || !requestBody.isDuplex()) &#123;</span><br><span class="line">      <span class="comment">// 发送请求    </span></span><br><span class="line">      exchange.finishRequest()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (responseBuilder == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 读取返回结果  </span></span><br><span class="line">      responseBuilder = exchange.readResponseHeaders(expectContinue = <span class="literal">false</span>)!!</span><br><span class="line">      <span class="keyword">if</span> (invokeStartEvent) &#123;</span><br><span class="line">        exchange.responseHeadersStart()</span><br><span class="line">        invokeStartEvent = <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">var</span> <span class="variable">response</span> <span class="operator">=</span> responseBuilder</span><br><span class="line">        .request(request)</span><br><span class="line">        .handshake(exchange.connection.handshake())</span><br><span class="line">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build()</span><br><span class="line">    <span class="type">var</span> <span class="variable">code</span> <span class="operator">=</span> response.code</span><br><span class="line">    <span class="title function_">if</span> <span class="params">(code == <span class="number">100</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// Server sent a 100-continue even though we did not request one. Try again to read the actual</span></span><br><span class="line">      <span class="comment">// response status.</span></span><br><span class="line">      responseBuilder = exchange.readResponseHeaders(expectContinue = <span class="literal">false</span>)!!</span><br><span class="line">      <span class="keyword">if</span> (invokeStartEvent) &#123;</span><br><span class="line">        exchange.responseHeadersStart()</span><br><span class="line">      &#125;</span><br><span class="line">      response = responseBuilder</span><br><span class="line">          .request(request)</span><br><span class="line">          .handshake(exchange.connection.handshake())</span><br><span class="line">          .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">          .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">          .build()</span><br><span class="line">      code = response.code</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    exchange.responseHeadersEnd(response)</span><br><span class="line"></span><br><span class="line">    response = <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</span><br><span class="line">      <span class="comment">// Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span></span><br><span class="line">      response.newBuilder()</span><br><span class="line">          .body(EMPTY_RESPONSE)</span><br><span class="line">          .build()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      response.newBuilder()</span><br><span class="line">          .body(exchange.openResponseBody(response))</span><br><span class="line">          .build()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;close&quot;</span>.equals(response.request.header(<span class="string">&quot;Connection&quot;</span>), ignoreCase = <span class="literal">true</span>) ||</span><br><span class="line">        <span class="string">&quot;close&quot;</span>.equals(response.header(<span class="string">&quot;Connection&quot;</span>), ignoreCase = <span class="literal">true</span>)) &#123;</span><br><span class="line">      exchange.noNewExchangesOnConnection()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((code == <span class="number">204</span> || code == <span class="number">205</span>) &amp;&amp; response.body?.contentLength() ?: -<span class="number">1L</span> &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ProtocolException(</span><br><span class="line">          <span class="string">&quot;HTTP $code had non-zero Content-Length: $&#123;response.body?.contentLength()&#125;&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>至此OKHttp请求流程分析完毕，通过 7 大拦截器完成HTTP的请求和响应。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Https%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/08/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Https%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">Https 介绍</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-08-31 15:11:42" itemprop="dateCreated datePublished" datetime="2023-08-31T15:11:42+00:00">2023-08-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-09-11 11:02:55" itemprop="dateModified" datetime="2023-09-11T11:02:55+00:00">2023-09-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <meta name="referrer" content="no-referrer" />

<h1 id="HTTPS-介绍"><a href="#HTTPS-介绍" class="headerlink" title="HTTPS 介绍"></a>HTTPS 介绍</h1><p>HTTP由于是明文传输的，传输信息会被任何中间商所获取、修改、伪装。如果进行线上交易，黑客很容易伪装成交易方获取你的交易信息，比如交易账号、实名信息等，危险财产安全。<br>HTTPS是一种新的应用层协议，默认端口为443，在HTTP的基础上增加了安全性，其他特点都和HTTP相同，相当于HTTP的安全进化版。</p>
<h2 id="HTTPS的安全特性"><a href="#HTTPS的安全特性" class="headerlink" title="HTTPS的安全特性"></a>HTTPS的安全特性</h2><p>HTTPS增加了哪些安全特性保证了数据传输的安全呢？主要有以下4个安全特性：机密性、完整性、身份验证、不可否认。</p>
<h3 id="机密性"><a href="#机密性" class="headerlink" title="机密性"></a>机密性</h3><p>机密性，通过密钥对传输的信息进行加密，只有接收方和发送发知道真实信息，黑客哪怕获取到密文，没有密钥也无法破解，解决HTTP协议中明文数据被黑客获取的问题。</p>
<h3 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h3><p>完整性，验证并保证数据传输的完整。因为发送方传输的数据即使被加密，黑客能通过劫持后能修改密文，接收方如果不能验证完整性，解密之后就是错误的信息，整个通信过程就被破坏了。</p>
<h3 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h3><p>身份验证，验证传输信息双方的真实身份，证明信息确实是可信的人传递的，而不是黑客传来的。</p>
<h3 id="不可否认"><a href="#不可否认" class="headerlink" title="不可否认"></a>不可否认</h3><p>不可否认，不能否认已经发生的行为，发送方给接收方传递了信息，发送方不能说自己没传过。</p>
<h3 id="生活实例"><a href="#生活实例" class="headerlink" title="生活实例"></a>生活实例</h3><p>下面这个生活小例子，说明了这4种安全特性。</p>
<p>小明和小红上课喜欢纸条，但是离得远只能通过小强传递，小强喜欢看他们纸条内容。于是小红和小明放学约定了一个加密规则，对纸条内容进行加密，即使小强看了纸条也不知道啥意思。</p>
<p>小强没办法知道纸条内容，于是恼羞成怒，每次在纸条里面加几个字，导致小红和小明都解密出错误的信息，小红和小明又约定了一个验证完整性的规则，小强以后改了纸条信息也能被发现。</p>
<p>小强没辙了，就假冒小明给小红写纸条，小红不知道，以为小明突然又用明文传输了，于是就给他回了，于是和小强传了一早上纸条，小明的纸条传的纸条都被小强扔了。小红和小明放学一合计被小强耍了，于是又定了一个规则验证双方身份信息，保证纸条不是小强传的。</p>
<p>小强终于老实了，但是小红和小明遇到了问题，小明在纸条里写了周末带小红去欢乐谷，放学了小明突然想起来周末有事，于是不承认对小红说过，小红老生气了，但是纸条被扔了也没办法，就跟小明说这次先原谅你，现在说好以后纸条我们两个都要收好，免得对方赖账。</p>
<h2 id="SSL-TLS协议"><a href="#SSL-TLS协议" class="headerlink" title="SSL&#x2F;TLS协议"></a>SSL&#x2F;TLS协议</h2><p>上面介绍了HTTPS的安全特性，HTTPS依靠SSL协议实现安全特性，保证数据传输的安全。</p>
<p>HTTPS中的”S”指的就是SSL&#x2F;TLS，HTTP下层是TCP&#x2F;IP协议栈，而HTTPS在下层加了SSL&#x2F;TTL协议，先调用专门的安全接口，再把接口处理过的数据传给TCP&#x2F;IP协议栈。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4538003-7d1a7f0d45c91fdc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HTTPS 结构图"></p>
<p>SSL 即安全套接层（Secure Sockets Layer），在 OSI 模型中处于第 5 层（会话层），由网景公司于 1994 年发明，有 v2 和 v3 两个版本，而 v1 因为有严重的缺陷从未公开过。</p>
<p>SSL 发展到 v3 时已经证明了它自身是一个非常好的安全通信协议，于是互联网工程组 IETF 在 1999 年把它改名为 TLS（传输层安全，Transport Layer Security），正式标准化，版本号从 1.0 重新算起，所以 TLS1.0 实际上就是 SSLv3.1。</p>
<p>到今天 TLS 已经发展出了三个版本，分别是 2006 年的 1.1、2008 年的 1.2 和去年（2018）的 1.3，每个新版本都紧跟密码学的发展和互联网的现状，持续强化安全和性能，已经成为了信息安全领域中的权威标准。</p>
<p>目前应用的最广泛的 TLS 是 1.2，而之前的协议（TLS1.1&#x2F;1.0、SSLv3&#x2F;v2）都已经被认为是不安全的，各大浏览器即将在 2020 年左右停止支持，所以接下来的讲解都针对的是 TLS1.2。</p>
<p>浏览器和服务器在使用 TLS 建立连接时需要选择一组恰当的加密算法来实现安全通信，这些算法的组合被称为“密码套件”（cipher suite，也叫加密套件）。</p>
<h3 id="TLS-协议的组成"><a href="#TLS-协议的组成" class="headerlink" title="TLS 协议的组成"></a>TLS 协议的组成</h3><p>TLS 包含几个子协议，你也可以理解为它是由几个不同职责的模块组成，比较常用的有记录协议、警报协议、握手协议、变更密码规范协议等。</p>
<ul>
<li><p><strong>记录协议</strong>（Record Protocol）规定了 TLS 收发数据的基本单位：记录（record）。它有点像是 TCP 里的 segment，所有的其他子协议都需要通过记录协议发出。但多个记录数据可以在一个 TCP 包里一次性发出，也并不需要像 TCP 那样返回 ACK。</p>
</li>
<li><p><strong>警报协议</strong>（Alert Protocol）的职责是向对方发出警报信息，有点像是 HTTP 协议里的状态码。比如，protocol_version 就是不支持旧版本，bad_certificate 就是证书有问题，收到警报后另一方可以选择继续，也可以立即终止连接。</p>
</li>
<li><p><strong>握手协议</strong>（Handshake Protocol）是 TLS 里最复杂的子协议，要比 TCP 的 SYN&#x2F;ACK 复杂的多，浏览器和服务器会在握手过程中协商 TLS 版本号、随机数、密码套件等信息，然后交换证书和密钥参数，最终双方协商得到会话密钥，用于后续的混合加密系统。</p>
</li>
<li><p><strong>变更密码规范协议</strong>（Change Cipher Spec Protocol），它非常简单，就是一个“通知”，告诉对方，后续的数据都将使用加密保护。那么反过来，在它之前，数据都是明文的。</p>
</li>
</ul>
<h2 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h2><p><strong>实现完整性的手段主要是摘要算法（Digest Algorithm），也就是常说的散列函数、哈希函数。摘要算法能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，且不可逆，不能通过摘要字符串推出原数据。</strong></p>
<p>只有输入相同的明文数据经过相同的摘要算法才能得到相同的摘要字符串，哪怕明文数据和之前有一个字符的微小差别，生成的摘要字符串也是不同的。</p>
<p>客户端将请求数据通过摘要算法得出摘要字符串，附加到请求数据后（可以区分请求消息和摘要字符串）。服务端接受到之后，解密取出请求字符串，用相同的摘要算法得出摘要字符串，将两份摘要字符串进行比对，如果相同，则数据完整且没有被修改。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4538003-90b33e252dd30e95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="摘要算法过程"></p>
<p>常用的摘要算法有MD5和SHA-1，能够生成16字节和20字节长度的数字摘要。但这两个算法的安全强度比较低，不够安全，在 TLS 里已经被禁止使用了。</p>
<p>TLS目前推荐使用的SHA-1的后继者——SHA-2。SHA-2 实际上是一系列摘要算法的统称，总共有 6 种，常用的有 SHA224、SHA256、SHA384，分别能够生成 28 字节、32 字节、48 字节的摘要。</p>
<p>TLS使用摘要算法生成摘要字符串，再对摘要字符串用下面的加密方法进行加密，就保证了机密性和完整性。</p>
<h2 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h2><p>TLS&#x2F;SSL中的加密算法组合实现了HTTPS中的安全特性，下面详细介绍这些加密算法。</p>
<h3 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h3><p>对称加密双方约定好一个密钥，称为<strong>会话密钥</strong>，双方通过会话密钥进行加密、解密数据，保证了数据的机密性。<br>网站通过密钥加密数据明文，把密文发送给客户端，客户端收到之后再通过密钥解析密文，获取数据明文。黑客即使拦截了，获取的只是密文，没有密钥就无法破解得出明文。</p>
<p>TLS 里有非常多的对称加密算法可供选择，比如 RC4、DES、3DES、AES、ChaCha20 等，但前三种算法密钥较短，可以暴力破解，被认为是不安全的，通常都禁止使用。目前常用的只有 AES 和 ChaCha20。</p>
<p>AES 的意思是“高级加密标准”（Advanced Encryption Standard），密钥长度可以是 128、192 或 256。它是 DES 算法的替代者，安全强度很高，性能也很好，而且有的硬件还会做特殊优化，所以非常流行，是应用最广泛的对称加密算法，被许多浏览器和服务器所应用。</p>
<p>ChaCha20 是 Google 设计的另一种加密算法，密钥长度固定为 256 位，纯软件运行性能要超过 AES，曾经在移动客户端上比较流行，但 ARMv8 之后也加入了 AES 硬件优化，所以现在不再具有明显的优势，但仍然算得上是一个不错算法。</p>
<h3 id="分组密码模式"><a href="#分组密码模式" class="headerlink" title="分组密码模式"></a>分组密码模式</h3><p>AES、ChaCha20 等对称加密算法只能通过固定长度的密钥加密明文，因此能加密的明文长度是受限制的。如果要加密任意长度的明文，需要将明文进行分组，由对称加密算法迭代分组加密，具体迭代的方式就称为分组迭代模式。<br><img src="https://upload-images.jianshu.io/upload_images/4538003-3156fa0571d246fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="分组加密"></p>
<p>最早有 ECB、CBC、CFB、OFB 等几种分组模式，但都陆续被发现有安全漏洞，所以现在基本都不怎么用了。最新的分组模式被称为 AEAD（Authenticated Encryption with Associated Data），在加密的同时增加了认证的功能，常用的是 GCM、CCM 和 Poly1305。</p>
<p>对称加密算法+分组密码模式，组成TLS协议中加密任意长度明文的方法。比如AES128-GCM，意思是密钥长度为 128 位的 AES 算法，使用的分组模式是 GCM。</p>
<h3 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h3><p>对称加密需要双方持有密钥才能对数据进行加密和解密，这就涉及到密钥传输问题了。如果用明文传输就会被黑客获取，破解密文。如果不用明文，使用对称加密，那么遇到了相同的问题如何传输新密钥，循环往复。<strong>因此密钥传输不能使用对称加密，而采用非对称加密。</strong></p>
<p>非对称加密基本原理就是先创建一个私钥，只能自己拥有，再用私钥创建一个公钥，是公开的任何人都可以获取。公钥和私钥有个特别的“单向”性，公钥加密的数据只能私钥解密，私钥加密的数据只能公钥解密。</p>
<p>所以非对称加密有两大作用：</p>
<p><strong>加密数据，公钥加密数据，私钥解密数据</strong>。服务端生成一对私钥和公钥，将公钥传给客户端，客户端用公钥加密数据后传给服务端，服务端在用私钥解密。即使中间商获取了公钥，公钥无法解密数据。</p>
<p><strong>数字签名，私钥加密数据，公钥解密数据</strong>。数字签名作用就是做身份验证，服务端用私钥加密数据，客户端能用公钥解密，由于私钥只有服务端一个人有，中间商获取不到，所以就可以证明数据确实是服务端发送。<br>就好比人民币的防伪标志，每个人都知道怎么看防伪标志，但是只有银行拥有这个技术，所以就可以证明钱确实是银行印的。</p>
<p>非对称加密算法的设计要比对称算法难得多，在 TLS 里只有很少的几种，比如 DH、DSA、RSA、ECC 等。</p>
<p>RSA 可能是其中最著名的一个，几乎可以说是非对称加密的代名词，它的安全性基于“整数分解”的数学难题，使用两个超大素数的乘积作为生成密钥的材料，想要从公钥推算出私钥是非常困难的。</p>
<p>10 年前 RSA 密钥的推荐长度是1024，但随着计算机运算能力的提高，现在1024已经不安全，普遍认为至少要2048位。</p>
<p>ECC（Elliptic Curve Cryptography）是非对称加密里的“后起之秀”，它基于“椭圆曲线离散对数”的数学难题，使用特定的曲线方程和基点生成公钥和私钥。</p>
<p>椭圆曲线离散对数，在椭圆上使用固定的基点，从基点出发做连续次数的折射，最终到达椭圆上的另外一个点。折射次数作为私钥，终点作为公钥。即使知道了基点和终点，也很难反推出经过多少次折射，因为私钥安全性很高。</p>
<p>子算法 ECDHE 用于密钥交换，ECDSA 用于数字签名。</p>
<h3 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h3><p>既然非对称加密可以解决公钥加密问题，为什么不用非对称加密算法加密信息呢？<strong>因为非对称加密算法加密效率很低。</strong>如下所示，对称加密算法AES128是13MB&#x2F;s，非对称加密算法RSA2048是15KB&#x2F;s，加密效率相差几百倍。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">aes_128_cbc enc/dec 1000 times : 0.97ms, 13.11MB/s</span><br><span class="line"></span><br><span class="line">rsa_1024 enc/dec 1000 times : 138.59ms, 93.80KB/s</span><br><span class="line">rsa_1024/aes ratio = 143.17</span><br><span class="line"></span><br><span class="line">rsa_2048 enc/dec 1000 times : 840.35ms, 15.47KB/s</span><br><span class="line">rsa_2048/aes ratio = 868.13</span><br></pre></td></tr></table></figure>

<p>在TLS协议把对称加密算法和非对称加密算法相结合。</p>
<p><strong>服务端和客户端用非对称加密协商出一套对称密钥，发送方用对称密钥加密数据，接收方用对称密钥解密数据。</strong></p>
<p>混合加密就解决了对称加密算法的密钥交换问题，而且安全和性能兼顾，完美地实现了机密性。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4538003-c5b16392678809da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="混合加密过程"></p>
<h2 id="数字签名在HTTPS中应用"><a href="#数字签名在HTTPS中应用" class="headerlink" title="数字签名在HTTPS中应用"></a>数字签名在HTTPS中应用</h2><p><strong>数字签名的作用为验证身份</strong>，主要分为单向认证和双向认证目前主要使用单项认证。</p>
<h3 id="单向认证"><a href="#单向认证" class="headerlink" title="单向认证"></a>单向认证</h3><p>单向认证在TLS协议中只对服务端的身份进行验证，而客户端的身份在服务端应用层上通过账号、密码等信息进行验证。</p>
<p>所以只要服务端生成公钥和私钥，公钥保存在数字证书中发送给客户端，发送数据并通过公钥对摘要字符串进行加密。客户端则不需要生成公钥和私钥，对数据数字签名。</p>
<h3 id="双向验证"><a href="#双向验证" class="headerlink" title="双向验证"></a>双向验证</h3><p>双向认证是指在TLS协议中认证双方的身份。客户端和服务端都要生成公钥和私钥，然后互传数字证书，传输数据是要用自己的私钥对摘要字符串加密，收到之后用对方的公钥解密认证身份。</p>
<p><strong>数字签名主要应用在公钥传输和加密数据传输。</strong></p>
<h3 id="加密数据传输"><a href="#加密数据传输" class="headerlink" title="加密数据传输"></a>加密数据传输</h3><p>上述通过加密算法和摘要算法实现了机密性和完整性，黑客无法获取和修改明文数据了，但是黑客可以抓取到发送的密文，然后伪装客户端像服务器发起请求，比如抓取到客户端转账请求的密文，发送给服务器，服务器无法验证具体的身份，就会执行转账请求。</p>
<p>所以服务端会对数据先进行 hash 计算等到 hash code，然后再用私钥加密 hash code。</p>
<h3 id="公钥传输"><a href="#公钥传输" class="headerlink" title="公钥传输"></a>公钥传输</h3><p>服务端是明文传输公钥给客户端，为什么使用明文传输呢，因为如果对公钥加密又会陷入同样的问题，需要对新密钥进行加密，又是循环往复。</p>
<p>选择使用明文传输，公钥信息就会被黑客获取，然后伪造假的公钥发给客户端，客户端收到假的公钥，用假公钥加密会话密钥，导致服务端无法解密，整个通信过程被破坏。</p>
<p>服务端传输 A公钥给客户端时，服务端需要用 B私钥 对 A公钥进行加密生成数字签名，并且将B公钥传给客户端。</p>
<p>客户端持有B公钥 如果能解密，说明 A公钥确实来自服务端，因为B私钥只有服务端有其他中间商都没有。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4538003-ae17cfa53129c2cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>那么问题来了，我怎么确保B公钥来自服务端呢？于是改成下面这个样子。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4538003-e3d8878bd85455d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>那又要保证C公钥，如此循环下去永无止境，<strong>因此引入了CA(证书认证机构)和数字证书。</strong></p>
<h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><p><strong>数字证书的作用就是保证服务器公钥确实是服务器发的，而不是被中间商伪造。</strong></p>
<p>CA即为证书认证机构，为服务器的公钥签字担保，保证公钥是真的。相当于我们身份证上的签发单位公安局，公安局的公信力很高，所以大家都相信身份证信息是真的。</p>
<p><strong>数字证书由证书信息和数字签名组成。</strong><br>证书信息主要包括<strong>服务器公钥</strong>，<strong>服务器主机名</strong>，<strong>证书的所有者</strong>类似身份证上的姓名和身份证号，<strong>颁发机构</strong>类似身份证上给办理的公安局，<strong>证书有效期</strong>类似身份证上的有效期等。</p>
<ol>
<li>服务端会发送 CSR(证书签名请求,包括传递的公钥和证书信息)到 CA。</li>
<li>CA 会验证 CSR 中的信息，比如服务器主机名是否存在等。</li>
<li>数字签名，使用摘要算法对 CSR 信息做 Hash 计算，得到一个 Hash 值，使用 CA 私钥加密摘要值。</li>
<li>这个证书包含了公钥、证书信息和签名信息。</li>
</ol>
<p>中间证书都应由其上一级证书（即其父证书的 CA）签名。客户端会使用父证书的公钥来验证中间证书的签名。<br>最终信任链顶端的CA没人给他签名了，这个就叫“自签名证书”或者“根证书”。全球大的CA只有几个，操作系统和浏览器都内置了各大 CA 的根证书，所以根证书的签名验证是浏览器或操作系统完成。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4538003-79d82b8dafe3f6ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="证书"></p>
<p>就像你不相信派出所，可以打电话问市公安局确认派出所的合法性，不相信市公安局，打电话给省公安厅确认市公安局的合法性，往上最终到达公安部。公安部全中国就一个，你不信也得信。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4538003-d01fd359e5910d50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h3 id="验证过程"><a href="#验证过程" class="headerlink" title="验证过程"></a>验证过程</h3><p>服务器把证书传给浏览器，浏览器读取证书中的证书所有者、有效期等信息进行一一校验。<strong>验证host是否和客户端一致</strong>，防止中间商发其他网站的证书，这样即使签名验证正确，但是公钥不是服务端发来的那个。</p>
<p><strong>校验证书签名</strong>。</p>
<ol>
<li>从预装在浏览器或操作系统的根证书内的公钥，验证一级中间证书。</li>
<li>一级中间证书拿当前证书公钥，再去验证二级证书，循环往复。</li>
<li>最终验证得出证书没有问题，最后一层证书的公钥即为服务端公钥。</li>
</ol>
<p><strong>数字证书可以保证非对称加密的公钥的准确性，那直接把对称加密的密钥放在数字证书中不就好了吗？</strong><br>显然不行，因为每个服务端的CA证书都是申请好固定的，但是对称加密的密钥，一次会话结束，就发生变化了，并且服务端和客户端每个连接的对称加密的密钥都是不同的。<br>不能每次生成一个新的密钥就去申请一个数字证书吧。</p>
<h2 id="TLS1-2握手过程"><a href="#TLS1-2握手过程" class="headerlink" title="TLS1.2握手过程"></a>TLS1.2握手过程</h2><p>TLS 由记录协议、握手协议、警告协议、变更密码规范协议、扩展协议等几个子协议组成，综合使用了对称加密、非对称加密、身份认证等许多密码学前沿技术，下面介绍是如何将子协议和密码学运用在握手过程中。</p>
<p>下面介绍TLS协议中两种握手方式，区别在于使用不同的非对称加密算法，用于交换对称加密的密钥。一种是ECDHE非对称加密算法，一种是RSA非对称加密算法。</p>
<h3 id="TLS使用ECDHE算法握手过程"><a href="#TLS使用ECDHE算法握手过程" class="headerlink" title="TLS使用ECDHE算法握手过程"></a>TLS使用ECDHE算法握手过程</h3><p>握手过程如下图所示，我们使用 WireShark 抓包分析一下，具体如何抓包可以看这篇文章<a target="_blank" rel="noopener" href="https://blog.csdn.net/nimasike/article/details/80887436">配置Wireshark抓取https数据包 解密SSL</a>。</p>
<p>通过分析抓包，TLS算法最多经过两次消息往返（4 个消息）就可以完成握手，然后就可以在安全的通信环境里发送 HTTP 报文，实现 HTTPS 协议。</p>
<h4 id="1-建立连接"><a href="#1-建立连接" class="headerlink" title="1. 建立连接"></a>1. 建立连接</h4><p>通过TCP协议3次握手建立连接。</p>
<h4 id="2-客户端Client-Hello"><a href="#2-客户端Client-Hello" class="headerlink" title="2. 客户端Client Hello"></a>2. 客户端Client Hello</h4><p>客户端会先向服务器发送请求，可以理解成打招呼。<br>客户端通过<code>Client Hello</code>类型的握手子协议，主要发送以下信息给服务器：</p>
<p>Version：TLS的版本号。</p>
<p>Random：客户端随机数用于生成主密钥，会话密钥基于主密钥进行扩展。</p>
<p>Cipher Suites：客户端支持的密钥套件，密钥套件定义一个密钥交换算法、一个数据密算法、一个身份认证（MAC）算法，以及一个伪随机函数（PRF）。<br>比如<code>Cipher Suite: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384(0xc030)</code>：</p>
<ul>
<li><code>TLS</code>表示TLS协议。</li>
<li><code>ECDHE</code>作为密钥交换算法。</li>
<li><code>RSA</code>作为身份认证算法，用于加密摘要字符串。</li>
<li><code>SHA384</code>作为伪随机算法或摘要算法，摘要算法生成摘要字符串，伪随机算法用于生成主钥，密钥交换部分会详细介绍。</li>
</ul>
<p>Extension: 扩展字段。扩展字段可以在不修改协议本身的条件下为TLS协议增加功能。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4538003-407bf196e9a1b023.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Clienet Hello报文"></p>
<h4 id="3-服务端Server-Hello、Certificate、Server-Key-Exchange"><a href="#3-服务端Server-Hello、Certificate、Server-Key-Exchange" class="headerlink" title="3.服务端Server Hello、Certificate、Server Key Exchange"></a>3.服务端Server Hello、Certificate、Server Key Exchange</h4><p>TLS中的记录子协议，其他子协议作为一个记录单位，一个TCP包可以发送多个握手协议类型。服务器接收到客户端发来<code>Client Hello</code>，一次性返回以下4个握手子协议类型数据。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4538003-775e8ce57c68427b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="记录子协议"></p>
<h5 id="Server-Hello"><a href="#Server-Hello" class="headerlink" title="Server Hello"></a>Server Hello</h5><p>比对TLS版本后，服务器返回 Random(随机数)用于生成主密钥，从客户端密码套间中确定一个在HTTPS中使用的密码套件，这里确定为 <code>TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 (0xc030)</code>，还有其他的扩展参数。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4538003-e62f421283f195ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Server Hello报文"></p>
<h5 id="Server-Certificate"><a href="#Server-Certificate" class="headerlink" title="Server Certificate"></a>Server Certificate</h5><p>服务端用已确定密码套件中的<code>RSA</code>算法生成公钥和私钥，把服务端公钥放入数字证书中，并对数字证书进行签名，发送给客户端，确保服务器身份。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4538003-117092e09de75d42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Certificate报文"></p>
<h5 id="Server-Key-Exchange"><a href="#Server-Key-Exchange" class="headerlink" title="Server Key Exchange"></a>Server Key Exchange</h5><p>因为选择了 ECDHE 算法作为密钥交换算法。</p>
<p>ECDHE算法详细介绍可以看极客时间的透视HTTP协议专栏中的<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/148188">DHE&#x2F;ECDHE算法的原理</a>。</p>
<p>ECDHE（椭圆曲线Diffie-Hellman Ephemeral）算法生成密钥的过程如下：</p>
<ol>
<li><p>选择一个椭圆曲线：ECDHE首先需要选择一个椭圆曲线。这个曲线通常是预定义的，并且在所有使用ECDHE的设备中都是一样的。</p>
</li>
<li><p>生成临时密钥对：服务端和客户端各自生成一对临时的 ECDH 公私钥。这对公私钥只会用于当前的 SSL&#x2F;TLS 会话，会话结束后就会被丢弃。</p>
</li>
<li><p>交换公钥：服务端将其临时 ECDH 公钥<code>server_ephemeral_key</code>发送给客户端，客户端也将其临时 ECDH 公钥发送给服务端。这两个公钥都是明文发送的。</p>
</li>
<li><p>计算共享密钥：服务端使用自己的临时ECDH私钥和客户端的临时 ECDH 公钥进行计算，得到一个共享密钥；客户端也使用自己的临时 ECDH 私钥和服务端的临时 ECDH 公钥进行计算，也得到一个共享密钥。由于 ECDH 算法的特性，这两个共享密钥是相同的。</p>
</li>
<li><p>生成会话密钥：最后，这个共享密钥会被用来生成会话密钥，用于后续的通信加密。</p>
</li>
<li><p>P1 和 P2 的值相同，作为各自的<code>pre-master</code>生成主密钥。就好比 1+10&#x3D;11,2+10&#x3D;12, 交换 11 和 12，1+12&#x3D;2+11。</p>
</li>
</ol>
<p>使用 ECDHE 的优点是，即使有人拦截到了临时的 ECDH 公钥，也无法计算出共享密钥，因为计算共享密钥需要知道临时的 ECDH 私钥，而这个私钥从来不在网络中传输。<br>另外，由于每个会话都使用不同的临时 ECDH 公私钥，所以ECDHE提供了前向保密，即使服务端的长期私钥被泄露，也不会影响之前的SSL&#x2F;TLS会话的安全性。</p>
<p><strong>服务端通过椭圆曲线生成临时 ECDH 公钥，并加上自己的私钥签名，保证身份验证和完整性，<code>server_key_params</code>本身并不会被加密</strong>。</p>
<p>这一步并非直接交换对称加密的会话密钥，而是生成密钥的其中一个参数。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4538003-136455d72dfe064b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Server Key Exchange报文"></p>
<h5 id="Server-Hello-Done"><a href="#Server-Hello-Done" class="headerlink" title="Server Hello Done"></a>Server Hello Done</h5><p>表示服务器已经将所有预计的握手消息发送完毕。在此之后，服务器会等待客户端发送消息。</p>
<h4 id="4-客户端Client-Key-Exchange、Change-Cipher-Spec、Encrypted-Handshake-Message"><a href="#4-客户端Client-Key-Exchange、Change-Cipher-Spec、Encrypted-Handshake-Message" class="headerlink" title="4.客户端Client Key Exchange、Change Cipher Spec、Encrypted Handshake Message"></a>4.客户端Client Key Exchange、Change Cipher Spec、Encrypted Handshake Message</h4><p>客户端收到服务器的数据，会按照信证书链逐级验证数字证书，确认数字证书是合法的，说明确实来自于服务器，取出服务端公钥<code>server_pub_key</code>。</p>
<p>通过一个TCP包返回以下3个握手子协议类型数据。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4538003-0849aa61518da4c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="客户端"></p>
<h5 id="Client-Key-Exchange"><a href="#Client-Key-Exchange" class="headerlink" title="Client Key Exchange"></a>Client Key Exchange</h5><p><strong>客户端根据确定的椭圆曲线也生成客户端的临时 ECDH 公钥和私钥。<br>由于采用单向认证，服务端不需要在TLS协议层验证客户端的身份，因此没有加数字签名，将客户端临时 ECDH 公钥明文返回给服务端。</strong><br><img src="https://upload-images.jianshu.io/upload_images/4538003-5d89325cbceb6e44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Client Key Exchange报文"></p>
<h5 id="Client-Change-Cipher-Spec"><a href="#Client-Change-Cipher-Spec" class="headerlink" title="Client Change Cipher Spec"></a>Client Change Cipher Spec</h5><p>客户端和服务端都拥有了对方临时的 ECDH 公钥，把它们带入 ECDHE 算法得出相同的<code>pre_master</code>。</p>
<p>客户端再把<code>pre_master</code>、<code>client_random</code>和<code>server_random</code>，通过密码套件中的伪随机算法<code>SHA384</code>得出相同的**主密钥<code>Master Secret</code>**。</p>
<p>服务端和客户端都会使用这个预主密钥，以及相同的伪随机函数（Pseudorandom Function，简称PRF），生成一系列的会话密钥。<br><strong>包括客户端写密钥（client_write_key）和服务器写密钥（server_write_key）, 用于加密后续的信息。</strong></p>
<p>为什么对称加密，要生成客户端和服务端两个会话密钥呢？<br>客户端发送消息使用客户端密钥加密，服务端发送消息使用服务端密钥加密。<br>使用一个密钥的风险在于，身份验证失效了。中间商获取之后，直接原封不动把消息丢回来，客户端收到之后依然可以解密，就以为真是服务器发来的。</p>
<p>然后返回消息通知服务端后面通信使用<code>AES_256_GCM</code>对称加密算法，使用刚生成的会话密钥加密。<br><img src="https://upload-images.jianshu.io/upload_images/4538003-c31f23532b8d6815.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Change Cipher Spec报文"></p>
<h5 id="Client-Encrypted-Handshake-Message"><a href="#Client-Encrypted-Handshake-Message" class="headerlink" title="Client Encrypted Handshake Message"></a>Client Encrypted Handshake Message</h5><p>这是由客户端服务器之间协商的算法和密钥保护的第一个消息。它意味着握手已经完成。消息内容将使用会话密钥加密，以便双发可以安全地交换验证整个握手完整性所需要的数据。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4538003-cabcc83d1d543a6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Encrypted Handshake Message报文"></p>
<h4 id="5-服务端Change-Cipher-Spec、Encrypted-Handshake-Message"><a href="#5-服务端Change-Cipher-Spec、Encrypted-Handshake-Message" class="headerlink" title="5. 服务端Change Cipher Spec、Encrypted Handshake Message"></a>5. 服务端Change Cipher Spec、Encrypted Handshake Message</h4><p>服务端接收到<code>client_pub_key</code>之后，服务端也会生成相同的主密钥<code>Master Secret</code>，扩展生成会话密钥，通知客户端传输的数据将使用对称加密。<br>随后消息内容使用对称加密，发送给客户端。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4538003-79a744fbffde3d6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="服务端Change Cipher Spec、Encrypted Handshake Message报文"></p>
<h4 id="6-客户端Encrypted-Alert"><a href="#6-客户端Encrypted-Alert" class="headerlink" title="6.客户端Encrypted Alert"></a>6.客户端Encrypted Alert</h4><p>客户端收到服务端的加密信息，表示可以正常通信，握手完成，服务端和客户端会互传数据并加密。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4538003-f46df35ac4b97684.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ECDHE抓包图"></p>
<p>ECDHE 传输过程如下：</p>
<ol>
<li>客户端和服务端建立连接，Client Hello 将客户端端随机数、密码套件等发送给服务端。</li>
<li>服务端收到后Server Hello，将服务端随机数，选定的密码套件等发送给客户端。</li>
<li>服务端再将包含服务器公钥、服务器主机名等数字证书信息和证书签名，CA证书和签名发送给客户端。</li>
<li>客户端先验证数字证书和主机名是否正确，确定是服务器发送的之后，提取出服务器公钥。</li>
<li>客户端再将客户端公钥发送给服务器，如果单向认证不需要证书，如果双向认证需要发送客户端证书。</li>
<li>服务器和客户端根据双方的公钥生成pre_master，加上双方随机数生成master，扩展生成服务端和客户端会话密钥。</li>
<li>客户端使用会话密钥加密，通知服务端以后使用对称加密。</li>
<li>服务端收到后也会使用对称加密。</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/4538003-fee7dd4e0e099c74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ECDHE握手过程"></p>
<h2 id="RAS传输过程"><a href="#RAS传输过程" class="headerlink" title="RAS传输过程"></a>RAS传输过程</h2><p>HTTPS中使用<strong>非对称加密算法</strong>加密 生成<strong>对称加密算法</strong>秘钥的关键信息，再使用<strong>对称加密算法</strong>来加密传输信息。这句话有点绕，看下面过程应该就可以理解了：</p>
<ol>
<li><p>客户端和服务端建立连接，客户端给服务端发送一个随机数，用于后面加密。</p>
</li>
<li><p>服务端收到，也发给客户端一个随机数，用于后面加密。</p>
</li>
<li><p>服务端生成公钥和私钥，CA证书保存公钥，并发送CA证书给客户端。</p>
</li>
<li><p>客户端收到CA证书，使用CA公钥进行验证解析，获取服务端的公钥，并生成一个随机数字<code>pre-master</code>,再把<code>pre-master</code>使用解析出的公钥进行加密传输给服务器端。</p>
</li>
<li><p>服务器接收到之后加密的随机数字<code>pre-master</code>之后，使用私钥进行解析，获取<code>pre-master</code>明文数字。</p>
</li>
<li><p>客户端和服务端使用<strong>客户端的随机数+服务端的随机数+pre-master</strong>计算得出对称加密算法秘钥。</p>
</li>
<li><p>客户端和服务端使用秘钥加密传输信息。</p>
</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/4538003-94cbc972b09a02f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="传输过程"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%20%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%20%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">DNS 介绍</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-08-27 16:17:53" itemprop="dateCreated datePublished" datetime="2023-08-27T16:17:53+00:00">2023-08-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-09-11 11:02:55" itemprop="dateModified" datetime="2023-09-11T11:02:55+00:00">2023-09-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <meta name="referrer" content="no-referrer" />
# DNS 介绍

<p>DNS（Domain Name System），一个将域名转换为IP地址的系统。<br>DNS 协议是应用层协议，因为 TCP 建立连接必须需要 IP 地址，所以应用层必须要把域名解析成 IP 地址，才能建立 TCP 连接，否则会建立连接失败。</p>
<h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p>域名本质是一个名字，使得用户能更方便地找到和访问网站，而不需要记住复杂的IP地址，如果每个网站都要你输入IP地址你岂不是要崩溃。</p>
<p>完全限定域名的组成部分，常见域名组成形式: 子域名(主机名)+二级(权威)域名+顶级域名。比如<a target="_blank" rel="noopener" href="http://www.sina.com./">www.sina.com。</a></p>
<ul>
<li>com 为顶级域名，顶级域名是域名的最后一部分，它表示域名的类别或地理位置。常见的顶级域名有”.com”、”.net”、”.org”、”.edu”等，还有表示国家或地区的顶级域名，如”.cn”、”.uk”、”.us”等。</li>
<li>sina 为二级域名，一般为公司或者个人独特名字。</li>
<li>www 为主机名(子域名)，用于主机的用途或者是网站的某个部分，比如 “www” 表示表示提供网页浏览服务的服务器，”ftp”用于文件传输服务，”mail”用于电子邮件服务。<br>也可以用于公司标识不同网站不同部分一个公司可能会有“blog.example.com”来托管他们的博客，“shop.example.com”来托管他们的在线商店，或者“mail.example.com”来提供电子邮件服务。</li>
</ul>
<p>一个物理主机可以托管多个网站，即存在多个虚拟机。<br>虚拟主机使用域名来区分和路由到服务器上的不同网站。<br>一个服务器下有多个虚拟机主机对外提供服务，把域名作为虚拟机主机名后，通过域名匹配找到对应的虚拟机主机。</p>
<h2 id="DNS服务器"><a href="#DNS服务器" class="headerlink" title="DNS服务器"></a>DNS服务器</h2><p><strong>DNS 服务器即域名解析服务器，用于把域名解析成IP地址。</strong> 比如在浏览器上面输入<code>www.taobao.com</code>，然后回车一下，浏览器就会跳转到淘宝的页面。</p>
<p>众所周知，发送网络请求时需要知道对方的IP地址，网络请求才会被发送出去。那为什么我们仅仅输入了域名就可以进入淘宝页面呢？<br>因为 DNS 服务器已经把<code>www.taobao.com</code>这个域名解析成了例如<code>192.168.0.10</code>这样的 IP 地址。</p>
<p>可以这么联想小明的家在北京市朝阳区新城国际23幢1单元505室。比如老师想去小明家做家访，老师这时候就用电脑调用出学生地址登记簿，就知道小明家的具体位置了。<br>这里小明的家就是域名，北京市朝阳区新城国际23幢1单元505室就是IP地址，老师查询的地址登记簿就是 DNS 服务器。</p>
<h3 id="DNS服务器结构"><a href="#DNS服务器结构" class="headerlink" title="DNS服务器结构"></a>DNS服务器结构</h3><p>所有的域名都要DNS服务器来解析，那么DNS服务器就是分布式的，整体为树状结构，不一定就3层，根据系统可以继续向下分层级。<br>根DNS服务器全球一共 13 台。<br>上层 DNS 服务器返回下层 DNS 服务器的 IP 地址。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4538003-7c8c1809298d359c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DNS结构图(来源极客时间)"></p>
<h2 id="DNS-解析过程"><a href="#DNS-解析过程" class="headerlink" title="DNS 解析过程"></a>DNS 解析过程</h2><p>比如解析 <code>www.google.com</code> 这个域名</p>
<ol>
<li><p>主机首先会查询操作系统 DNS 缓存，如果存在则返回，如果找不到再查询本地host文件，windows 下 host 文件在<code>C:\Windows\System32\drivers\etc</code>目录，linux系统在<code>\etc\host</code>下。</p>
</li>
<li><p>如果 host 文件存在域名(主机名)和 IP 地址的映射关系，则直接返回，如果不存在在请求本地 DNS 服务器。</p>
</li>
<li><p>主机会配置一个本地 DNS 服务器，windows 可以通过<code>ipconfig \all</code>指令查看。主机通过DNS协议把域名发给本地DNS服务器解析。本地DNS服务器会先查询DNS缓存，如果没有缓存则请求根DNS服务器。</p>
</li>
<li><p>本地服务器中保存了 13 个根DNS服务器的地址，这些地址是固定不变的。本地服务器会向其中一个发起请求。根服务器管理<code>com</code>、<code>cn</code>、<code>net</code>等顶级DNS服务器。</p>
</li>
<li><p>根服务器收到请求后，根据域名的顶级域名返回<code>com</code>的 DNS 服务器 IP 地址。其他网站比如<code>www.taobao.com</code>是<code>.com</code>域下的，返回com DNS服务器IP地址，<code>www.csdn.net</code>是<code>.cn</code>域下的，返回cn DNS 服务器 IP 地址。</p>
</li>
<li><p>本地DNS服务器接收到<code>com</code>顶级域名的DNS服务器IP地址后，向它发送请求。</p>
</li>
<li><p>顶级域名的DNS服务器管理二级域名的DNS服务器。<code>com</code>顶级域名的DNS服务器接收到请求后，返回<code>google.com</code>域名的 DNS 服务器 IP 地址。</p>
</li>
<li><p>本地DNS服务器收到<code>google.com</code>域名的 DNS 服务器 IP 地址，再向它发起请求。</p>
</li>
<li><p>二级DNS服务器，可以通过网站方进行部署，意为这个域名指向的具体IP地址是由我决定的。<code>google.com</code>域名的 DNS 服务器接收到请求之后，把 <code>www.google.com</code> 所在的服务器 IP 地址返回。</p>
</li>
<li><p>本地DNS服务器接收到之后再返回给主机，一般都会缓存，主机知道了IP地址，就能发送HTTP请求，最终进入网站。</p>
</li>
<li><p>整个过程如下图所示，就好比老师查询地址簿，先判断小明的家在北京市，再判断在北京市下辖的朝阳区，最后再朝阳区的范围中找到小明家的具体位置。</p>
</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/4538003-d46f180b5bca276b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DNS流程图"></p>
<h2 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h2><p><strong>DNS缓存</strong>，为了防止每次域名解析都请求都重新请求一遍，会把域名和IP地址的映射关系保存下来，即为DNS缓存。一般3个地方具有DNS缓存。</p>
<ol>
<li>除了上面介绍的3类服务器之外，许多大公司、网络运行商都会建立自己的 DNS 服务器，作为客户主机 DNS 查询的代理，代替它访问核心 DNS 系统。本地DNS服务器保存域名查询的结果。</li>
<li>客户主机操作系统把 IP 地址和域名的映射关系保存在内存中。</li>
<li>客户端主机的<code>host</code>文件会把所有解析过的域名和ip地址映射关系保存下来。</li>
</ol>
<p>域名解析会先查询缓存，缓存查询顺序是操作系统 DNS 缓存-&gt;host文件-&gt;本地 DNS 服务器缓存。<br>阿里云、腾讯提供的 DNS 解析服务器也是类似这个作用，可以最快帮助用户将域名解析成 IP 地址。</p>
<h2 id="DNS的优点"><a href="#DNS的优点" class="headerlink" title="DNS的优点"></a>DNS的优点</h2><ol>
<li><p>如果网站服务器出现故障，需要迁移到另外一台服务器上面，IP 地址改变，只需要在权威服务器改为新的 IP 即可，不用告诉所有人我的 IP 变了。</p>
</li>
<li><p>负载均衡，一个网站有多个服务器，通过DNS一个域名可以指向多个IP地址，DNS服务器每次可能返回的是不同的IP地址，返回离客户最近的服务器 IP 地址，或者使用轮询算法，可能小明访问网站DNS服务器返回的是<code>192.168.0.1</code>，小王返回网站DNS服务器返回的是<code>192.167.0.1</code>。<br>除此之外，DNS 解析还可以返回 CDN 的服务器 IP 地址。</p>
</li>
</ol>
<h2 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h2><p>如果我们DNS被挟持了，你访问的网站被指向了一个钓鱼网站的IP地址。就好比我们以前登录游戏网站，有人做了一个样的钓鱼网站。由于你的DNS被挟持，所以当你输入网址时就跳转到了钓鱼网站上面，然后你输入了账号和密码，这时候你的账号就被盗了。</p>
<p>所以我们不要随便连外面的wifi，也要注意网络安全。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/URI%E3%80%81URL%E3%80%81URN%20%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/URI%E3%80%81URL%E3%80%81URN%20%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">URI、URL、URN 介绍</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-08-27 15:39:54" itemprop="dateCreated datePublished" datetime="2023-08-27T15:39:54+00:00">2023-08-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-09-11 11:02:55" itemprop="dateModified" datetime="2023-09-11T11:02:55+00:00">2023-09-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <meta name="referrer" content="no-referrer" />

<h1 id="URI、URL、URN-介绍"><a href="#URI、URL、URN-介绍" class="headerlink" title="URI、URL、URN 介绍"></a>URI、URL、URN 介绍</h1><p>URI：统一资源标识符<br>URL：统一资源定位符<br>URN：统一资源名</p>
<p>三者之间关系如下所示：</p>
<p>URI包含了URL和URN，因为两者都可以作为资源标识符。<br>URI 由 3 部分组成，以下面 URI 为例<br><code>https://feishu.cn/drive/home/</code></p>
<ul>
<li>协议名: 访问该资源应当使用的协议，使用 https。</li>
<li>主机名: 互联网上主机的标记，可以是域名或 IP 地址，使用 feishu.cn。</li>
<li>路径: 资源在主机上的位置，使用“&#x2F;”分隔多级目录,使用 &#x2F;drive&#x2F;home。</li>
</ul>
<p>URL类似于地址，用于定位资源，如<code>https://leetcode-cn.com</code>，我们可以通过访问URL找到资源，就比如通过北京市朝阳区东新小区2幢1单元2室家庭地址，定位到某人的具体位置。</p>
<p>URN类似于身份证号码，通过特定命名空间的名字标识资源，如<code>bitpoetry.io/posts/hello.html</code>。</p>
<p>URL一定是URI，但是URI不一定是URL。无论URN还是URL都是URI其中的一类。</p>
<p>开发过程中，所以不用分的太细，一律当成 URI 统一资源标识符看即可。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4538003-60d69ee010eb7e84.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="URI、URL和URN之间的关系"></p>
<h2 id="DNS-和-URI-之间的关系"><a href="#DNS-和-URI-之间的关系" class="headerlink" title="DNS 和 URI 之间的关系"></a>DNS 和 URI 之间的关系</h2><p>DNS 负责将 URI 中的域名部分解析成 IP 地址，定位到服务器，再根据 URI 中的路径名找到服务器中的资源。<br>举个例子，你要买农夫山泉矿泉水，DNS 根据超市名，帮助你找到超市的位置，根据 URI 知道农夫山泉在超市的摆放位置，然后找到它。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%20%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%20%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">Http介绍</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-26 11:19:37" itemprop="dateCreated datePublished" datetime="2021-06-26T11:19:37+00:00">2021-06-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-09-11 11:02:55" itemprop="dateModified" datetime="2023-09-11T11:02:55+00:00">2023-09-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <meta name="referrer" content="no-referrer" />

<h1 id="HTTP协议介绍"><a href="#HTTP协议介绍" class="headerlink" title="HTTP协议介绍"></a>HTTP协议介绍</h1><p><strong>HTTP协议，超文本传输协议，表示两个计算机通信点之间传输文字、图片、视频等超文本数据的约定和规范。</strong><br>它不关心寻址、路由、数据完整性等传输细节，而要求这些工作都由下层的TCP协议来处理，提供可靠，字节流形式的通信。</p>
<p>在传输过程中图片、视频、文字等超文本数据和传输参数都会转换为字符，把这些字符连起来发送给接收方，接收方接收到这些字符根本不知道这些字符的含义是什么，也就无法解析。<br>就好比一个发了一大串没有联系的字母，另外一个人根本不知道这些到底什么意思。</p>
<p>有了HTTP协议，就好比有了一个说明书，通过key-value的形式，知道每个key及对应的value是什么意思，比如<code>Accept</code>表示的就是客户机支持的数据类型，<code>Date</code>表示请求的时间是什么，接收方通过解析知道发送方的意图，再根据HTTP协议作出响应。</p>
<p>HTTP协议是应用层协议。TCP&#x2F;IP协议栈对应4层网络模型分别是应用层、传输层、网际层、链路层。传输资源根据HTTP协议包装好，包装好的数据依靠底下3层和对应的协议发送给接收方。</p>
<p>HTML和HTTP协议密切相关，但是不要把HTTP协议和HTML混为一谈。HTML是一种标记语言，使用各种标签描述文字、图片、超链接等资源，是超文本资源的载体，相当于给传输的超文本资源加上描述符。<br>浏览器根据HTML标签，知道资源要如何展示出来，比如<code>&lt;h1&gt;&lt;/h1&gt;</code>，其中的文字被标签描述为标题，浏览器给它加大加粗。所以HTML数据也是传输数据的一种。</p>
<p>可以参考<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP">MDN</a>进行学习。</p>
<h2 id="HTTP特点"><a href="#HTTP特点" class="headerlink" title="HTTP特点"></a>HTTP特点</h2><ol>
<li>HTTP 是灵活可扩展的，可以任意添加头字段实现任意功能；</li>
<li>HTTP 是可靠传输协议，基于 TCP&#x2F;IP 协议“尽量”保证数据的送达；</li>
<li>HTTP 是应用层协议，比 FTP、SSH 等更通用功能更多，能够传输任意数据；</li>
<li>HTTP 使用了请求 - 应答模式，客户端主动发起请求，服务器被动回复请求；</li>
<li>HTTP 本质上是无状态的，每个请求都是互相独立、毫无关联的，协议不要求客户端或服务器记录请求相关的信息，通过cookie技术实现有状态。</li>
<li>HTTP 是明文传输，数据完全肉眼可见，能够方便地研究分析，但也容易被窃听</li>
<li>HTTP 是不安全的，无法验证通信双方的身份，也不能判断报文是否被窜改</li>
<li>HTTP 有性能瓶颈，请求是顺序发送的，当队头请求被堵塞，后面排队的请求也会被堵塞，这就是队头堵塞。</li>
</ol>
<h2 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h2><p>HTTP报文如下图所示，由<strong>起始行、头部、空行、实体组成</strong>，实体不是必须的，可以不包含实体。</p>
<p>HTTP报文可以分为请求报文和响应报文两类。</p>
<ul>
<li>请求报文: 客户端向服务器发起请求的 HTTP 报文，包含客户端请求的信息。</li>
<li>响应报文: 服务端给客户端的响应的 HTTP 报文，包含服务端响应的信息。</li>
</ul>
<p>下面依次介绍HTTP报文的组成部分。<br><img src="https://cdn.jsdelivr.net/gh/kptnewler/blog-image/blogs/picture/20230826165411.png" alt="HTTP报文组成"></p>
<h3 id="起始行"><a href="#起始行" class="headerlink" title="起始行"></a>起始行</h3><p>起始行可以根据请求报文和响应报文，分成请求行和响应行两类。</p>
<h4 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h4><p>请求行由<strong>请求方法</strong>、<strong>请求URL</strong>、<strong>HTTP版本号</strong>组成，并用空格隔开。比如<code>GET /user/login HTTP/1.1</code>。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4538003-dc408b54368b8a39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="请求行"></p>
<p>请求方法：表示操作服务端超文本资源的方式。比如请求修改资源，获取资源，上传资源等等。操作方式由对应的请求方法表示，这里简单介绍一下。最常用的是<code>GET</code>和<code>POST</code>请求方法。</p>
<ol>
<li>GET：请求获取资源，即希望服务器返回指定的资源内容。</li>
<li>POST：提交资源，即向服务器新增超文本资源。</li>
<li>PUT：修改资源，即向服务器修改已有的资源内容。</li>
<li>DELETE：删除资源，即从服务器删除某个资源。</li>
<li>HEAD：获取资源元信息，即从服务器返回资源的信息，不需要内容，比如查看是否有新版本更新。</li>
<li>OPTIONS：列出可对资源实行的方法</li>
<li>CONNECT：建立特殊的连接隧道</li>
<li>TRACE：追踪请求 - 响应的传输路径。</li>
</ol>
<p>URL：表示请求服务端超文本资源的地址，用于定位服务端超文本资源。URL可以只是路径部分，因为协议名和主机名已经分别出现在了请求行的版本号和请求头部字段的<code>Host</code>字段里，没有必要再重复。当然，在请求行里使用完整的 URI 也是可以的。</p>
<p>HTTP版本号：目前包含HTTP&#x2F;0.9、HTTP&#x2F;1.0、HTTP&#x2F;1.1、HTTP&#x2F;2，这几个版本。</p>
<h4 id="响应行"><a href="#响应行" class="headerlink" title="响应行"></a>响应行</h4><p>响应行由 <strong>HTTP版本号、响应状态码、状态描述</strong>组成，并用空格隔开。比如<code>HTTP/1.1 200 ok</code>。<br><img src="https://upload-images.jianshu.io/upload_images/4538003-94191192caa447a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="响应行"></p>
<p>HTTP版本号：和请求行中的一样。</p>
<p>响应状态码：表示服务器处理请求的结果，客户端可以根据状态码进行下一步处理工作或用于调试。目前主要有41个状态码，也可以自行扩展。状态码主要分为以下几类，没类都有对应的请求码。</p>
<ol>
<li>1xx：表示提示信息，是协议处理的中间状态，实际能够用到的时候很少，比如101-Switching 协议切换，比如WebSocket，100-continue客户端通过POST发送大数据。</li>
<li>2XX: 表示服务端接收并成功处理了请求，204-No Content，和 200 意思一样，但没有响应的 body，206-Partial Content-用于分块和断点续传，服务正确处理结果，但是响应 body 中数据不完全。</li>
<li>3xx：表示重定向，服务端资源变动，让客户端使用返回的新url请求资源，301-永久重定向，302-临时重定向，主要在搜索引擎上不同，304 - 资源未修改，用于缓存控制。</li>
<li>4xx：表示客户端请求出错。400-请求报文有错误，401-未授权需要登录身份验证，403禁止访问，404资源不存在。</li>
<li>5xx：表示服务端处理请求报错，500-服务器内部出错，501-客户端请求功能不支持，502-服务器作为网关或代理返回，访问出错，503-服务器很忙无法响应服务。</li>
</ol>
<p>状态描述：表示状态码的描述信息。</p>
<h3 id="头部介绍"><a href="#头部介绍" class="headerlink" title="头部介绍"></a>头部介绍</h3><p><strong>头部分为请求头和响应头，使用 key-value 的形式，可以使用 HTTP 协议提供了标准的头部字段或自定义头部字段作为key值。</strong></p>
<p>HTTP标准头部字段主要分为：</p>
<ul>
<li>通用字段：在请求头和响应头里都可以出现。</li>
<li>请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件。</li>
<li>响应字段：仅能出现在响应头里，补充说明响应报文的信息；</li>
<li>实体字段：它实际上属于通用字段，但专门描述 body 的额外信息。</li>
</ul>
<p>HTTP 的报文解析和处理主要对头部字段的处理，<strong>理解了头部字段， HTTP 报文也就有个全面认识了。</strong></p>
<p>下面看看头部字段的具体应用场景，按照功能能主要划分为<strong>描述信息、实体数据传输、文件传输、连接管理、重定向、Cookie管理、HTTP代理、缓存</strong>，下面根据应用场景一一介绍 HTTP 的头部字段。</p>
<h4 id="描述信息"><a href="#描述信息" class="headerlink" title="描述信息"></a>描述信息</h4><p><strong>描述请求或响应的信息说明</strong>，比如时间、主机名等等。</p>
<ul>
<li><strong>Host: 请求字段，如果服务器一个IP地址下有多个虚拟主机(同一个物理机器托管多个网站)，就可以通过 Host 来找到接收请求的主机。</strong><br>比如 <code>114.114.12.1</code> 下面有 2 个虚拟主机，<a target="_blank" rel="noopener" href="http://www.shop.com/">www.shop.com</a> <a target="_blank" rel="noopener" href="http://www.store.com,使用域名进行访问,必须要用/">www.store.com，使用域名进行访问，必须要用</a> Host 区分这两个 IP 相同但是域名不同的网站，否则找不到合适的虚拟主机处理，就会报错。</li>
<li><strong>User-Agent: 请求字段，用于描述发起 HTTP 请求的客户端</strong>。比如有 Mozilla、Chrome 等浏览器名。</li>
<li><strong>Date: 通用字段，通常出现响应头，表示 HTTP 报文创建的时间。</strong></li>
<li><strong>Server: 响应字段，只出现在响应头，告诉客户端提供 Web 服务的软件和版本号。</strong> 比如 tomcat&#x2F;7.0.2 等。</li>
</ul>
<h4 id="实体数据传输"><a href="#实体数据传输" class="headerlink" title="实体数据传输"></a>实体数据传输</h4><p>实体数据传输主要包括以下几点:</p>
<ul>
<li><p>客户端请求服务端，要告知服务端，客户端支持处理的资源信息，比如类型，语言，字符集。<strong>请求时通过请求头部字段添加支持处理的资源描述信息。</strong></p>
</li>
<li><p>服务端响应客户端，也要告知客户端，响应的资源信息，客户端根据资源信息，对资源进行处理，<strong>响应时通过实体头部字段添加响应的资源描述信息。</strong></p>
</li>
<li><p>如果客户端使用 POST 请求，则<strong>添加资源，客户端会携带资源发送给服务端，客户端也要通过实体头部字段添加请求的资源描述信息。</strong></p>
<p>如果没有资源实体描述信息，客户端和服务端每次都要检查资源的内容来获取资源信息，如类型、长度等，非常低效和不准确。</p>
</li>
</ul>
<h5 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h5><p><strong><code>Content-Length</code>: 表示客户端提交资源实体数据的长度或服务器响应返回实体数据的长度，属于实体首部。</strong></p>
<p>因为Body部分，没有准确的结束符，比如<code>\n</code>，所以需要根据长度来提取出实体数据。<br>如果客户端给<code>Content-Length</code>和实体数据长度不匹配，可能会造成服务端接收的数据被截断。</p>
<p>另外如果没有这个字段服务端可能认为实体是不定长的，使用 chunked 方式分段传输。</p>
<h5 id="MIME介绍"><a href="#MIME介绍" class="headerlink" title="MIME介绍"></a>MIME介绍</h5><p>MIME，全名为多用途互联网邮件扩展，最早应用于电子邮件传输。<br>HTTP协议传输和邮件传输类似，可以传输多种格式的数据，比如图片、文件、音乐、视频等。<br>MIME类型的格式是<code>&lt;MIME_type&gt;/&lt;MIME_subtype&gt;</code>,如果<code>text/html</code>、<code>image/png</code>，前面是主类别，后面是主类别下的子类别。<br>如果<code>type</code>为通配符<code>*</code>,表示MIME的所有主类别，<code>subtype</code>为通配符<code>*</code>表示主类别下的所有子类别，比如所有图片类型<code>image/*</code>，所有MIME类型<code>*/*</code>。</p>
<p>常用的MIME有以下几种，所有的MIME类型可以查询<a target="_blank" rel="noopener" href="https://www.iana.org/assignments/media-types/media-types.xhtml">所有MIME类型</a></p>
<ul>
<li><p><code>text</code>：表示文本格式类型，子类别如超文本<code>text/html</code>、css格式<code>text/css</code>、纯文本格式<code>text/plain</code>等。</p>
</li>
<li><p><code>image</code>：表示图片格式类型，子类别如png格式<code>image/png</code>、gif格式<code>image/gif</code>、jpg格式<code>image/jpeg</code>等。</p>
</li>
<li><p><code>audio</code>：表示音频格式类型，子类别如mp3格式<code>audio/mpeg</code>、wav格式<code>audio/wav</code>等。</p>
</li>
<li><p><code>video</code>：表示视频格式类型，子类别如mp4格式<code>video/mp4</code>等。</p>
</li>
<li><p><code>application</code>：表示数据格式不固定，可能是文本也可能是二进制，必须由上层应用程序来解释。比如json格式<code>application/json</code>、pdf格式<code>application/pdf</code>、js格式<code>application/javaScript</code>。如果无法判断具体格式类型，则使用<code>application/octet-stream</code>，可以用在所有格式类型的资源上，服务端返回此种类型格式，浏览器会把当做文件下载。</p>
</li>
<li><p><code>multipart</code>：表示数据包含多种格式类型，如用于表单数据传输<code>multipart/form-data</code>。</p>
</li>
</ul>
<p><strong>客户端和服务端根据头部字段判断传输实体的类型，做相应的处理。</strong></p>
<h5 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h5><p><strong><code>Accept</code>: 请求字段，主要用于客户端请求头，表示客户端支持的资源 MIME类 型，属于请求字段。</strong></p>
<p><code>Accept</code>中的值为MIME类型和权重，两者用<code>;</code>隔开，格式为<code>&lt;MIME_type&gt;/&lt;MIME_subtype&gt;;q=value</code>。<br><code>Accept</code>的值可以为多种MIME类型，每个值用<code>,</code>隔开，表示客户端支持多种资源MIME类型。<br>权重表示客户端最希望服务器返回的资源类型。<code>q</code>的最高权重为1,最小权重为0.01。如果没有<code>q</code>，则默认为最高权重</p>
<p>如下<code>Accept</code>头部信息表示：<br>客户端最希望返回的是 HTML 类型的资源，权重为1。<br>其次为 XML 类型的资源，权重为0.9。<br>最后是其他任意 MIME 类型的资源，权重为0.8。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xml;q=0.9,*/*;q=0.8</span><br></pre></td></tr></table></figure>

<h4 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h4><p><strong><code>Content-Type</code>: 实体首部，客户端上传(比如 POST 请求)或服务端返回的资源 MIME 类型</strong>，对方接收到数据后根据<code>Content-Type</code> 判断出具体数据类型，方便处理。<br>比如客户端上传 JSON 字符串，如果不注明<code>application/json</code>，服务端就不知道数据类型，也不会执行 JSON 字符串转实体的逻辑。</p>
<p><strong><code>Content-Type</code>的值只能用一种 MIME 类型表</strong>示，如果实体数据包含多种类型数据则用 MIME 类型中<code>multipart</code>表示。<br><code>Content-Type</code>中 MIME 类型后面还会有实体数据的字符集，因为没有单独的头部字段表示实体数据的字符集。<br>MIME类型和字符集用<code>;</code>隔开。</p>
<p>表示资源实体数据为 HTML，字符集为UTF-8。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html; charset=UTF-8</span><br></pre></td></tr></table></figure>
<p><code>Content-Type</code> 常用用法如下：</p>
<ul>
<li>text&#x2F;html: 在服务器响应头中，表示返回的是 HTML 文本。</li>
<li>application&#x2F;json: 在客户端请求头中，表示上传的是 JSON 数据。在服务器响应头中，表示返回的是 JSON 数据。</li>
<li>image&#x2F;jpeg: 图片、视频格式在服务端响应头中用于返回的多媒体文件类型。</li>
<li>application&#x2F;octet-stream: 在客户端请求头，可以用于单文件上传。</li>
<li>application&#x2F;x-www-form-unlencoded: 客户端表单上传，只能提交文本类型，表单内的数据转换为键值对，&amp;分隔。</li>
<li>multipart&#x2F;form-data: 客户端表单上传，包括文本和文件类型，<code>boundary</code>表示分隔符可自定义，每个键值对或文件通过分隔符断开，另外每部分都会用<code>Content-Type</code>表示当前数据的类型。<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/upload.do</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>SOHUWapRebot</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-cn,zh;q=0.5</span><br><span class="line"><span class="attribute">Accept-Charset</span><span class="punctuation">: </span>GBK,utf-8;q=0.7,*;q=0.7</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>60408</span><br><span class="line">Content-Type:multipart/form-data; boundary=ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.sohu.com</span><br><span class="line"></span><br><span class="line"><span class="language-jboss-cli"><span class="params">--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC</span></span></span><br><span class="line"><span class="language-jboss-cli"></span></span><br><span class="line"><span class="language-jboss-cli"><span class="string">//</span> 文本</span></span><br><span class="line"><span class="language-jboss-cli">Content-Disposition: form-data;name=<span class="string">&quot;desc&quot;</span></span></span><br><span class="line"><span class="language-jboss-cli">Content-Type: text/plain; charset=UTF-8</span></span><br><span class="line"><span class="language-jboss-cli">Content-Transfer-Encoding: 8bit</span></span><br><span class="line"><span class="language-jboss-cli">[<span class="string">......</span>][<span class="string">......</span>][<span class="string">......</span>][<span class="string">......</span>]<span class="string">...........................</span></span></span><br><span class="line"><span class="language-jboss-cli"></span></span><br><span class="line"><span class="language-jboss-cli"><span class="params">--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC</span></span></span><br><span class="line"><span class="language-jboss-cli"></span></span><br><span class="line"><span class="language-jboss-cli"><span class="string">//</span> 图片</span></span><br><span class="line"><span class="language-jboss-cli">Content-Disposition: form-data;name=<span class="string">&quot;pic&quot;</span>; filename=<span class="string">&quot;photo.jpg&quot;</span></span></span><br><span class="line"><span class="language-jboss-cli">Content-Type: application/octet-stream</span></span><br><span class="line"><span class="language-jboss-cli">Content-Transfer-Encoding: binary</span></span><br><span class="line"><span class="language-jboss-cli">[图片二进制数据]</span></span><br><span class="line"><span class="language-jboss-cli"></span></span><br><span class="line"><span class="language-jboss-cli"><span class="params">--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC--</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="Content-Disposition"><a href="#Content-Disposition" class="headerlink" title="Content-Disposition"></a>Content-Disposition</h5><p>我们可以看到上面出现了 <code>Content-Disposition</code>。</p>
<p><code>Content-Disposition</code>:表示服务端返回给客户端的资源表现形式。</p>
<p>** 如果应用在单MIME类型实体资源上，属于响应首部 **，有两种类型，浏览器根据类型不同处理方式也不同。</p>
<ul>
<li><p><code>inline</code>: 服务端告知客户端将返回的资源直接显示出来，类似邮件发送将文件内容直接显示在正文中。</p>
</li>
<li><p><code>attachment</code>: 服务端告知客户端，返回的资源作为附件。客户端如果为浏览器，则会直接弹出下载对话框。类似邮件发送中将文件作为邮件的附件。</p>
</li>
</ul>
<p><code>filename</code>表示返回资源的文件名。</p>
<p>如下报文所示，服务端返回的<code>Content-Disposition</code>类型为<code>inline</code>，浏览器会直接显示文件中的内容。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4538003-f78427a4f0d67575.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="inline报文"><br><img src="https://upload-images.jianshu.io/upload_images/4538003-65eb3628f6d9dbfc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="inline浏览器显示"></p>
<p>如下报文所示，服务端返回的<code>Content-Disposition</code>类型为<code>attachment</code>，浏览器会弹出下载框，文件名<code>filename</code>中的值。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4538003-b5ac299e0a063a8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="attachment报文"><br><img src="https://upload-images.jianshu.io/upload_images/4538003-e9a8ee889e960211.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="attachment浏览器展示"></p>
<p><strong>如果应用在多MIME类型实体资源上，作为通用首部。</strong> </p>
<p>客户端使用表单提交数据，表单中提交内容包含文字、文件多种类型。</p>
<p><code>Content-Disposition</code>紧跟在分隔符<code>--boundary</code>的后面，格式为<code>form-data; name=&quot;filedname&quot;; filename=&quot;filename&quot;</code>，如果表单值不为文件可以不加<code>filename</code>字段。<br>如果需要说明内容类型再添加<code>Content-Type</code>，最后为表单值或者文件内容。</p>
<p>如下报文所示，客户端提交表单内容，通过分隔符分隔，每个部分都包含<code>Content-Disposition</code>请求头部字段。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4538003-b47fc95d88d0e423.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表单提交报文"></p>
<h5 id="Accpet-Encoding和Content-Encoding"><a href="#Accpet-Encoding和Content-Encoding" class="headerlink" title="Accpet-Encoding和Content-Encoding"></a>Accpet-Encoding和Content-Encoding</h5><p><strong><code>Accept-Encoding</code>：请求首部，表示客户端支持的压缩格式。</strong><br><strong><code>Content-Encoding</code>：实体首部，表示客户端提交资源实体数据的压缩格式或服务端响应返回资源实体数据的压缩格式。</strong></p>
<p>** Encoding的目的负责将传输的数据进行压缩，对文本压缩率较高，图片、视频等多媒体文件压缩率低。**</p>
<p>HTTP协议中常用的压缩格式有以下几种，可以使用通配符<code>*</code>，表示所有的压缩格式。</p>
<ul>
<li>gzip：由GNU zip生成，使用Lempel-Ziv coding (LZ77)压缩算法，也是互联网上最流行的压缩格式。</li>
<li>compress：由UNIX文件压缩程序compress生成，使用Lempel-Ziv-Welch (LZW) 压缩算法。</li>
<li>deflate：使用zlib格式和deflate压缩算法生成的压缩格式，流行程度仅次于 gzip。</li>
<li>br：使用专门为HTTP优化的新压缩算法Brotli。</li>
<li>identity：用于标识，不执行压缩和修改的默认压缩格式。</li>
</ul>
<p><code>Accpet-Encoding</code>中的值为压缩格式和权重，两者用<code>;</code>隔开，格式为<code>&lt;Encoding-Type&gt;;q=value</code>。<br><code>Accpet-Encoding</code>的值可以为多种压缩格式，表示客户端支持多种压缩格式。权重的含义同上。</p>
<p>客户端最希望服务端返回的压缩格式为<code>gzip</code>，其次为<code>deflate</code>，权重为0.9。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate;q=0.9。</span><br></pre></td></tr></table></figure>

<p><code>Content-Encoding</code>的值只能为压缩格式中的一种，实体数据只会用一种压缩格式压缩。</p>
<h5 id="Accept-Language和Content-Language"><a href="#Accept-Language和Content-Language" class="headerlink" title="Accept-Language和Content-Language"></a>Accept-Language和Content-Language</h5><p><code>Accept-Language</code>:表示客户端支持的自然语言类型，属于请求首部。<br><code>Content-Language</code>：表示客户端提交资源实体数据的自然语言类型或服务端响应返回实体数据的自然语言类型，属于实体首部。</p>
<p>自然语言类型一般为中文、英文等，如中文<code>zh-CN</code>、英文<code>en-US</code>。</p>
<p><code>Accept-Language</code>的值为语言类型和权重，两者用<code>;</code>隔开，格式为<code>&lt;Language-Type&gt;;q=value</code>。<br><code>Accept-Language</code>可以有多个值，表示客户端可以支持的自然语言。权重的含义同上。</p>
<p><code>Content-Language</code>的值只能有一个，实体数据只会统一用一种自然语言。</p>
<h5 id="Accept-Charset"><a href="#Accept-Charset" class="headerlink" title="Accept-Charset"></a>Accept-Charset</h5><p><code>Accept-Charset</code>：客户端支持的字符集。<br>资源实体数据的字符集在<code>Content-Type</code>中。</p>
<p>字符集有<code>utf-8</code>、<code>iso-8859-1</code>等。</p>
<p><code>Accept-Charset</code>的值为字符集和权重，两者用<code>;</code>隔开，格式为<code>&lt;Charset&gt;;q=value</code><br><code>Accept-Charset</code>可以有多个值，表示客户端可以支持的字符集。权重含义同上。</p>
<h4 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h4><p>HTTP除了传输资源实体数据，还要传输文件，而且有可能是大文件。<br>服务器返回给客户端的文件比较大或者是由PHP、Java等动态生成的资源实体数据，服务端无法预估生成的大小。</p>
<p>下面从客户端和服务端两个方面分别说明设置哪些头部字段处理。</p>
<h5 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a>Transfer-Encoding</h5><p><strong><code>Transfer-Encoding</code>：表示报文的编码格式和 <code>Content-Length</code> 互斥，值可以为<code>compress</code>、<code>deflate</code>、<code>gzip</code>、<code>identity</code>、<code>chunked</code>。</strong></p>
<p>使用方式主要为<code>Transfer-Encoding: chunked</code>，用于分块传输。</p>
<p><code>Transfer-Encoding</code>有些资料显示属于通用头部，但是查询<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Transfer-Encoding">MDN Transfer-Encoding</a>，它属于响应首部，<br>并且请求测试，即使手动将其添加到请求头部，请求时请求头中该字段也不会出现。</p>
<p>分块传输主要应用于服务端响应返回数据给客户端。分块传输会将数据进行分块，逐个返回给客户端。</p>
<ol>
<li><strong>服务端传输大文件</strong>，可以一边压缩数据，一边返回数据，客户端逐个接收，而不用一次性压缩所有的数据返回给客户端，客户端也不用使用很大的byte数组来接收大文件。</li>
<li><strong>服务端是动态生成的资源实体数据</strong>，一开始不知道数据的大小，可以逐块传输给客户端。<br>服务端不用生成完毕之后，再返回资源，会导致客户端等待时间过久。客户端逐块接收，逐块加载。</li>
</ol>
<p>使用分块传输的编码规则如下：</p>
<ol>
<li><p>每个分块包含两个部分，长度头和数据块。</p>
</li>
<li><p>长度头为16进制，且以<code>CRLF</code>(即为&#x2F;r&#x2F;n)结尾。</p>
</li>
<li><p>数据块按照长度头切分，跟在数据头后面，也以<code>CRLF</code>(即为&#x2F;r&#x2F;n)结尾。</p>
</li>
<li><p>最后一行把长度头0作为结束符，即为<code>0\r\n\r\n</code>;</p>
</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/4538003-4db36913b8ac13af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="分块编码格式"></p>
<p>具体格式如下图所示，红色矩形数字即为长度头，2000为16进制，十进制为8192byte。紧跟的就是实体数据，由于太长做了截取。最后的0就是结束符。<br><img src="https://upload-images.jianshu.io/upload_images/4538003-92a27b00daca233b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>分块传输我们常见就是下载文件，浏览无法知道文件的大小，服务端分包逐个传输，浏览器逐个接收，去掉分块编码，重新组装成完整文件。<br><img src="https://upload-images.jianshu.io/upload_images/4538003-b2eae84905ef4b2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="下载文件"></p>
<p>通过Wireshark抓包，大文件被分包之后，会通过HTTP协议，将数据返回给客户端。<br><img src="https://upload-images.jianshu.io/upload_images/4538003-5d3c7ba457f2d08d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HTTP分块传输"></p>
<p>如果小文件或者已经知道资源实体数据传输大小则不需要使用分块传输，因为会导致多一次TCP传输，降低数据传输效率。</p>
<h5 id="Range、Accept-Ranges和Content-Range"><a href="#Range、Accept-Ranges和Content-Range" class="headerlink" title="Range、Accept-Ranges和Content-Range"></a>Range、Accept-Ranges和Content-Range</h5><p><strong><code>Accept-Ranges</code>: 响应首部，表示服务端是否支持范围请求</strong>，千万不要和上面的带<code>Accept</code>相关的字段混淆，以为它属于请求首部。有两个值：</p>
<ul>
<li><p><code>none</code>(和不使用 Accept-Ranges 作用相同)：表示不支持范围请求，等同于服务端不返回该字段。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Accept-Ranges</span><span class="punctuation">: </span>none</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>bytes</code>：表示支持范围请求，且单位为bytes。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Accept-Ranges</span><span class="punctuation">: </span>bytes</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong><code>Range</code>: 请求首部，客户端请求服务端获取资源实体数据的大小范围。</strong><br>值的格式为<code>bytes=x-y</code>或<code>bytes=x-y, x-y, x-y</code>。<code>x-y</code>表示起点和终点，可以是1个范围，表示单范围请求。也可以是多个范围，表示多范围请求，多个范围用<code>,</code>隔开。<br>使用方法如下所示，前者表示单范围请求，后者表示多范围请求。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Range</span><span class="punctuation">: </span>bytes = 0-200</span><br><span class="line"><span class="attribute">Range</span><span class="punctuation">: </span>bytes=-100, 200-656, 700-</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>x-y</code>中起点的<code>x</code>或者终点的<code>y</code>可以省略。</p>
<ul>
<li><p><code>-100</code>,开头可以省略<code>x</code>，表示客户端请求资源最后 100 字节，相当于<code>990-999</code>。</p>
</li>
<li><p><code>0-656</code>,表示请求的资源大小范围从文档开头到第 656 字节。</p>
</li>
<li><p><code>700-</code>尾部可以省略<code>y</code>，表示请求资源大小范围从第 700 字节一直到字段的最后一个字节，相当于<code>700-999</code>。</p>
</li>
</ul>
<p><strong><code>Content-Range</code>: 响应首部，表示服务端返回给客户端的数据，在服务端资源的资源属于哪个范围。</strong><br>值的格式为<code>bytes x-y/size</code>。<code>x-y</code>表示起点和终点，<code>size</code>表示整个资源的大小。</p>
<p>如果下面这个例子，表示在服务端 67559 大小的资源中，返回的第 200 字节到第 1000 字节范围的文件。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Range</span><span class="punctuation">: </span>bytes 200-1000/67589</span><br></pre></td></tr></table></figure>

<p><strong>范围请求是客户端向服务器请求指定范围的部分资源，相当于客户端主动要求对服务端的资源进行分块。</strong></p>
<p>比如我们平时在视频网站上看视频，并不是等视频全部下载完成，才可以观看，而是边下载边播放。<br>客户端根据进度条，请求服务端指定范围的视频文件，服务端根据客户端的请求，返回指定范围的视频文件数据范围。</p>
<p>另外还能用于，多段并发下载，比如百度云对每个账号限速 100 kb，我们可以开10个账号，每个账号同时现在文件的其中一部分，最后合并，那么速度就相当于 100kb * 10了。</p>
<p>下面分别来介绍单范围请求和多范围请求。</p>
<h5 id="单范围请求"><a href="#单范围请求" class="headerlink" title="单范围请求"></a>单范围请求</h5><p>客户端向服务端范围请求，如果是单个范围请求，客户端通过<code>Range</code>字段只请求其中一个范围，比如从第 100 字节到第 200 字节，步骤如下所示。</p>
<ol>
<li><p>客户端先向服务端<code>HEAD</code>请求，判断服务端是否支持范围请求。<br>如果响应头部字段包含<code>Accept-Ranges: bytes</code>，表示服务端支持范围请求，并且通过<code>Content-Length</code>返回资源的大小值。<br>如果响应头部字段不包含<code>Accept-Ranges</code>首部字段或者为<code>Accept-Ranges: none</code>，表示服务端不支持范围请求。</p>
</li>
<li><p>如果服务端支持范围请求，客户端发送请求，请求头部中包含<code>Range</code>头部字段，说明资源范围。</p>
<blockquote>
<p>请求头Range是 HTTP 范围请求的专用字段，格式是“bytes&#x3D;x-y”，其中的 x 和 y 是以字节为单位的数据范围。<br>要注意 x、y 表示的是“偏移量”，范围必须从 0 计数。</p>
</blockquote>
</li>
<li><p>服务端接收到之后先判断请求范围是否合法，如果超出文件范围，比如文件只有 100 个字节，但请求「200-300」，返回响应码<code>416 Range Not Satisfiable</code>。</p>
</li>
<li><p>如果合法，返回响应码<code>206 Partial Content</code>，表示返回部分资源，响应头部包含<code>Content-Range</code>字段返回资源的范围和 <code>Content-Length</code> 寿命返回资源大小。</p>
<blockquote>
<p>告诉片段的实际偏移量和资源的总大小，格式是“bytes x-y&#x2F;length”，与 Range 头区别在没有“&#x3D;”，范围后多了总长度。例如，对于“0-10”的范围请求，值就是“bytes 0-10&#x2F;100”。</p>
</blockquote>
</li>
</ol>
<p>模拟如下，先使用<code>HEAD</code>请求判断，如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4538003-75304bfd36f64db1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="head请求报文"></p>
<p>再使用<code>GET</code>请求单个范围的资源数据。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4538003-db283c489ffee6bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="单范围请求报文"></p>
<h5 id="多范围请求"><a href="#多范围请求" class="headerlink" title="多范围请求"></a>多范围请求</h5><p>多范围请求一般用的不多，但是还是讲解一下。客户端可以通过<code>Range</code>字段请求多个资源范围，比如从第100字节到第200字节，第400字节到第600字节等。步骤如下所示</p>
<ol>
<li><p>和单范围请求一样，客户端发送<code>HEAD</code>请求，这里不再赘述。</p>
</li>
<li><p>客户端请求服务端，通过<code>Range</code>字段发送多个请求范围。</p>
</li>
<li><p>服务端收到之后判断所有请求范围是否合法，不合法返回响应码<code>416</code>。<br> 如果合法，响应码<code>206</code>。返回所有范围的资源数据，响应头部字段的<code>Content-type</code>值为<code>multipart/byteranges; boundary=00000000001</code>，<code>boundary</code>表示数据分隔符。<br> <code>Content-Length</code>值为返回数据的大小。</p>
</li>
<li><p>返回数据使用分隔符<code>--boundary</code>隔开，之后要用<code>Content-Type</code>和<code>Content-Range</code>标记这段数据的类型和所在范围，然后就像普通的响应头一样以回车换行结束，再加上分段数据，最后用一个“- -boundary- -”（前后各有两个“-”）表示所有的分段结束。</p>
</li>
<li><p>客户端收到之后去除分隔符，提取指定范围的资源。</p>
</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/4538003-8be7f32fe0852656.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="返回数据格式"></p>
<p>具体请求报文如下所示</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4538003-42c0f4f1deafc65d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多范围请求报文"></p>
<h4 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h4><p>由于HTTP开始设计时，使用短连接。客户端请求服务端，客户端和服务端通过3次握手建立TCP连接，客户端发送请求，服务端返回响应后，两者断开连接。<br>下次客户端再向服务端发送请求时，再重新建立连接。如果短时间内同一个客户端和服务端进行请求应答，会重复建立建立连接，传输效率低下。</p>
<p>为了改变这种情况，HTTP&#x2F;1.1启用了长连接，长连接可以复用同一个TCP链路，，短时间同一个客户端向服务端进行请求应答，不用重复建立连接和断开连接，提高了传输效率。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4538003-9dd6f9bbeb3c1a15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="长连接和短连接"></p>
<p>为了解决队头堵塞的问题，相同域名下使用<strong>并发连接</strong>，对同个域名发起多个长连接，如果队头被堵塞，其他请求可以走另外的长连接，一般浏览器默认设置相同域名下，连接数为6-8个。</p>
<p>如果还不够用，就使用<strong>域名分片</strong>技术，将多个域名同时指向一台服务器，这样每个域名下都有长连接数名额。</p>
<h5 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h5><p><strong><code>Connection</code>：通用首部，表示客户端和服务端的连接管理，一般有两个值。</strong></p>
<ul>
<li><p><code>keep-alive</code>: 请求头使用表示客户端支持长连接，响应头使用表示服务端支持长连接。使用方式<code>Connection: keep-alive</code>。</p>
</li>
<li><p><code>close</code>：请求头使用表示客户端这次请求之后主动要求断开TCP连接。响应头使用表示服务端这次请求之后主动要求断开TCP连接。使用方式<code>Connection: close</code>。</p>
</li>
</ul>
<p>下面使用 WireShark 抓包，如果客户端和服务端请求头都没有<code>Connection: keep-alive</code>，则会被当成短连接，每次 GET 请求都要重新建立连接和断开连接。<br>当我们编写服务端代码时，不用手动添加，客户端浏览器请求头一般会带上该头部字段。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4538003-478544ec1bf84817.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="短连接"></p>
<p>如果使用长连接，第一次请求建立 TCP 连接之后，后面的 HTTP 请求都复用 TCP 链路，直到断开 TCP 连接。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4538003-a22cc17445299193.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="长连接"></p>
<p>一般情况下服务端不会主动使用<code>Connection: close</code>主动断开连接。如果客户端也不主动断开连接，会导致大量的空闲连接占用服务端的资源。<br>这种情况下如Tomcat、Nginx等服务器会设置最大保持连接时间、最大请求数，当超过时，服务端会主动断开连接。</p>
<p>每个服务器都有长连接保活措施，比如发送心跳包等。如果检测到客户端无连接，服务端会主动断开连接。<br><img src="https://upload-images.jianshu.io/upload_images/4538003-075f23e17cd17ad7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="心跳包"></p>
<p>HTTP连接还可以通过头部字段<code>Keep-Alive</code>管理。不过这个字段的服务端和客户端的约束力并不强，很多都不会遵守，一般使用率比较低。下面简单介绍一下。</p>
<h5 id="Keep-Alive"><a href="#Keep-Alive" class="headerlink" title="Keep-Alive"></a>Keep-Alive</h5><p><strong><code>Keep-Alive</code>: 表示客户端和服务端当前连接约定的超时时间和最大请求数。</strong>使用格式如下<code>Keep-Alive: parameters</code>，有两个值可以设置：</p>
<ul>
<li><p><code>timeout</code>: 表示保持连接的最长时间，超过最长时间服务端主动关闭连接。</p>
</li>
<li><p><code>max_requests</code>: 表示连接最大发送请求的数量，如果超过请求数量，服务端主动关闭连接。</p>
</li>
</ul>
<p>如<code>Keep-Alive: timeout=5, max=1000</code>，最长时间为5秒，最多发送的请求为2个。</p>
<h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>重定向是指当客户端请求服务端时，服务端由于当前URL下的资源失效，服务端返回给客户端一个新的URL，客户端再使用新的URL请求服务端。<br>重定向要适度使用，因为客户端会请求两次服务端。</p>
<h5 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h5><p><strong><code>Location</code>:响应首部，表示服务端返回给客户端的重定向 URL，配合服务端返回的响应码3xx一起使用。</strong></p>
<p><code>Location</code>中的 URL 可以使用绝对地址或相对地址。</p>
<ul>
<li><p>绝对地址即为完整的URL，包括包括 scheme、host:port、path 等，如<code>https://news.sina.com.cn/s/2019-11-29/doc-iihnzhfz2569609.shtml?cre=tianyi&amp;mod=pchp&amp;loc=2&amp;r=0&amp;rfunc=21&amp;tj=none&amp;tr=12</code>。</p>
</li>
<li><p>相对地址即只包括path和query部分，是不完整的。如<code>s/2019-11-29/doc-iihnzhfz2569609.shtml?cre=tianyi&amp;mod=pchp&amp;loc=2&amp;r=0&amp;rfunc=21&amp;tj=none&amp;tr=12</code>。</p>
</li>
</ul>
<p>如果在站内跳转可以使用相对地址，浏览器可以从请求中的host中获取到服务端地址，拼接得到完整URL。<br>如果跳转到站外，必须使用绝对地址，如果使用相对地址，浏览器会拼接成站内URL，导致404，资源不存在。</p>
<h5 id="响应码"><a href="#响应码" class="headerlink" title="响应码"></a>响应码</h5><p>重定向主要分为以下 2 种，服务端会返回对应的响应码，告知客户端。</p>
<ul>
<li><p>永久重定向：响应码为<strong>301 Permanent Redirect</strong>，表示原来url地址下的资源永远失效了，比如更新了域名、服务器变更等，客户端以后都要请求<code>Location</code>中的url获取资源，客户端会进行相应的更新。<br>比如浏览器根据响应码301会更新和失效URL相关的历史记录、书签等，防止二次跳转。</p>
</li>
<li><p>临时重定向：响应码为<strong>302 Found</strong>，表示原来URL下的资源暂时失效，系统处于临时维护的状态。客户端只是暂时使用<code>Location</code>中的URL获取资源。<br>客户端会认为原来的URL仍然有效，但暂时不可用，所以只会执行简单的跳转页面，不记录新的 URI，也不会有其他的多余动作，下次访问还是用原URL。</p>
</li>
</ul>
<p>还有以下3种响应码，对上面两种响应码的拓展，不过这三个状态码的接受程度较低，有的浏览器和服务器可能不支持，开发时应当慎重，测试确认浏览器的实际效果后才能使用。</p>
<ul>
<li><p>303 See Also：属于临时重定向，但是使用新的URL访问服务端只能用GET请求，不能使用POST、PUT等其他请求方式。</p>
</li>
<li><p>307 Temporary Redirect：属于临时重定向，但是使用新的URL访问服务端的请求方式，必须和之前使用旧的URL访问一样。</p>
</li>
<li><p>308 Permanent Redirect：属于永久重定向，但是使用的新的URL访问服务端的请求方式必须，必须和之前使用旧的URL访问一样。这点和307一致。</p>
</li>
</ul>
<p>有很多网站都会使用重定向技术，下面是访问京东的一个网址，返回了响应码302，响应头包含<code>Location</code>提供了新的URL。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4538003-0812a56f1c512a20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="重定向报文"></p>
<p>浏览器使用<code>Location</code>中新的URL再次请求服务端。<br><img src="https://upload-images.jianshu.io/upload_images/4538003-03ffb2887722c459.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="请求新的URL"></p>
<h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><h4 id="代理服务"><a href="#代理服务" class="headerlink" title="代理服务"></a>代理服务</h4><h4 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h4><p>虽然目前传输速度和可靠性基本可以得到保证，但是还是会遇到各种传输问题，传输时延不确定，以及需要的传输成本。<br>因此要使用缓存将获取的数据重复利用，将数据保存在本地磁盘中，减少请求-响应次数，增加响应速度。</p>
<p>HTTP是客户端请求，服务端响应的模式。按照缓存端点，分为<strong>客户端缓存</strong>和<strong>服务端缓存</strong>。</p>
<p><strong>客户端缓存将资源保存在本地磁盘中。<br>服务端缓存主要通过代理服务器实现(缓存代理)，当然服务器内部也有如 Memcache、Redis、Varnish 等缓存工具，HTTP无法涉及到，比如服务端不会根据http请求头部字段去刷新redis数据。</strong></p>
<p>客户端和服务端就相当于茅台零售商和茅台总公司的关系，缓存代理服务器相当于每个地区的代理商。<br>零售商会根据客户的需求多进一批货，客户下次再要就不用再跑去贵州了。零售商仓库的茅台酒就是客户端缓存。零售商有库存就不需要去贵州进货。<br>零售商没库存了，就需要找茅台总公司下订单，去贵州进货，茅台根据订单配货给零售商。订单就相当于HTTP请求报文。<br>茅台总公司仓库的酒，是生产的所有茅台，并没有根据零售商的订单进行分类备货，相当于内部缓存。<br>全国一共有几万个茅台零售商，茅台总公司无法保存所有订单，所以每次都需要根据订单重新配货，效率大大降低。<br>零售商每次都要去贵州进货，运输成本也很高。<br>为了解决问题，茅台总公司就在每个地区设置一个代理商，代表茅台总公司处理每个地区零售商的订单。<br>零售商向代理商下过一次订单之后，代理商就知道了零售商需要的茅台酒品类之后，下次先备齐零售商的货，这就是服务器缓存。<br>以后零售商没库存就找代理商下单，代理商有库存就发货给零售商，没库存可再把订单发给茅台总公司要货。<br>零售商也不用每次跑到贵州进货了，直接找当地代理商就好了，大大提高了效率。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4538003-c43fd9381a3c67f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="缓存流程"></p>
<h4 id="缓存控制"><a href="#缓存控制" class="headerlink" title="缓存控制"></a>缓存控制</h4><p>仅仅有缓存还不够，还需要通过HTTP协议控制服务端缓存和客户端缓存。<br>服务端和客户端均能通过头部字段控制客户端缓存资源，下面分别介绍服务端和客户端的缓存控制。</p>
<h4 id="客户端缓存控制"><a href="#客户端缓存控制" class="headerlink" title="客户端缓存控制"></a>客户端缓存控制</h4><p>客户端在请求头中使用头部字段控制缓存的使用，比如缓存要符合指定时间才使用，使用缓存的条件，相当于零售商只卖在保质期1年内的茅台。<br>服务器在响应头中使用缓存字段控制缓存的存储，比如存储时间，是否缓存资源等等，相当于茅台公司控制茅台酒的保值期为3年，限制零售商、代理商是否能多进货有多余库存。<br>下面一一介绍缓存控制的相关头部字段。</p>
<h5 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h5><p><strong><code>Cache-Control</code>: 通用首部，表示缓存控制的方式，实现缓存机制，可以在请求头和响应头中使用。</strong></p>
<h6 id="请求头中使用"><a href="#请求头中使用" class="headerlink" title="请求头中使用"></a>请求头中使用</h6><p>请求头中的用法，表示客户端中从<strong>缓存时间和缓存模式</strong>两个方面管理缓存。<br>前三个表示缓存时间，后4个表示缓存模式。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-age=&lt;seconds&gt;</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-stale[=&lt;seconds&gt;]</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>min-fresh=&lt;seconds&gt;</span><br><span class="line"><span class="attribute">Cache-control</span><span class="punctuation">: </span>no-cache</span><br><span class="line"><span class="attribute">Cache-control</span><span class="punctuation">: </span>no-store</span><br><span class="line"><span class="attribute">Cache-control</span><span class="punctuation">: </span>no-transform</span><br><span class="line"><span class="attribute">Cache-control</span><span class="punctuation">: </span>only-if-cached</span><br></pre></td></tr></table></figure>

<p>3个缓存时间相关的值：</p>
<p>缓存时间是客户端和服务端协商的结果，是期望服务端对应的缓存参数。</p>
<ul>
<li><p><code>max-age</code>:表示缓存的过期时间，超过过期时间，资源过期，客户端会向服务器请求，可以理解成商品的保质期。<br>比如<code>max-age=20</code>，表示保质期是20秒，如果资源缓存超过了20秒，视为过期，重新请求新资源。<br>希望服务端响应头返回<code>Cache-Control:max-age = 20</code>。</p>
</li>
<li><p><code>max-stale</code>: 表示最大过期时间，缓存资源如果过期，但是在该时间范围内还可以被使用。<br>比如<code>max-stable = 5，max-age=20</code>,如果资源在本地保存了23秒超过20秒保质期，已经过期了。过期时间为3秒，在5秒以内，资源还可以被使用。<br>就好比罐头虽然过期了3天，但是过期时间还不久，兜里没钱也能凑活吃。</p>
</li>
<li><p><code>min-fresh</code>: 表示最小新鲜时间，表示缓存资源几秒之后还没有过期，缓存要满足<code>min-fresh+资源本地保存时间&lt;保质期</code>才可以被使用。<br> 比如还有<code>max-age=20 min-fresh=2</code>，资源已经在本地保存了19秒，还有1秒就过期了，但是<code>min-fresh</code>要求资源2秒之后还是新鲜的，2+19&#x3D;21&gt;20，所以客户端缓存不能使用了。</p>
</li>
</ul>
<p>4个缓存模式相关的值：</p>
<ul>
<li><code>no-store</code>: 不使用缓存，每次向服务器请求最新资源，相当于零售商不使用库存的茅台，每次都向茅台总公司进货。</li>
<li><code>no-cache</code>:并不是不使用缓存，而是使用缓存之前，先询问服务器，一般配合条件缓存头部后面介绍，好比零售商要用库存的茅台，都要打电话给茅台总公司，询问是否有最新生产的茅台。</li>
<li><code>no-transform</code>: 不得对缓存资源进行转换或转变。</li>
<li><code>only-if-cached</code>：客户端只用已缓存的资源，无论如何都不会向服务器发获取新资源。</li>
</ul>
<h6 id="响应头中使用"><a href="#响应头中使用" class="headerlink" title="响应头中使用"></a>响应头中使用</h6><p>如果没有缓存代理服务器，服务器在响应头使用<code>Cache-control</code>的以下值。</p>
<ul>
<li><code>must-revalidate</code>：一旦资源过期（比如已经超过max-age），再向服务器认证之前，缓存不能使用。</li>
<li><code>no-store</code>:客户端不使用任何缓存。</li>
<li><code>no-cache</code>：客户端可以使用缓存资源，但是使用缓存之前必须要向服务器验证是否过期。</li>
<li><code>max-age</code>：客户端缓存资源的时间，相当于缓存保质期。</li>
</ul>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cache-control</span><span class="punctuation">: </span>must-revalidate</span><br><span class="line"><span class="attribute">Cache-control</span><span class="punctuation">: </span>no-cache</span><br><span class="line"><span class="attribute">Cache-control</span><span class="punctuation">: </span>no-store</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-age=&lt;seconds&gt;</span><br></pre></td></tr></table></figure>

<h5 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h5><p><strong><code>Expires</code>: 响应首部，表示资源过期时间</strong>，比如<code>Expires: Wed, 21 Oct 2019 08:00:00 GMT</code>，比如资源在2019年10月21号，早上8点过期。</p>
<p>但是如果服务器响应头中使用<code>Cache-control:max-age</code>指定了过期时间，会覆盖<code>Expires</code>中的时间。</p>
<h4 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h4><p><code>cache-control</code>可以控制是否使用本地缓存，如果缓存可以使用，一般为了保证缓存的准确性，客户端会请求服务端验证缓存是否符合条件可以被使用。<br>客户端请求头就需要用到HTTP协议中的条件请求字段，一共有5个，<code>If-Modified-Since</code>和<code>If-Unmodified-Since</code>、<code>If-Match</code>和<code>If-None-Match</code>、<code>If-Ranage</code>。</p>
<p><strong>最常被使用的是If-Modified-Since和If-None-Match</strong>。</p>
<h5 id="If-Modified-Since、If-Unmodified-Since和Last-modified"><a href="#If-Modified-Since、If-Unmodified-Since和Last-modified" class="headerlink" title="If-Modified-Since、If-Unmodified-Since和Last-modified"></a>If-Modified-Since、If-Unmodified-Since和Last-modified</h5><ul>
<li><strong><code>Last-modified</code>:响应首部，表示服务器告诉客户端返回资源被修改的日期</strong>，如<code>Wed, 21 Oct 2015 07:28:00 GMT</code>。</li>
<li><strong><code>If-Modified-Since</code>:请求首部，用于<code>GET</code>和<code>HEAD</code>请求，向服务器验证资源在指定日期后是否改变，如果改变返回状态码200，并且带上最新资源</strong>。如果未改变返回状态码 304(Not Modified)，并且不返回资源，客户端使用缓存。</li>
<li><strong><code>If-Unmodified-Since</code>：请求首部，和<code>If-modified-Since</code>意思相反，向服务器验证资源在指定日期后是否未改变</strong>，如果改变返回状态码 412(Precondition Failed) 错误，如果未改变返回状态码200，带上最新的资源。</li>
</ul>
<p>客户端第一次向服务器请求获取资源不会使用条件请求，服务端返回资源，响应头会带上<code>Last-modified</code>，客户端会保存<code>Last-modified</code>的值，即修改日期。<br>当客户端再向服务端请求资源时，<code>If-Modified-Since</code>或<code>If-Unmodified-Since</code>会带上修改日期，让服务器进行验证。</p>
<p><code>Last-modified</code> 相当于零售商第一次进货，茅台总公司告诉零售商茅台的生产日期2019-12-18 15:00:00。<br><code>If-Modified-Since</code> 相当于零售商打电话问茅台总公司，12月18号15点之后有新茅台吗，茅台总公司如果生产新的会提供给零售商，如果没有让他用库存里面的。<br><code>If-Unmodified-Since</code> 相当于零售商打电话问茅台总公司，12月18号15点之后没有新茅台吗，茅台总公司如果生产新的会让零售商加价，如果没有继续供货。</p>
<h5 id="If-Match、If-None-Match和ETag"><a href="#If-Match、If-None-Match和ETag" class="headerlink" title="If-Match、If-None-Match和ETag"></a>If-Match、If-None-Match和ETag</h5><p><strong><code>ETag</code>:响应首部，标示实体标签，是服务器告知客户端资源的唯一标识，主要是用来解决修改时间无法准确区分文件变化的问题</strong>。比如，一个文件在一秒内修改了多次，但因为修改时间是秒级，所以这一秒内的新版本无法区分。</p>
<p><strong><code>If-Match</code>:请求首部，用于<code>GET</code>和<code>HEAD</code>请求，向服务器验证本地资源实体标签和服务端的是否一致</strong>，如果一致返回状态码返回状态码 200，并且带上最新资源，如果不一致返回状态码412（Precondition Failed）先决条件失败。</p>
<p><strong><code>If-None-Match</code>:请求首部，向服务器验证本地资源标签和服务端是否不一致</strong>，如果一致返回状态码304(Not Modified)，如果不一致返回状态码200并且带上服务端最新资源。</p>
<p>和上面一样，客户端<code>If-Match</code>或<code>If-None-Match</code>会带上服务器响应报文中的<code>Etag</code>头部字段的值向服务器验证是否一致。</p>
<p><code>Etag</code>有强弱之分，强<code>ETag</code>使用强比较算法，只有在每一个字节都相同的情况下，才可以认为两个资源是相同的，如<code>&quot;bfc13a64729c4290ef5b2c2730249c88ca92d82d&quot;</code>。<br>弱<code>ETag</code>在值前有个“W&#x2F;”标记，只要求资源在语义上没有变化，但内部可能会有部分发生了改变（例如 HTML 里的标签顺序调整，或者多了几个空格，如<code>W/&quot;67ab43&quot;</code>。</p>
<h5 id="If-Range"><a href="#If-Range" class="headerlink" title="If-Range"></a>If-Range</h5><p><code>If-Range</code>:请求首部，服务器若指定的If-Range字段值和请求资源的ETag值一致时，则作为范围请求处理，否则返回全部资源。</p>
<h5 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h5><p>使用了客户端缓存还要向服务器验证，效率不是还没提高吗？<br>客户端向服务器发送请求，如果验证客户端缓存可用，就不用返回资源数据了，如果不可用再返回资源数据。<br>就好比零售商打电话给茅台公司询问现在库存的茅台符合你们要求吗，不符合我再去贵州提货，如果符合就卖库存里面的，省的我跑一趟了。</p>
<h4 id="服务端缓存控制"><a href="#服务端缓存控制" class="headerlink" title="服务端缓存控制"></a>服务端缓存控制</h4><p>服务端缓存控制会使用缓存代理服务器。<br>客户端请求头中使用的缓存头部，不光控制客户端的缓存，也是要求代理服务器中的缓存资源，代理服务器要根据客户端的请求头部字段返回符合要求的资源。<br>源服务器不光要控制客户端的缓存，也要控制代理服务器的缓存。</p>
<p>代理服务器对于客户端来说是服务端，对于源服务器来说则是客户端，相当于资源的中转站，既不生产资源，也不消费资源。<br>就如同代理商，将茅台总公司的茅台酒转发给零售商，如果无法满足零售商的需求，就告知服茅台总公司生产对应的茅台。</p>
<p>缓存代理服务器可以在请求头和响应头中使用头部字段控制缓存，客户端和源服务器也要对代理服务器进行缓存控制，<code>Cache-Control</code>的语义性也会发生变化。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4538003-852b34e48f560432.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="代理模式"></p>
<h5 id="源服务器"><a href="#源服务器" class="headerlink" title="源服务器"></a>源服务器</h5><p>源服务器中的<code>Cache-Control</code>针对代理服务器和客户端的约束要进行区分。<br>其中<code>max-age</code>、<code>no_store</code>、<code>no_cache</code>和<code>must-revalidate</code>不光能约束客户端，也能约束代理服务器。</p>
<p>但是客户端缓存和代理服务器缓存是不同的，如果源服务器需要对客户端和代理服务器的缓存控制进行区分，源服务器需要使用<code>Cache-control</code>中新的值对代理服务器进行控制。</p>
<p><code>no-transform</code>：代理服务器不能对资源进行转换或转变，包括对报文的修改，比如<code>Content-Encoding</code>、<code>Content-Range</code>、<code>Content-Type</code>等HTTP头不能由代理修改。<br><code>public</code>:表示资源可以在任何地方被缓存，包括客户端和代理服务器。<br><code>private</code>:表示资源只能在客户端缓存，其他任何地方都不能缓存。<br><code>proxy-revalidate</code>:要求代理服务器的缓存过期后必须验证，不约束客户端。<br><code>s-maxage=&lt;seconds&gt;</code>:要求代理服务器的缓存过期时间，不约束客户端。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cache-control</span><span class="punctuation">: </span>no-transform</span><br><span class="line"><span class="attribute">Cache-control</span><span class="punctuation">: </span>public</span><br><span class="line"><span class="attribute">Cache-control</span><span class="punctuation">: </span>private</span><br><span class="line"><span class="attribute">Cache-control</span><span class="punctuation">: </span>proxy-revalidate</span><br><span class="line"><span class="attribute">Cache-control</span><span class="punctuation">: </span>s-maxage=&lt;seconds&gt;</span><br></pre></td></tr></table></figure>

<p>源服务器使用<code>Cache-control</code>中的字段，并组合使用相关的值，对客户端和服务端的缓存进行控制。<br>比如<code>private, max-age=5</code>，代理服务器不能缓存资源，客户端缓存资源的过期时间为5秒。<br><code>max-age=30, proxy-revalidate, no-transform</code>，客户端缓存资源的时间为30秒，代理服务器缓存过期之后必须向服务器请求新的资源，且不能改变资源。</p>
<p>下面流程图完整展示了源服务器对客户端和服务器缓存策略的控制。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4538003-2238f93a1a1f73b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="源服务器缓存控制"></p>
<h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><p>客户端使用<code>Cache-control</code>的值，不光控制客户端本地缓存的使用，也要控制代理服务器缓存的使用。<br><code>max-age</code>、<code>max-stale</code>、<code>min-fresh</code>要求对代理服务器缓存时间的要求，用法上面控制客户端缓存一样。<br><code>no-transform</code>：代理服务器不能改变资源<br><code>only-if-cached</code>：表示只接受代理缓存的数据，不接受源服务器的响应。如果代理上没有缓存或者缓存过期，就应该给客户端返回一个504（Gateway Timeout）。<br><code>no-store</code>：代理服务器不使用任何缓存，直接请求源服务器获取新资源。<br><code>no-cache</code>：代理服务器使用缓存之前，先向源服务器进行验证。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-age=&lt;seconds&gt;</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-stale[=&lt;seconds&gt;]</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>min-fresh=&lt;seconds&gt;</span><br><span class="line"><span class="attribute">Cache-control</span><span class="punctuation">: </span>no-cache</span><br><span class="line"><span class="attribute">Cache-control</span><span class="punctuation">: </span>no-store</span><br><span class="line"><span class="attribute">Cache-control</span><span class="punctuation">: </span>no-transform</span><br><span class="line"><span class="attribute">Cache-control</span><span class="punctuation">: </span>only-if-cached</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">John Doe</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
